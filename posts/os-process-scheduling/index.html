<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>OS 进程调度 - Jinyun's Notes</title><meta name=Description content="进一寸有进一寸的欢喜，退一步有退一步的从容"><meta property="og:title" content="OS 进程调度"><meta property="og:description" content="当多个进程在系统并发执行时，所有进程共享 CPU。当某一 CPU 上运行的进程因阻塞和进程运行结束而使 CPU 可以分配给其它进程使用时，如何从众多就绪的可运行进程中选择一个进程，将 CPU 分配给该进程，使系统有效运行，是多任务操作系统需要解决的问题。"><meta property="og:type" content="article"><meta property="og:url" content="https://imajinyun.xyz/posts/os-process-scheduling/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-08T13:52:45+08:00"><meta property="article:modified_time" content="2023-09-08T13:52:45+08:00"><meta property="og:site_name" content="Jinyun's Notes"><meta name=twitter:card content="summary"><meta name=twitter:title content="OS 进程调度"><meta name=twitter:description content="当多个进程在系统并发执行时，所有进程共享 CPU。当某一 CPU 上运行的进程因阻塞和进程运行结束而使 CPU 可以分配给其它进程使用时，如何从众多就绪的可运行进程中选择一个进程，将 CPU 分配给该进程，使系统有效运行，是多任务操作系统需要解决的问题。"><meta name=application-name content="进一寸有进一寸的欢喜，退一步有退一步的从容"><meta name=apple-mobile-web-app-title content="进一寸有进一寸的欢喜，退一步有退一步的从容"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=https://inotes.oss-cn-beijing.aliyuncs.com/common/201812/logo.svg><link rel=apple-touch-icon sizes=180x180 href=https://imajinyun.xyz/apple-touch-icon.png><link rel=mask-icon href=https://imajinyun.xyz/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=https://imajinyun.xyz/site.webmanifest><link rel=canonical href=https://imajinyun.xyz/posts/os-process-scheduling/><link rel=prev href=https://imajinyun.xyz/posts/wiki-data-size/><link rel=next href=https://imajinyun.xyz/posts/mysql-cheat-sheet/><link rel=preload href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/style.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/style.css></noscript><link rel=stylesheet href=https://imajinyun.xyz/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"OS 进程调度","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/imajinyun.xyz\/posts\/os-process-scheduling\/"},"genre":"posts","keywords":"OS","wordcount":4197,"url":"https:\/\/imajinyun.xyz\/posts\/os-process-scheduling\/","datePublished":"2023-09-08T13:52:45+08:00","dateModified":"2023-09-08T13:52:45+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"作者"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=https://imajinyun.xyz/ title="Jinyun's Notes"><span class=header-title-pre><i class='fa fa-charging-station'></i></span>Jinyun's Notes</a></div><div class=menu><div class=menu-inner><a class=menu-item href=https://imajinyun.xyz/posts/><i class='fa-solid fa-sun'></i> 笔记 </a><a class=menu-item href=https://imajinyun.xyz/tags/><i class='fa-solid fa-tags'></i> 标签 </a><a class=menu-item href=https://imajinyun.xyz/categories/><i class='fa-solid fa-layer-group'></i> 分类 </a><a class=menu-item href=https://imajinyun.xyz/docs/><i class='fa-solid fa-file-word'></i> 文档 </a><a class=menu-item href=https://imajinyun.xyz/links/><i class='fa fa-link'></i> 友链 </a><a class=menu-item href=https://imajinyun.xyz/about/><i class='fa fa-paper-plane'></i> 关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="🐶 Enter keyword search..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=https://imajinyun.xyz/ title="Jinyun's Notes"><span class=header-title-pre><i class='fa fa-charging-station'></i></span>Jinyun's Notes</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="🐶 Enter keyword search..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=https://imajinyun.xyz/posts/ title><i class='fa-solid fa-sun'></i>笔记</a><a class=menu-item href=https://imajinyun.xyz/tags/ title><i class='fa-solid fa-tags'></i>标签</a><a class=menu-item href=https://imajinyun.xyz/categories/ title><i class='fa-solid fa-layer-group'></i>分类</a><a class=menu-item href=https://imajinyun.xyz/docs/ title><i class='fa-solid fa-file-word'></i>文档</a><a class=menu-item href=https://imajinyun.xyz/links/ title><i class='fa fa-link'></i>友链</a><a class=menu-item href=https://imajinyun.xyz/about/ title><i class='fa fa-paper-plane'></i>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">OS 进程调度</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://imajinyun.xyz/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>作者</a></span>&nbsp;<span class=post-category>收录于 <a href=https://imajinyun.xyz/categories/os/><i class="far fa-folder fa-fw" aria-hidden=true></i>OS</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2023-09-08>2023-09-08</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 4197 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 9 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#进程调度的功能和时机>进程调度的功能和时机</a><ul><li><a href=#进程调度的功能>进程调度的功能</a></li><li><a href=#进程调度的时机>进程调度的时机</a></li></ul></li><li><a href=#进程调度算法>进程调度算法</a><ul><li><a href=#选择调度方式和算法的若干准则>选择调度方式和算法的若干准则</a></li><li><a href=#调度算法>调度算法</a></li></ul></li><li><a href=#实时系统中的调度>实时系统中的调度</a><ul><li><a href=#常用的几种实时调度算法>常用的几种实时调度算法</a></li></ul></li><li><a href=#进程切换>进程切换</a></li><li><a href=#多处理器调度>多处理器调度</a><ul><li><a href=#多处理器系统的类型>多处理器系统的类型</a></li><li><a href=#多处理器系统中的进程分配方式>多处理器系统中的进程分配方式</a></li><li><a href=#进程调度方式>进程调度方式</a></li></ul></li><li><a href=#死锁>死锁</a><ul><li><a href=#产生死锁的主要原因和必要条件>产生死锁的主要原因和必要条件</a></li><li><a href=#处理死锁的基本方法>处理死锁的基本方法</a></li><li><a href=#银行家算法>银行家算法</a></li><li><a href=#死锁的检测和解除>死锁的检测和解除</a></li></ul></li></ul></nav></div></div><div class=content id=content><p>当多个进程在系统并发执行时，所有进程共享 CPU。当某一 CPU 上运行的进程因阻塞和进程运行结束而使 CPU 可以分配给其它进程使用时，如何从众多就绪的可运行进程中选择一个进程，将 CPU 分配给该进程，使系统有效运行，是多任务操作系统需要解决的问题。</p><h2 id=进程调度的功能和时机>进程调度的功能和时机</h2><h3 id=进程调度的功能>进程调度的功能</h3><p>进程调度的功能是按照某种策略和算法从就绪态进程中为当前空闲的 CPU 选择在其上运行的新进程。</p><h3 id=进程调度的时机>进程调度的时机</h3><p>当一个进程运行结束、进程阻塞、中断返回、在支持抢占式调度的系统中有比当前运行进程优先级更高的进程到来、当前运行进程的时间片用完时，系统都会通过执行进程调度程序重新进行进程调度。</p><h2 id=进程调度算法>进程调度算法</h2><h3 id=选择调度方式和算法的若干准则>选择调度方式和算法的若干准则</h3><ul><li>周转时间短。</li></ul><p>周转时间：指从作业被提交给系统开始，到作业完成为止的这段时间间隔。</p><ul><li>响应时间快。</li><li>截止时间有保证。</li><li>系统吞吐量高。</li><li>处理机利用率好。</li></ul><h3 id=调度算法>调度算法</h3><ol><li>先来先服务调度算法（FCFS - First Come First Served）</li></ol><p>调度算法：FCFS 就是从就绪队列的队首选择最先到达就绪队列的进程，为该进程分配 CPU。</p><p>性能分析：FCFS 适合 <strong>长</strong> 进程，不利于 <strong>短</strong> 进程，短进程等待时间相对运行时间而言太长。</p><p>假设有 3 个进程 p1、p2、p3 分别在 0、1、2 时刻进入系统，需要的运行时长分别为 24、3、3，如果按 FCFS 调度算法，3 个进程的等待时间和周转时间如下表所示：</p><table><thead><tr><th>进程名称</th><th>进入系统时间</th><th>开始运行时间</th><th>服务时间</th><th>等待时间</th><th>周转时间</th></tr></thead><tbody><tr><td>p1</td><td>0</td><td>0</td><td>24</td><td>0</td><td>24</td></tr><tr><td>p2</td><td>1</td><td>24</td><td>3</td><td>23</td><td>26</td></tr><tr><td>p3</td><td>2</td><td>27</td><td>3</td><td>25</td><td>28</td></tr></tbody></table><ul><li>系统的平均周转时间：T=(24+26+28)/3=26</li><li>平均的带权周转时间：T=(24/24+26/3+28/3)≈6.33</li></ul><ol start=2><li>短进程优先调度算法（SPF - Shortest Process First）</li></ol><p>调度算法：SPF 是从就绪队列中选择估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行完成，或发生某事件而被阻塞放弃处理机时，再重新调度。</p><p>算法优点：有效降低进程的平均等待时间，提高系统的吞吐量。</p><p>算法缺点：</p><ul><li>对长进程不利。如果系统中不断有短进程到来，长进程可能长时间得不到调度。</li><li>不能保证紧迫进程的及时处理，因为该算法不考虑进程的紧迫程度。</li><li>进程的长短根据用户的估计而定，故不一定能真正做到短进程优先。</li></ul><p>假设有 3 个进程 p3、p2、p1 分别在 0、1、2 时刻进入系统，需要的运行时长分别为 24、3、3，如果按 SPF 调度算法，3 个进程的等待时间和周转时间如下表所示：</p><blockquote><ul><li>周转时间=服务时间+等待时间。</li><li>开始运行时间=上一次开始运行时间+上一次服务时间。</li><li>等待时间=开始运行时间-进入系统时间。</li></ul></blockquote><table><thead><tr><th>进程名称</th><th>进入系统时间</th><th>开始运行时间</th><th>服务时间</th><th>等待时间</th><th>周转时间</th></tr></thead><tbody><tr><td>p1</td><td>2</td><td>6</td><td>24</td><td>4</td><td>28</td></tr><tr><td>p2</td><td>1</td><td>3</td><td>3</td><td>2</td><td>5</td></tr><tr><td>p3</td><td>0</td><td>0</td><td>3</td><td>0</td><td>3</td></tr></tbody></table><p>或者</p><table><thead><tr><th>进程名称</th><th>进入系统时间</th><th>开始运行时间</th><th>服务时间</th><th>等待时间</th><th>周转时间</th></tr></thead><tbody><tr><td>p3</td><td>0</td><td>0</td><td>3</td><td>0</td><td>3</td></tr><tr><td>p2</td><td>1</td><td>3</td><td>3</td><td>2</td><td>5</td></tr><tr><td>p1</td><td>2</td><td>6</td><td>24</td><td>4</td><td>28</td></tr></tbody></table><ul><li>系统的平均周转时间：T=(3+5+28)/3=12</li><li>平均的带权周转时间：T=()≈6.33</li></ul><ol><li>优先权调度算法（Priority Scheduling Algorithm）</li></ol><p>调度算法：每个进程都有一个与之关联的优先权。优先权值通常是固定区间的数字（如：0~127）。</p><p>优先权调度算法的类型：</p><ul><li>非抢占式（Nonpreemptive）优先权调度算法：</li><li>抢占式（Preemptive）优先权调度算法：</li></ul><p>优先权的类型：</p><ul><li>静态优先权：在进程创建时刻确定，在进程的整个运行期间保持不变。</li><li>动态优先权：在进程创建时被赋予优先权，随进程的推进或随其等待时间的增加而改变。</li></ul><p>优先权调度算法存在的问题和解决方案：</p><ul><li>存在问题：无穷阻塞，或称为饥饿（Starving）问题。</li><li>解决方案：老化（Aging）技术，以逐渐增加在系统中等待时间很长的进程的优先权，使低优先权进程在等待时间很长的情况下，优先权变高而获得 CPU 的执行。</li></ul><ol start=4><li>时间片轮转调度算法（RR - Round Robin）</li></ol><p>时间片轮转调度算法是现代分时系统中广泛使用的进程调度算法，Unix、Linux 和 Windows 操作系统都采用基于时间片轮转、支持优先权和抢占式调度的混合式进程调度算法。</p><ol start=5><li>多级队列调度算法（Multilevel Queue Scheduling）</li></ol><p>多级队列调度算法将就绪队列分成多个独立队列，根据进程的某些属性，如需要占用的存在大小、进程优先权或进程类型，进程会被永久地分配到一个队列。每个队列有自己的调度算法。不同的队列优先权不同，调度算法也可能不同。</p><p>对于低优先权的进程会存在无穷阻塞（饥饿）问题，而多级反馈队列调度算法可以弥补这些不足。</p><ol start=6><li>多级反馈队列调度（Multilevel Feedback Queue Scheduling）</li></ol><p>多级反馈队列调度算法的设计需要考虑的几个方面的问题：</p><ul><li>就绪队列的数量。</li><li>根据进程优先权确定进程应该进入哪个就绪队列的算法。</li><li>用以确定进程何时转移到较高优先权队列的算法。</li><li>用以确定进程何时转移到较低优先权队列的算法。</li><li>用以确定进程在需要服务时应该进入哪个队列的算法。</li></ul><h2 id=实时系统中的调度>实时系统中的调度</h2><h3 id=常用的几种实时调度算法>常用的几种实时调度算法</h3><ol><li>最早截止时间优先算法（EDF - Earliest Deadline First）。</li><li>最低松弛度优先算法（LLF - Least Laxity First）。</li></ol><p>松弛度：来用表示一个实时进程的紧迫程度。如果一个进程的完成截止时间为 T，当前时间为 T<sub>c</sub>，处理完该任务还需要的时间为 T<sub>s</sub>，则松弛度 L 的计算式表示为：L=T-T<sub>c</sub>-T<sub>s</sub>。</p><p>假设在一个实时系统中，有两个周期性实时进程 A 和 B，要求进程 A 每 20ms 执行一次，执行时间为 10ms。要求进程 B 每 50ms 执行一次，执行时间为 25ms。由此可知进程 A 和 B 每次必须完成的时间分别为：A1、A2、A3&mldr; 和 B1、B2、B3&mldr;，如下图所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>    A1        A2        A3        A4        A5        A6        A7        A8
</span></span><span class=line><span class=cl>    <span class=p>|</span>         <span class=p>|</span>         <span class=p>|</span>         <span class=p>|</span>         <span class=p>|</span>         <span class=p>|</span>         <span class=p>|</span>         <span class=p>|</span>
</span></span><span class=line><span class=cl>    <span class=p>|</span>         <span class=p>|</span>         <span class=p>|</span>         <span class=p>|</span>         <span class=p>|</span>         <span class=p>|</span>         <span class=p>|</span>         <span class=p>|</span>
</span></span><span class=line><span class=cl>----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----&gt; t
</span></span><span class=line><span class=cl>         <span class=m>20</span>        <span class=m>40</span>   <span class=p>|</span>    <span class=m>60</span>        <span class=m>80</span>        <span class=m>100</span>       <span class=m>120</span>       <span class=m>140</span>  <span class=p>|</span>    <span class=m>160</span>
</span></span><span class=line><span class=cl>                        <span class=p>|</span>                        <span class=p>|</span>                        <span class=p>|</span>
</span></span><span class=line><span class=cl>                        <span class=p>|</span>                        <span class=p>|</span>                        <span class=p>|</span>
</span></span><span class=line><span class=cl>                        B1                       B2                       B3
</span></span></code></pre></td></tr></table></div></div><p>对进程 A 和进程 B 采用最低松弛度优先算法，保证两个进程在每个周期都能执行一次。</p><p>采用最低松弛度优先算法的调度时机和调度过程如下图，图中 A1、A2、A3、A4 分别表示进程 A 在第一、二、三、四个周期内的一次连续执行时间，B1、B2 分别表示进程 B 在第一、二个周期内的一次连续执行时间。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>  A1<span class=o>(</span>10<span class=o>)</span>                       A2<span class=o>(</span>10<span class=o>)</span>          A3<span class=o>(</span>10<span class=o>)</span>                   A4<span class=o>(</span>10<span class=o>)</span>
</span></span><span class=line><span class=cl>+--------+                   +---------+    +---------+              +---------+
</span></span><span class=line><span class=cl><span class=p>|</span>        <span class=p>|</span>                   <span class=p>|</span>         <span class=p>|</span>    <span class=p>|</span>         <span class=p>|</span>              <span class=p>|</span>         <span class=p>|</span>
</span></span><span class=line><span class=cl><span class=p>|</span>        <span class=p>|</span>                   <span class=p>|</span>         <span class=p>|</span>    <span class=p>|</span>         <span class=p>|</span>              <span class=p>|</span>         <span class=p>|</span>
</span></span><span class=line><span class=cl>T1       T2                  T3        T4   T5        T6             T7        T8
</span></span><span class=line><span class=cl>---------+---------+---------+---------+----+----+----+----+---------+---------+---------&gt; t
</span></span><span class=line><span class=cl>         <span class=m>10</span>        <span class=m>20</span>        <span class=m>30</span>        <span class=m>40</span>   <span class=p>|</span>    <span class=m>50</span>   <span class=p>|</span>    <span class=m>60</span>        <span class=m>70</span>        <span class=m>80</span>
</span></span><span class=line><span class=cl>         <span class=p>|</span>                   <span class=p>|</span>         <span class=p>|</span>    <span class=p>|</span>         <span class=p>|</span>              <span class=p>|</span>         <span class=p>|</span>
</span></span><span class=line><span class=cl>         <span class=p>|</span>                   <span class=p>|</span>         <span class=p>|</span>    <span class=p>|</span>         <span class=p>|</span>              <span class=p>|</span>         <span class=p>|</span>
</span></span><span class=line><span class=cl>         +-------------------+         +----+         +--------------+         +----------
</span></span><span class=line><span class=cl>                 B1<span class=o>(</span>20<span class=o>)</span>                 B1<span class=o>(</span>5<span class=o>)</span>              B2<span class=o>(</span>15<span class=o>)</span>                 B2<span class=o>(</span>10<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>上图的调度过程如下：</p><table><thead><tr><th>T<sub>n</sub></th><th>L(A)</th><th>L(B)</th><th>Memo</th></tr></thead><tbody><tr><td><code>T1=0</code></td><td>20-T1-10=20-0-10=10</td><td>50-T1-25=50-0-25=25</td><td>L(A)&lt;L(B) => A 执行 10ms</td></tr><tr><td><code>T2=10</code></td><td>40-T2-10=40-10-10=20</td><td>50-T2-25=50-10-25=15</td><td>L(A)>L(B) => B 执行 20ms</td></tr><tr><td><code>T3=30</code></td><td>40-T3-10=40-30-10=0</td><td>50-T3-(25-20)=50-30-5=15</td><td>L(A)&lt;L(B) => A 执行 10ms（25-20 是因为 B1 已经运行了 20ms）</td></tr><tr><td><code>T4=40</code></td><td>60-T4-10=60-40-10=10</td><td>50-T4-(25-20)=50-40-5=5</td><td>L(A)>L(B) => B 执行 5ms</td></tr><tr><td><code>T5=45</code></td><td>60-T5-10=60-45-10=5</td><td>100-T5-25=100-45-25=30</td><td>L(A)&lt;L(B) => A 执行 10ms</td></tr><tr><td><code>T6=55</code></td><td>80-T6-10=80-55-10=15</td><td>100-T6-25=100-55-25=5</td><td>L(A)&lt;L(B) => A 没有进入新的执行周期，B 进程执行 15ms</td></tr><tr><td><code>T7=70</code></td><td>80-T7-10=80-70-10=0</td><td>100-T7-(25-15)=100-70-10=20</td><td>L(A)&lt;L(B) => B 执行 10ms</td></tr><tr><td><code>T7=80</code></td><td>100-T8-10=100-80-10=10</td><td>100-T8-(25-15)=100-80-10=10</td><td>L(A)=L(B) => 松弛度相同时，调度进程需要其它条件支持</td></tr></tbody></table><h2 id=进程切换>进程切换</h2><p>进程切换的步骤：</p><ol><li>保存包括程序计数器和其它寄存器在内的 CPU 上下文环境。</li><li>更新被替换进程的进程控制块。</li><li>修改进程状态，把执行态改为就绪态或者阻塞态。</li><li>将被替换进程的进程控制块移到就绪队列或阻塞队列。</li><li>执行通过进程调度程序选择的新进程，并更新该进程的进程控制块。</li><li>更新内存管理的数据结构。</li><li>恢复被调度程序选中的进程的硬件上下文。</li></ol><h2 id=多处理器调度>多处理器调度</h2><h3 id=多处理器系统的类型>多处理器系统的类型</h3><ol><li>紧密耦合的多处理器系统和松弛耦合的多处理器系统。</li></ol><ul><li>紧密耦合的多处理器系统通常通过高速总线或调整交叉开关实现多个处理器之间的互连，它们共享主存储器系统和 IO 设备，并要求将主存储器划分为若干个独立访问的存储器模块，以便多个处理器能同时对主存进程访问。</li><li>松弛耦合的多处理器系统通常通过通道或通信线路来实现多台计算机之间的互连。每台计算机都有自己的存储器和 IO 设备，并配置了操作系统来管理本地资源和在本地运行的进程。因此，每一台计算机都能独立工作。</li></ul><ol start=2><li>对称多处理器系统和非对称多处理器系统：只有一个主处理器，有多个从处理器。</li></ol><h3 id=多处理器系统中的进程分配方式>多处理器系统中的进程分配方式</h3><ol><li>对称多处理器系统中的进程分配方式。</li><li>非对称多处理器系统中的进程分配方式。</li></ol><h3 id=进程调度方式>进程调度方式</h3><ol><li>自调度。</li><li>成组调度。</li><li>专用处理器分配。</li></ol><h2 id=死锁>死锁</h2><h3 id=产生死锁的主要原因和必要条件>产生死锁的主要原因和必要条件</h3><ol><li><p>死锁产生的主要原因：竞争共享资源且分配资源的顺序不当。</p></li><li><p>死锁产生的必要条件：</p></li></ol><blockquote><p>注意：只有当以下 4 个条件同时满足时才会发生死锁。</p></blockquote><ul><li>互斥条件。</li><li>请求和保持条件。</li><li>不剥夺条件。</li><li>环路等待条件。</li></ul><h3 id=处理死锁的基本方法>处理死锁的基本方法</h3><ol><li>死锁的预防。</li><li>死锁的避免。</li></ol><h3 id=银行家算法>银行家算法</h3><p>1965 年 Dijkstra 提出了一种能够避免死锁的资源分配算法。其思想是一个进程提出资源请求后，系统先进行资源的试分配。然后检测本次的试分配是否使系统处理安全状态，若安全则按试分配方案分配资源，否则不分配资源。</p><ol><li>数据结构。</li></ol><ul><li><code>available[]</code> 是一个一维数组。表示系统中某种资源的可用数量，也就是这种资源可分配的数量。</li><li><code>max[]</code> 是一个 n*m 的二维数组。表示各进程需要各类资源的最大数量。</li><li><code>allocation[]</code> 是二维数组。表示某时刻已分配给进程的某类资源数。</li><li><code>need[]</code> 是二维数组。表示某个进程还需要某类资源的数量。</li></ul><ol start=2><li>算法说明。</li></ol><p>银行家算法分为两个过程：一是进行资源的试分配过程；二是对试分配后系统的状态做安全性检测的过程。经过安全性检测，若试分配后系统安全状态是安全的，则分配资源。若不安全，则阻塞申请资源的进程，暂不为它分配资源。</p><p>资源试分配算法：</p><div class=mermaid id=id-1></div><p>安全性检测算法：安全性检测算法用来判断系统的资源分配状态是否安全。</p><div class=mermaid id=id-2></div><ol><li>实例。</li></ol><p>假设系统中有 5 个进程 p0、p1、p2、p3、p4，有 3 种类型的资源 A、B 和 C。A 类资源有 10 个，B 类资源有 5 个，C 类资源有 7 个。假定在 T0 时刻，系统的资源分配状态如表所示：</p><table><thead><tr><th>进程名称</th><th>Allocation<sub>i</sub>(A,B,C)</th><th>Max(A,B,C)</th><th>Need(A,B,C)</th><th>Available(A,B,C)</th></tr></thead><tbody><tr><td>p0</td><td>(0,1,0)</td><td>(7,5,3)</td><td>(7,4,3)</td><td>(3,3,2)</td></tr><tr><td>p1</td><td>(2,0,0)</td><td>(3,2,2)</td><td>(1,2,2)</td><td></td></tr><tr><td>p2</td><td>(3,0,2)</td><td>(9,0,2)</td><td>(6,0,0)</td><td></td></tr><tr><td>p3</td><td>(2,1,1)</td><td>(2,2,2)</td><td>(0,1,1)</td><td></td></tr><tr><td>p4</td><td>(0,0,2)</td><td>(4,3,3)</td><td>(4,3,1)</td><td></td></tr></tbody></table><p>在 T0 时刻，可以找到一个安全序列 &lt;p1,p3,p4,p0>，系统在 T0 时刻处于安全状态。</p><p>若此时进程 pi 提出资源请求 request<sub>i</sub> = (1,0,2)，通过银行家算法，先进行资源试分配，然后检测试分配后系统在 T1 时刻的状态是否安全。</p><ul><li>对 p1 的请求进行试分配：T0 时刻 request<sub>i</sub> = (1,0,2)，available = (3,3,2)，need<sub>i</sub> = (1,2,2) 可见满足 request<sub>i</sub> &lt;= need<sub>i</sub> 并且 request<sub>i</sub> &lt;= available。所以进行进一步试分配。</li></ul><h3 id=死锁的检测和解除>死锁的检测和解除</h3><ol><li>何时调用检测算法。</li></ol><hr><p>取决于两个因素：一是死锁可能发生的频率；二是当死锁发生时受影响的进程数量。</p><ol start=2><li><p>资源分配图。</p></li><li><p>死锁定理。</p></li></ol><p>定理作用：用于检测系统所处的资源分配状态 S 是否为死锁状态。</p><p>死锁定理：S 为死锁状态的 <strong>充分条件</strong> 是当且仅当 S 状态的资源分配图是不可完全简化的。</p><ol start=4><li>死锁的解除。</li></ol><p>解除死锁的途径：一是终止处于死锁的进程；二是抢占死锁进程占有的资源。</p><p>进程终止：</p><ul><li>终止所有死锁进程。</li><li>一次只终止一个处于死锁的进程，直到死锁解除。</li></ul><p>资源抢占：逐步从进程中抢占资源给其他进程使用，直到死锁环被打破为止。</p><p>抢占来处理死锁，需要处理三个问题：</p><ul><li>抢占哪个进程和哪些资源。</li><li>回滚。</li><li>饥饿：进程因长时间不能获得所需要的资源而无限等待的状态。</li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2023-09-08</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://imajinyun.xyz/posts/os-process-scheduling/ data-title="OS 进程调度" data-hashtags=OS><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://imajinyun.xyz/posts/os-process-scheduling/ data-hashtag=OS><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://imajinyun.xyz/posts/os-process-scheduling/ data-title="OS 进程调度"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://imajinyun.xyz/posts/os-process-scheduling/ data-title="OS 进程调度"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://imajinyun.xyz/posts/os-process-scheduling/ data-title="OS 进程调度"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=https://imajinyun.xyz/tags/os/>OS</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=https://imajinyun.xyz/>主页</a></span></section></div><div class=post-nav><a href=https://imajinyun.xyz/posts/wiki-data-size/ class=prev rel=prev title="Wiki - 兆字节和兆比特"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>Wiki - 兆字节和兆比特</a>
<a href=https://imajinyun.xyz/posts/mysql-cheat-sheet/ class=next rel=next title="MySQL 速查表">MySQL 速查表<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.118.2">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2018 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://imajinyun.xyz/ target=_blank></a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/mermaid@9.1.3/dist/mermaid.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:80},comment:{},data:{"id-1":`%%{
  init: {
    'theme': 'base',
    'themeVariables': {
      'fontSize': '12px',
    }
  }
}%%

graph TD
A[开始] --> B{request<sub>i</sub><=need?}
B -- Y --> C{request<sub>i</sub><=available?}
C -- Y --> D[available=available-request<sub>i</sub>\\nallocation<sub>i</sub>=allocation<sub>i</sub>+request<sub>i</sub>\\nneed<sub>i</sub>=need<sub>i</sub>-request<sub>i</sub>]
D --> E[调用安全检测过程]
E -- Y --> F{本次分配安全吗？}
F -- Y --> F1[分配资源]
F -- N --> F2[阻塞 pi]
B -- N --> Z[出错]`,"id-2":`%%{
  init: {
    'theme': 'base',
    'themeVariables': {
      'fontSize': '12px',
    }
  }
}%%

graph TD
A[开始] --> B[work=available]
B --> C[
for i=0 to i=n-1 do\\n
  finish<sub>i</sub>=false
]
C --> D[while 存在一个 p<sub>i</sub> 且 finish<sub>i</sub>=false 且 need<sub>i</sub><=work do\\nwork=work+allocation<sub>i</sub> 进程运行完可以释放资源，使可分配资源增加\\nend do
]
D --> E{所有 finish<sub>i</sub>=true}
E -- Y --> F1[返回安全的标志]
E -- N --> F2[返回不安全标志]`},search:{algoliaAppID:"MY71JUZ8GH",algoliaIndex:"prod-notes",algoliaSearchKey:"6343a8bc3a547e45d8ea9b9c340842fc",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:30,type:"algolia"}}</script><script type=text/javascript src=https://imajinyun.xyz/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-4TWZ0BV77P",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-4TWZ0BV77P" async></script></body></html>