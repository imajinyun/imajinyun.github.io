<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Go - 分类 - Jinyun's Notes</title><link>https://imajinyun.xyz/categories/go/</link><description>Go - 分类 - Jinyun's Notes</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 08 Nov 2022 13:52:45 +0800</lastBuildDate><atom:link href="https://imajinyun.xyz/categories/go/" rel="self" type="application/rss+xml"/><item><title>Linux Go 运行环境搭建</title><link>https://imajinyun.xyz/posts/linux-go-env/</link><pubDate>Tue, 08 Nov 2022 13:52:45 +0800</pubDate><author>作者</author><guid>https://imajinyun.xyz/posts/linux-go-env/</guid><description>&lt;p>要在 Linux 上运行 Go 代码，需要安装 Go 编译器和设置 Go 环境变量。&lt;/p></description></item><item><title>Go GPM 模型</title><link>https://imajinyun.xyz/posts/go-gpm-model/</link><pubDate>Sat, 15 Oct 2022 21:31:32 +0800</pubDate><author>作者</author><guid>https://imajinyun.xyz/posts/go-gpm-model/</guid><description>基本概念 普通栈：需要调度的 Goroutine 组成的函数栈，是可增长的栈，因为 Goroutine 可以越开越多； 线程栈：需要将 Goroutine 放置到线程上的 M 们组成，实质上 M 也是由 Goroutine 生成的，</description></item><item><title>Go gRPC</title><link>https://imajinyun.xyz/posts/go-grpc/</link><pubDate>Mon, 20 Jun 2022 21:02:02 +0800</pubDate><author>作者</author><guid>https://imajinyun.xyz/posts/go-grpc/</guid><description><![CDATA[<p><code>gRPC</code> 是一个现代的开源高性能远程过程调用（<code>RPC - Remote Procedure Call</code>）框架，可以在任何环境中运行。它可以通过对负载平衡、跟踪、健康检查和身份验证的可插拔支持，有效地连接数据中心内和跨数据中心的服务。它也适用于分布式计算的最后一英里，将设备、移动应用程序和浏览器连接到后端服务。</p>]]></description></item><item><title>Go 连接字符串</title><link>https://imajinyun.xyz/posts/go-concat-string/</link><pubDate>Sun, 25 Jul 2021 20:41:09 +0800</pubDate><author>作者</author><guid>https://imajinyun.xyz/posts/go-concat-string/</guid><description>&lt;p>Go 中连接字符串的方法有很多种，其实掌握一两种较为高效的方法就足够了，其它权当看热闹。&lt;/p></description></item><item><title>Go 正确姿势</title><link>https://imajinyun.xyz/posts/go-correct-posture/</link><pubDate>Sat, 24 Jul 2021 22:28:17 +0800</pubDate><author>作者</author><guid>https://imajinyun.xyz/posts/go-correct-posture/</guid><description>&lt;p>在编写 Go 代码之时，我跟很多新手一样踩了不少坑，感觉非常有必要将那些踩过的坑记录下来以避免下次犯错。很多人说 Go 简单易学，上手容易，可惜我不是那些很多人中的一个，天资愚钝如此，我只能反复学习了。&lt;/p></description></item><item><title>Go 其它测试</title><link>https://imajinyun.xyz/posts/go-other-test/</link><pubDate>Thu, 22 Jul 2021 08:43:23 +0800</pubDate><author>作者</author><guid>https://imajinyun.xyz/posts/go-other-test/</guid><description>&lt;p>Go 的 testing 包除了测试，还提供了运行并验证示例的功能。一方面是文档的效果，是关于某个功能的使用例子；另一方面，可以被当做测试运行。&lt;/p></description></item><item><title>Go 基准测试</title><link>https://imajinyun.xyz/posts/go-benchmark-test/</link><pubDate>Sat, 17 Jul 2021 10:28:28 +0800</pubDate><author>作者</author><guid>https://imajinyun.xyz/posts/go-benchmark-test/</guid><description>&lt;p>Go 语言标准库内置的 &lt;code>testing&lt;/code> 测试框架提供了基准测试（benchmark）的能力，能让我们很容易地对某一段代码进行性能测试。基准测试主要是通过测试 CPU 和 Memory 的效率问题，来评估被测试代码的性能，进而找到更好的解决方案。&lt;/p></description></item><item><title>Go 单元测试</title><link>https://imajinyun.xyz/posts/go-unit-test/</link><pubDate>Fri, 16 Jul 2021 08:43:26 +0800</pubDate><author>作者</author><guid>https://imajinyun.xyz/posts/go-unit-test/</guid><description>&lt;p>Go 语言从开发初期就注意了测试用例的编写。特别是静态语言，由于调试没有动态语言那么方便，所以能最快最方便地编写一个测试用例就显得非常重要了。&lt;/p></description></item><item><title>Go 随机数</title><link>https://imajinyun.xyz/posts/go-random-number/</link><pubDate>Wed, 14 Jul 2021 08:48:18 +0800</pubDate><author>作者</author><guid>https://imajinyun.xyz/posts/go-random-number/</guid><description>&lt;p>在 Go 中的生成的随机数根本就不是随机的，叫伪随机数。它们是用固定的决定论算法计算的。&lt;/p></description></item><item><title>Go 日期时间</title><link>https://imajinyun.xyz/posts/go-date-time/</link><pubDate>Sun, 11 Jul 2021 11:51:23 +0800</pubDate><author>作者</author><guid>https://imajinyun.xyz/posts/go-date-time/</guid><description>&lt;p>Go 中的日期时间使用布局来格式化，通过布局来完成日期时间的格式化和解析。&lt;/p></description></item></channel></rss>