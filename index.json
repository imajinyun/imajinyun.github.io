[{"categories":["PgSQL"],"content":"整理一份私人 PgSQL 速查表。 ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:0:0","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"1. 数据库操作 ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:1:0","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"1.01 查看所有数据库 \\l 或者 \\l+ 或者 SELECT datname FROM pg_catalog.pg_database; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:1:1","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"1.02 列出所有的模式 \\dn 或者 \\dn+ 或者 SELECT schema_name FROM information_schema.schemata; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:1:2","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"1.03 切换数据库 \\c \u003cdatabase_name\u003e ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:1:3","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"1.04 创建数据库 SELECT rolname FROM pg_roles; CREATE DATABASE \u003cdatabase_name\u003e WITH OWNER \u003crole_name\u003e ENCODING 'UTF8' TABLESPACE 'pg_default' LC_COLLATE='en_US.UTF-8' LC_CTYPE='en_US.UTF-8'; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:1:4","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"1.04 重命名数据库 SELECT pg_terminate_backend(pg_stat_activity.pid) FROM pg_stat_activity WHERE datname='old_database_name'; ALTER DATABASE \u003cold_database_name\u003e RENAME TO \u003cnew_database_name\u003e; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:1:5","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"1.05 删除数据库 DROP DATABASE \u003cdatabase_name\u003e; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:1:6","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"1.06 查看数据库创建语句 SHOW CREATE DATABASE \u003cdatabase_name\u003e; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:1:7","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2. 数据表操作 ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:0","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.01 创建表 CREATE TABLE users ( id SERIAL NOT NULL PRIMARY KEY, username VARCHAR(100) NOT NULL DEFAULT '', preferences JSON DEFAULT NULL, actived BOOLEAN DEFAULT TRUE, created_at TIMESTAMP(6) DEFAULT ('now'::text)::timestamp(0) WITH TIME ZONE ); COMMENT ON TABLE users IS '用户表'; COMMENT ON COLUMN users.id IS '主键'; COMMENT ON COLUMN users.username IS '账户名称'; COMMENT ON COLUMN users.preferences IS '偏好信息'; COMMENT ON COLUMN users.actived IS '是否激活'; COMMENT ON COLUMN users.created_at IS '创建日期时间'; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:1","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.02 删除表 DROP TABLE IF EXISTS \u003ctable_name\u003e CASCADE; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:2","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.03 重命名表 ALTER TABLE \u003cold_table_name\u003e RENAME \u003cnew_table_name\u003e; 或者 ALTER TABLE \u003cold_table_name\u003e RENAME TO \u003cnew_table_name\u003e; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:3","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.04 截断表 此操作会清空数据表中的所有数据，请谨慎执行。 TRUNCATE TABLE table_name; -- The TABLE keyword is actually optional TRUNCATE table_name; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:4","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.05 列出表模式 \\d \u003ctable_name\u003e \\d+ \u003ctable_name\u003e SELECT column_name,data_type,character_maximum_length FROM INFORMATION_SCHEMA.COLUMNS WHERE table_name='\u003ctable_name\u003e'; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:5","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.06 列出所有表 \\dt *.*. SELECT * FROM pg_catalog.pg_tables; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:6","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.07 删除表 DELETE TABLE table_name; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:7","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.08 复制表 -- 复制表结构的同时复制数据 CREATE TABLE \u003cnew_table_name\u003e AS SELECT * FROM \u003csrc_table_name\u003e; -- 先复制表结构，再复制表数据 CREATE TABLE \u003cnew_table_name\u003e (LIKE \u003csrc_table_name\u003e); INSERT INTO \u003cnew_table_name\u003e SELECT * FROM \u003csrc_table_name\u003e; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:8","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.09 列出所有数据表 \\dt 或者 \\dt+ 或者 SELECT table_schema,table_name FROM information_schema.tables ORDER BY table_schema,table_name; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:9","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.10 列出表描述 \\dt \u003ctable_name\u003e; 或者 \\dt+ \u003ctable_name\u003e; 或者 \\d \u003ctable_name\u003e; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:10","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.11 列出创建表语句 pg_dump -st \u003ctable_name\u003e \u003cdatabase_name\u003e ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:11","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.12 查看当前数据库 SELECT current_database(); ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:12","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.13 重命名数据库 ALTER DATABASE \u003cold_name\u003e RENAME TO \u003cnew_name\u003e; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:13","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.14 删除当前数据库 DROP DATABASE IF EXISTS \u003cdatabase_name\u003e; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:14","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.15 添加列 ALTER TABLE \u003ctable_name\u003e ADD updated_at DATETIME NOT NULL COMMENT '更新日期时间'; ALTER TABLE \u003ctable_name\u003e ADD nickname VARCHAR(100) NOT NULL; ALTER TABLE \u003ctable_name\u003e ADD actived BOOLEAN DEFAULT TRUE; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:15","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.16 移除列 ALTER TABLE \u003ctable_name\u003e DROP COLUMN \u003ccolumn_name\u003e; -- The COLUMN keyword is actually optional ALTER TABLE \u003ctable_name\u003e DROP \u003ccolumn_name\u003e; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:16","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.17 重命名列 -- MySQL 5.x ALTER TABLE \u003ctable_name\u003e CHANGE \u003cold_column_name\u003e \u003cnew_column_name\u003e VARCHAR(100) NOT NULL; -- MySQL 8.0 ALTER TABLE \u003ctable_name\u003e RENAME COLUMN \u003cold_column_name\u003e TO \u003cnew_column_name\u003e; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:17","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.18 设置列默认值 -- Example: \u003ctable_name\u003e have a default stock of 0 ALTER TABLE \u003ctable_name\u003e ALTER COLUMN stocks integer SET DEFAULT 0; -- Example: \u003ctable_name\u003e are available by default (removed optional COLUMN keyword) ALTER TABLE \u003ctable_name\u003e ALTER available SET DEFAULT true; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:18","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.19 移除列默认值 --Example: \u003ctable_name\u003e have a default stock of 0 ALTER TABLE \u003ctable_name\u003e ALTER COLUMN stocks integer DROP DEFAULT; --Example: \u003ctable_name\u003e are available by default (removed optional COLUMN keyword) ALTER TABLE \u003ctable_name\u003e ALTER available DROP DEFAULT; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:19","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.20 添加 NOT NULL 约束 ALTER TABLE \u003ctable_name\u003e MODIFY stocks INT NOT NULL; ALTER TABLE \u003ctable_name\u003e MODIFY stocks INT NOT NULL DEFAULT 0; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:20","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.21 移除 NOT NULL 约束 ALTER TABLE \u003ctable_name\u003e MODIFY stocks INT; ALTER TABLE \u003ctable_name\u003e MODIFY stocks INT DEFAULT 0; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:21","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.22 添加索引 CREATE INDEX idx_username ON users (username); CREATE INDEX idx_user_org_id ON users (user_id, org_id); CREATE UNIQUE INDEX udx_email ON users (email); CREATE INDEX idx_nickname ON users (nickname(20)); CREATE INDEX idx_reverse_truename ON users (truename DESC); -- MySQL 8.0.13 and higher also supports functional key parts CREATE INDEX idx_line_item ON order_line_items ((product_price * quantity)); ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:22","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.23 移除索引 DROP INDEX \u003cidx_name\u003e ON \u003ctable_name\u003e; DROP INDEX `PRIMARY` ON \u003ctable_name\u003e; ALTER TABLE \u003ctable_name\u003e DROP INDEX \u003cidx_name\u003e; ALTER TABLE \u003ctable_name\u003e DROP PRIMARY KEY; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:23","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"2.24 更改主键顺序 ALTER SEQUENCE \u003ctable_name\u003e.\u003ccolumn_name\u003e RESTART WITH 1000; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:2:24","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"3. 表数据操作 ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:3:0","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"3.01 添加记录 INSERT INTO \u003ctable_name\u003e (username,email) VALUES ('Tony','tony@gmail.com'); INSERT INTO \u003ctable_name\u003e (username,email) VALUES ('John','john@gmail.com'), ('Acme','acme@gmail.com'); INSERT INTO \u003ctable_name_1\u003e (uname,email) SELECT username,email FROM \u003ctable_name_2\u003e WHERE id\u003c1000; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:3:1","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"3.02 更新记录 UPDATE \u003ctable_name\u003e SET stocks=100; UPDATE \u003ctable_name\u003e SET stocks=100,available=true; UPDATE \u003ctable_name\u003e SET stocks=100,available=true WHERE id=1; UPDATE \u003ctable_name\u003e SET stocks=50,available=true WHERE category='Computer'; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:3:2","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"3.03 删除记录 DELETE FROM \u003ctable_name\u003e WHERE id=1; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:3:3","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"3.04 查询记录 SELECT * FROM \u003ctable_name\u003e WHERE id\u003c10; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:3:4","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"4. 其它 ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:4:0","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"4.1 数组比较 SELECT array[1,2,3] = array[1,2,4] as compare1, -- arrays are equal array[1,2,3] \u003c\u003e array[1,2,4] as compare2; -- arrays are not equal SELECT array[1,2,5] \u003e= array[1,2,4] as compare1, array[1,2,5] \u003c= array[1,2,4,5] as compare2; -- This reads as array['a', 'b', 'c'] contains array['a', 'b', 'b', 'a'] SELECT array['a', 'b', 'c'] @\u003e array['a', 'b', 'b', 'a'] as contains; -- this reads as array[1, 1, 4] is contained by array[4, 3, 2, 1] SELECT array[1, 1, 4] \u003c@ array[4, 3, 2, 1] as is_contained_by; SELECT array[1, 2] \u0026\u0026 array[2, 3] as overlap1, array[1, 2] \u0026\u0026 array[3, 4] as overlap2; ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:4:1","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"4.2 连接字符串 SELECT 'Join these ' || 'strings with a number ' || 23; SELECT first_name||' '||last_name as customer_name FROM customer LIMIT 5; SELECT 'Null with ||' || 'will make ' || 'everything disappear' || NULL; SELECT CONCAT('Concat() handles', NULL, ' nulls better', NULL); ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:4:2","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"4.3 创建数组 CREATE TABLE contacts ( first_name VARCHAR, last_name VARCHAR, phone_numbers VARCHAR[] ); CREATE TABLE player_scores ( player_number INTEGER, round_scores INTEGER[] ); CREATE TABLE student_scores ( student_number INTEGER, test_scores DECIMAL[][] ); CREATE TABLE contacts ( first_name VARCHAR, last_name VARCHAR, phone_numbers VARCHAR ARRAY ); CREATE TABLE player_scores ( player_number INTEGER, round_scores INTEGER ARRAY[10] ); ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:4:3","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["PgSQL"],"content":"4.4 插入数据到数组 INSERT INTO contacts (first_name, last_name, phone_numbers) VALUES ('John', 'Doe', ARRAY ['999-876-5432','999-123-4567']); INSERT INTO player_scores (player_number, round_scores) VALUES (10001, ARRAY [95, 92, 96, 97, 98] ); -- multi-dimension arrays must have same array lengths for the inner dimensions INSERT INTO student_scores (student_number, test_scores) VALUES (20001, ARRAY [[1, 95], [2, 94], [3, 98]]); INSERT INTO contacts (first_name, last_name, phone_numbers) VALUES ('Bob', 'Parr', '{\"555-INC-RDBL\"}'); INSERT INTO player_scores (player_number, round_scores) VALUES (10002, '{91, 92, 93, 95, 99}' ); INSERT INTO student_scores (student_number, test_scores) VALUES (20002, '{{1, 96}, {2, 93}, {4, 97}}'); ","date":"2023-09-22","objectID":"/posts/pgsql-cheat-sheet/:4:4","tags":["PgSQL"],"title":"PostgreSQL 速查表","uri":"/posts/pgsql-cheat-sheet/"},{"categories":["OS"],"content":"内存管理的目标是：一方面实现内存分配、内存回收等基本内存管理功能；另一方面要提高内存空间的利用率土和内存的访问速度。 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:0:0","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"1. 存储器的层次结构 存储器系统是一个具有不同容量、成本和访问时间的存储设备的层次结构。 程序的执行遵循 局部性原理。程序执行的局部性原理指出：程序在执行时呈现局部性规律，即在一段较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域。 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:1:0","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"2. 程序的链接和装入 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:2:0","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"2.1 程序的链接 静态链接（Static Linking）：在程序运行前，用链接程序将目标模块链接成一个完整的装入模块。静态链接程序的任务一是对逻辑地址进行修改，二是变换外部调用符号。 动态链接（Runtime Dynamic Linking）：可将某些目标模块的链接推迟到这些模块中的函数被调用执行时才进行。 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:2:1","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"2.2 程序的装入 绝对装入方式。 可重定位装入方式（静态重定位）。 动态运行时装入方式（动态重定位）。 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:2:2","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"3. 连续分配存储管理方式 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:3:0","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"3.1 单一连续分配 单一连续分配方式适用于单用户、单任务的操作系统，它把内存分为系统区和用户区。系统区仅供操作系统使用，用户区供用户使用。 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:3:1","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"3.2 固定分区分配 划分分区的方法 支持固定分区分配的数据结构 固定分区分配的过程 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:3:2","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"3.3 动态分区分配 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:3:3","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"4. 基本分页存储管理方式 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:4:0","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"4.1 分页存储管理的基本原理 基本概念 页（Page）：将一个进程的逻辑地址空间分成若干个大小相等的片，称为页。 页框（Page Frame）：将物理内存空间分成与页大小相同的若干个存储块，称为页框或页帧。 分页存储：在为进程分配内存时，以面框为单位将进程中的若干页分别装入多个可以不相等邻接的面框中。 页内碎片：进程的最后一页一般装不满一个页框，而形成了不可利用的碎片，称为页内碎片，也是一种内部碎片。 页表（Page Table）：是系统为进程建立的数据结构，页表的作用是实现从页号到页框号的映射。 基本分页存储管理方式中的地址结构 若 A 为逻辑地址，L 为页大小，P 为页号，W 为页内偏移量，则有以下计算关系： P=INT(A/L) W=MOD(a/L) 分页地址变换 地址变换的过程： 进程执行，PCB 中页表起始地址和页表长度送 CPU 的页表寄存器。 CPU 访问逻辑单元 A。 由分页地址变换硬件自动将 A 分为页号和页内偏移两部分。 由硬件检索页表，等到 A 所在的页对应的页框号。 页框号和页内偏移地址送物理地址寄存器，计算物理地址。物理地址=页框大小*页框号+页内偏移量。 页大小的选择 在分页系统中，页的大小是由机器的 体系结构 和 操作系统 共同决定的。 一般页的大小为 2 的整数次幂。在目前的计算机系统中，大多选择 4KB 大小的页。 影响页大小设计的因素： 管理内存的开销。 内存的利用率。 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:4:1","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"4.2 快表 为了减少两次访存带来的时间开销，减少 CPU 在有效访存上的时间开销，提高访存速度，在硬件上引入了快表机制。 快表 快表：也称转换后援缓冲（TLB - Translate Look-aside Buffer），是为了提高 CPU 访存速度而采用的专用缓存，用来存放最近被访问过的页表项。 TLB 是关联的快速闪存。TLB 的条目由两部分组成：键和值，键对应页号，值对应页框号。TLB 条目数有限，在 64~1024 个之间。 引入 TLB 之后的地址变换过程 CPU 产生分页的逻辑地址页号和页内偏移后，将该逻辑地址的页号提交给 TLB。 查找 TLB，如果找到页号，则把该页所在的页框号用于形成物理地址。否则（TLB 失效）查找内存页表，从内存页表中找到相应的页表项，读取页所在的页框号，以形成物理地址。 如果所查找的页表项不在 TLB 中，在访问完内存页表后，要把找到的页表项中的页号和页框号写到 TLB 中。如果 TLB 中的条目已满，系统会根据某种策略（如最近最少使用替换）选择一个 TLB 中的条目，用刚访问的页表项信息替换选中的这个 TLB 条目。 引入 TLB 的性能分析 在 TLB 中找到某一个页号对应的页表项的百分比称为 TLB 命中率。 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:4:2","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"4.3 两级和多级页表 从系统性能考虑，不希望用太大的连续地址空间存放页表，解决的办法就是把页表再分页，形成两级或多级页表。 两级页表 多级页表结构 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:4:3","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"4.4 反置页表 反置页表 反置页表的地址映射 地址映射过程： 根据进程号和页号找到页框号。 物理地址=页框号*页框大小+页内偏移地址。 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:4:4","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"4.5 空闲面框的管理 使用位图管理空闲页框 使用空闲页框的链表 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:4:5","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"5. 基于分页的虚拟存储系统 虚拟存储器：指具有请求调入功能和置换功能，能从逻辑上对内存容量进行扩充的一种存储器系统。 虚拟存储技术实现的基本思想：只把进程的一部分装入内存。进程执行过程中，CPU 访问内存时如果发现所访问的内存不在内存中，则通过异常处理将所需要的内容从外存调入内存。 请求调入：将进程的一部分装入内存，其余的部分什么时候需要，什么时候请求系统装入。 置换功能：如果在请求系统装入进程在外存中的某一部分时，没有足够的内存，则由操作系统选择一部分内存中的进程内容换出到外存，以腾出内存空间把当前需要装入到内容调入到内存。 虚拟存储技术的优点： 提高内存利用率土。 提高多道程序度。 把逻辑地址空间和物理地址空间分开，使程序员不用关心物理内存的容量对编程的限制。 虚拟存储系统的特点： 离散性。 多次性。 对换性。 虚拟性。 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:5:0","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"5.1 请求分页中的硬件支持 5.1.1 页表 页表是支持请求分页系统最重要的数据结构，其作用时记录描述页的各种数据，包括在实现逻辑地址到物理地址映射时需要的页号和页框号的对应关系。 +------+---------+----------+---------+-------+ | 页框号| 状态位 P | 访问字段 A | 修改位 M | 保护位 | +------+---------+----------+---------+-------+ 对页表项中的各字段说明： 页框号：存放页所在的页框号。 状态位 P：用来标识页是否在内存中。 访问字段 A：用户记录页最近被访问的情况。 修改位 M：用于标识页最近是否被修改过。 保护位：用于标识页的访问权限。 5.1.2 缺页异常机构 5.1.3 地址变换 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:5:1","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"页分配策略 最少页框数 最少页框数：指能保证进程正常运行所需要的最少面框数。 页分配和置换策略 固定分配策略：指在进程从创建到撤销的过程中，为进程分配的页框数保持不变。 可变分配策略：指在进程从创建到撤销的过程中，为进程分配的页框数是可变的。 局部置换：指发生置换时，只从请求调页进程本身的内存页中选择一个被淘汰的页，以腾出内存页框，装入请求调入的页。 全局置换：指发生置换时，从系统中所有进程的内存页中选择被淘汰的页。 页分配和置换策略： 固定分配局部置换。 可变分配全局置换。 可变分配局部置换。 分配算法 操作系统为进程分配的页框数通常都是大于最少页框数。 页框分配算法： 平均分配算法：采用平均分配算法，如果系统中有 n 个进程，m 个可供分配的内存页框，则为每个进程分配 INT(m/n) 个页框，其余的 MOD[m/n] 个页框可以放入空闲页框缓冲池中。该算法的缺点是不考虑进程规模，可能使大进程分配到的页框与小进程一样多。大进程能进入内存的页数占本进程页总数的比例远远小于小进程，大进程可能因此频繁缺页。 按比例分配算法：为进程分配的页框数=进程页数/所有进程页数的总和*页框数。 在两个进程之间按比例分配 40 个页框，进程 p1 大小为 80 页，进程 p2 大小为 240 页，则为 p1 分配 10 个页框，为 p2 分配 30 个页框，则计算如下： 为 p1 进程分配的页框数=80/(80+240)*40=10。 为 p2 进程分配的页框数=240/(80+240)*40=30。 按比例分配算法的思想是为了优先权高的进程分配较多的页框数，为优先权低的进程分配较少的页框数。 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:5:2","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"页调入策略 1.3何时调入页 系统可以设计成只有在进程需要时才将页调入内存。 在实际系统中，通常是在调入缺页时，把与所缺页相邻的若干页也调入内存中。 从何调入页 从对换区调入：对换区中的页是进程运行前从文件区复制到对换区的。 UNIX 方式：没有被访问过的页都直接从文件区调入。换出页都存放在对换区，曾经运行过而又被换出的页从对换区中调入。 页调入过程 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:5:3","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"页置换算法 最佳置换算法和先进先出置换算法 最近最久未使用 LRU 置换算法 其它置换算法 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:5:4","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"请求分页系统的性能分析 缺页率对有效访问时间的影响 工作集 抖动产生的原因和预防方法 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:5:5","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"6. 分段存储管理 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:6:0","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"6.1 分段机制的引入 解决部分存储空间动态增长、信息共享和信息保护的问题。 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:6:1","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"6.2 分段系统的基本原理 6.2.1 分段 段表的每一个表项记录的信息包括段号、段长和该段的基址，段表存放在内存中。 6.2.2 分段的逻辑地址结构 分段机制的逻辑地址是二维的，由段号和段内的地址组成。 6.2.3 段表 段表是由操作系统维护的用于支持分段存储管理地址映射的数据结构。通常情况下，每个进程有一个段表，段表由段表项构成。每个段表项包含段号、段基址（段的起始地址）和段长（段的大小）三个部分。 6.2.4 分段系统的地址变换 段表项长度是指一个段表项所占用的字节数。 6.2.5 分页和分段的主要区别 分页和分段都属于离散分配方式，都要通过数据结构和硬件的配合来实现逻辑地址到物理地址的映射。 主要区别： 页是按物理单位划分的，分页的引入是为了提高内存的利用率和支持虚拟存储。而段是按逻辑单位划分的，一个段含有一组意义相对完整的信息。引入分段的目的是为了方便程序员编程。 页的大小是固定的。而段的大小不固定，取决于用户编写的程序和编译器。 分页的地址空间是一维的，程序员给出的地址只是一个助记符，已知的逻辑地址是一个数。分段的地址空间是二维的，程序员在标识一个逻辑地址时需要给出两个数：一个是段号，一个是段内偏移。 6.2.6 信息共享 采用分段机制比分页机制更容易实现信息的共享。 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:6:2","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"6.3 段页式存储管理 6.3.1 段页式存储管理的基本原理 在段页式存储管理系统中，将用户进程的逻辑空间先划分成若干个段，每个段再划分成若干个页。进程以页为单位在物理内存中离散存放，每个段中被离散存放的页具有逻辑相关性。 6.3.2 地址变换过程 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:6:3","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["OS"],"content":"7. Linux 的伙伴系统 Linux 的伙伴系统算法把所有的空闲面框分组为 11 个块链表，每个块链表分别包含大小为 1、2、4、8、16、32、64、128、256、512、1024 个连续的页框。对 1024 个页框的最大请求对应着 4MB 大小的连续页框。每个块的第一个页框的物理地址是该块大小的整数倍。 大小为 16 个页框的块，其起始地址是 16*212（212=4096B，这是一个常规页的大小）的倍数。 ","date":"2023-09-20","objectID":"/posts/os-memory-management/:7:0","tags":["OS"],"title":"OS 内存管理","uri":"/posts/os-memory-management/"},{"categories":["MySQL"],"content":"整理一份私人 MySQL 速查表。 ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:0:0","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"1. 数据库操作 ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:1:0","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"1.01 查看所有数据库 SHOW DATABASES; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:1:1","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"1.02 列出所有的模式 SHOW SCHEMAS; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:1:2","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"1.03 切换数据库 USE \u003cdatabase_name\u003e; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:1:3","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"1.04 创建数据库 CREATE DATABASE IF NOT EXISTS \u003cdatabase_name\u003e DEFAULT CHARACTER SET=utf8mb4 DEFAULT COLLATE=utf8mb4_0900_ai_ci; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:1:4","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"1.04 重命名数据库 -- 5.1.7~5.1.23 版本可以用的，但是官方不推荐，会有丢失数据的危险 SHOW PROCESSLIST; KILL \u003cconnection_id\u003e; RENAME DATABASE \u003cold_database_name\u003e TO \u003cnew_database_name\u003e; -- 使用其它方式重命名 CREATE DATABASE \u003cnew_database_name\u003e; CREATE TABLE \u003cnew_database_name.table_name\u003e AS SELECT * FROM \u003cold_database_name.table_name\u003e; DROP DATABASE \u003cold_database_name\u003e; 使用脚本批量操作： #!/usr/bin/env bash tables=$(mysql -uroot -p123456 -Nse \"SELECT table_name FROM information_schema.TABLES WHERE TABLE_SCHEMA='\u003cold_database_name\u003e'\") for table in $tables do mysql -uroot -p123456 -e \"RENAME TABLE \u003cold_database_name\u003e.$table TO \u003cnew_database_name\u003e.$table\" done ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:1:5","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"1.05 删除数据库 DROP DATABASE \u003cdatabase_name\u003e; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:1:6","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"1.06 查看数据库创建语句 SHOW CREATE DATABASE \u003cdatabase_name\u003e; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:1:7","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"2. 数据表操作 ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:2:0","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"2.01 创建表 CREATE TABLE \u003ctable_name\u003e ( id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY COMMENT '主键', -- 自动增长的主键 username VARCHAR(100) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '账户名称', preferences JSON DEFAULT NULL COMMENT '偏好信息', -- JSON 列非常适合存储非结构化数据，并且从 MySQL 5.7.8 版本开始支持 JSON 列 actived BOOLEAN default true COMMENT '是否激活', created_at DATETIME DEFAULT NULL COMMENT '创建日期时间' ) ENGINE=INNODB DEFAULT CHARSET=ubf8mb4 COLLATE=utf8mb4_unicode_ci; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:2:1","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"2.02 删除表 DROP TABLE \u003ctable_name\u003e; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:2:2","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"2.03 重命名表 ALTER TABLE \u003cold_table_name\u003e RENAME \u003cnew_table_name\u003e; 或者 RENAME TABLE \u003cold_table_name\u003e TO \u003cnew_table_name\u003e; 或者 RENAME TABLE \u003ctable_name_1\u003e TO \u003cold_table_name\u003e,\u003cold_table_name\u003e TO \u003ctable_name_2\u003e; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:2:3","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"2.04 截断表 此操作会清空数据表中的所有数据，请谨慎执行。 TRUNCATE TABLE \u003ctable_name\u003e; -- The TABLE keyword is actually optional TRUNCATE \u003ctable_name\u003e; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:2:4","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"2.05 删除表 DELETE TABLE \u003ctable_name\u003e; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:2:5","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"2.06 复制表 CREATE TABLE {new_table} AS SELECT * FROM {src_table}; -- 继承表的定义，即结构。 CREATE TABLE {new_table} LIKE {src_table}; INSERT INTO {new_table} SELECT * FROM {src_table}; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:2:6","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"2.07 列出所有数据表 SHOW TABLES; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:2:7","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"2.08 列出指定表描述 DESC \u003ctable_name\u003e; 或者 DESCRIBE \u003ctable_name\u003e; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:2:8","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"2.9 列出创建表语句 SHOW CREATE TABLE \u003ctable_name\u003e; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:2:9","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"3. 表数据操作 ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:2:10","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"3.01 添加记录 INSERT INTO \u003ctable_name\u003e VALUES ('Tony','tony@gmail.com'); INSERT INTO \u003ctable_name\u003e (uname,email) VALUES ('Tony','tony@gmail.com'); INSERT INTO \u003ctable_name\u003e SET uname='Tony',email='tony@gmail.com'; INSERT INTO \u003ctable_name\u003e (uname,email) VALUES ('John','john@gmail.com'), ('Acme','acme@gmail.com'); INSERT INTO \u003ctable_name_1\u003e (uname,email) SELECT uname,email FROM {table_name_2} WHERE id\u003e1001; INSERT INTO \u003ctable_name\u003e SET info='{\"beta\": true, \"status\": \"for review\", \"test_count\": 1}'; INSERT IGNORE INTO \u003ctable_name\u003e (product_id,product_name,stocks) VALUES (1, 'Product 1', 50); INSERT INTO \u003ctable_name\u003e (product_id,product_name,stocks) VALUES (1, 'Product 1', 45) ON DUPLICATE KEY UPDATE stocks=VALUES(stocks); REPLACE INTO \u003ctable_name\u003e (product_id,product_name,stocks) VALUES (1, 'Product 1', 35) ON DUPLICATE KEY UPDATE stocks = VALUES(stocks); ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:2:11","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"3.02 更新记录 UPDATE \u003ctable_name\u003e SET stocks=100; UPDATE \u003ctable_name\u003e SET stocks=100,available=true; UPDATE \u003ctable_name\u003e SET stocks=100,available=true WHERE product_id=1; UPDATE \u003ctable_name\u003e SET stocks=50,available=true WHERE category='Computer'; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:2:12","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"3.03 删除记录 DELETE FROM \u003ctable_name\u003e WHERE product_id=1; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:2:13","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"3.04 查询记录 SELECT * FROM \u003ctable_name\u003e WHERE product_id\u003c1000 ANS product_name LIKE '%foo%' LIMIT 5; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:2:14","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"4. 表结构管理 ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:3:0","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"4.01 添加列 ALTER TABLE \u003ctable_name\u003e ADD updated_at DATETIME NOT NULL COMMENT '更新日期时间'; ALTER TABLE \u003ctable_name\u003e ADD nickname VARCHAR(100) NOT NULL; ALTER TABLE \u003ctable_name\u003e ADD actived BOOLEAN DEFAULT TRUE; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:3:1","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"4.02 移除列 ALTER TABLE \u003ctable_name\u003e DROP COLUMN {column_name}; -- The COLUMN keyword is actually optional ALTER TABLE \u003ctable_name\u003e DROP {column_name}; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:3:2","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"4.03 重命名列 -- MySQL 5.x ALTER TABLE \u003ctable_name\u003e CHANGE product_name product_full_name VARCHAR(100) NOT NULL; -- MySQL 8.0 ALTER TABLE \u003ctable_name\u003e RENAME COLUMN product_name TO product_full_name; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:3:3","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"4.04 设置列默认值 -- Example: \u003ctable_name\u003e have a default stock of 0 ALTER TABLE \u003ctable_name\u003e ALTER COLUMN stocks integer SET DEFAULT 0; -- Example: \u003ctable_name\u003e are available by default (removed optional COLUMN keyword) ALTER TABLE \u003ctable_name\u003e ALTER available SET DEFAULT true; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:3:4","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"4.05 移除列默认值 --Example: \u003ctable_name\u003e have a default stock of 0 ALTER TABLE \u003ctable_name\u003e ALTER COLUMN stocks integer DROP DEFAULT; --Example: \u003ctable_name\u003e are available by default (removed optional COLUMN keyword) ALTER TABLE \u003ctable_name\u003e ALTER available DROP DEFAULT; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:3:5","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"4.06 添加 NOT NULL 约束 ALTER TABLE \u003ctable_name\u003e MODIFY stocks INT NOT NULL; ALTER TABLE \u003ctable_name\u003e MODIFY stocks INT NOT NULL DEFAULT 0; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:3:6","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"4.07 移除 NOT NULL 约束 ALTER TABLE \u003ctable_name\u003e MODIFY stocks INT; ALTER TABLE \u003ctable_name\u003e MODIFY stocks INT DEFAULT 0; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:3:7","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"4.08 添加索引 CREATE INDEX idx_username ON \u003ctable_name\u003e (username); CREATE INDEX idx_user_org_id ON \u003ctable_name\u003e (user_id, org_id); CREATE UNIQUE INDEX udx_email ON \u003ctable_name\u003e (email); CREATE INDEX idx_nickname ON \u003ctable_name\u003e (nickname(20)); CREATE INDEX idx_reverse_truename ON \u003ctable_name\u003e (truename DESC); -- MySQL 8.0.13 and higher also supports functional key parts CREATE INDEX idx_line_item ON order_line_items ((product_price * quantity)); ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:3:8","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"4.09 移除索引 DROP INDEX idx_name ON \u003ctable_name\u003e; DROP INDEX `PRIMARY` ON \u003ctable_name\u003e; ALTER TABLE \u003ctable_name\u003e DROP INDEX idx_name; ALTER TABLE \u003ctable_name\u003e DROP PRIMARY KEY; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:3:9","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"4.10 创建视图 CREATE OR REPLACE VIEW {view_name} AS \u003cselect statement\u003e; -- A view to show only beta users CREATE VIEW beta_users_vw AS SELECT * FROM \u003ctable_name\u003e WHERE beta = 1; -- A view to limit read access to only certain columns CREATE VIEW users_basic_vw AS SELECT first_name, last_name, telephone_number FROM \u003ctable_name\u003e; -- A view for management so they only need to do a \"SELECT * FROM top_20_customers_vw\" instead of learning a complex SQL CREATE OR REPLACE VIEW top_20_customers_vw AS SELECT c.customer_name, sum(p.price*od.quantity) order_total FROM customers c JOIN orders o USING (customer_id) JOIN order_details od USING (order_id) JOIN products p USING (product_id) GROUP BY c.customer_name ORDER BY order_total DESC LIMIT 20; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:3:10","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"4.11 删除视图 DROP VIEW {view_name}; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:3:11","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"4.12 更改主键顺序 ALTER TABLE \u003ctable_name\u003e AUTO_INCREMENT=1000; ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:3:12","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"5. 其它 ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:4:0","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"5.1 使用 IFNULL mysql\u003e CREATE TABLE `test` ( `id` int unsigned NOT NULL AUTO_INCREMENT, `day` date DEFAULT NULL, `tickets` tinyint unsigned DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci; mysql\u003e INSERT INTO test (day, tickets) VALUES ('2022-10-12',1),('2022-11-13',2),('2023-01-18',NULL),('2023-02-21',3); mysql\u003e SELECT * FROM test; +----+------------+---------+ | id | day | tickets | +----+------------+---------+ | 1 | 2022-10-12 | 1 | | 2 | 2022-11-13 | 2 | | 3 | 2023-01-18 | NULL | | 4 | 2023-02-21 | 3 | +----+------------+---------+ mysql\u003e SELECT day,IFNULL(tickets, 0) FROM test; +------------+--------------------+ | day | IFNULL(tickets, 0) | +------------+--------------------+ | 2022-10-12 | 1 | | 2022-11-13 | 2 | | 2023-01-18 | 0 | | 2023-02-21 | 3 | +------------+--------------------+ ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:4:1","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"5.2 计算百分比 Other MySQL Documentation Installation mysql\u003e SELECT f.title, ROUND(100.0 * (SELECT COUNT(*) FROM film AS f2 WHERE f2.length \u003c= f.length) / totals.film_count, 1) AS percentile FROM film f CROSS JOIN ( SELECT COUNT(*) AS film_count FROM film ) AS totals ORDER BY percentile DESC LIMIT 25; +--------------------+------------+ | title | percentile | +--------------------+------------+ | HOME PITY | 100.0 | | DARN FORRESTER | 100.0 | | MUSCLE BRIGHT | 100.0 | | CONTROL ANTHEM | 100.0 | | SOLDIERS EVOLUTION | 100.0 | | CHICAGO NORTH | 100.0 | | POND SEATTLE | 100.0 | | GANGS PRIDE | 100.0 | | SWEET BROTHERHOOD | 100.0 | | WORST BANGER | 100.0 | | SORORITY QUEEN | 99.0 | | THEORY MERMAID | 99.0 | | CRYSTAL BREAKING | 99.0 | | SMOOCHY CONTROL | 99.0 | | MOONWALKER FOOL | 99.0 | | SONS INTERVIEW | 99.0 | | CONSPIRACY SPIRIT | 99.0 | | KING EVOLUTION | 99.0 | | WIFE TURN | 98.2 | | FRONTIER CABIN | 98.2 | | YOUNG LANGUAGE | 98.2 | | SCALAWAG DUCK | 98.2 | | CATCH AMISTAD | 98.2 | | SEARCHERS WAIT | 97.7 | | BAKED CLEOPATRA | 97.7 | +--------------------+------------+ 25 rows in set (0.36 sec) ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:4:2","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["MySQL"],"content":"5.3 获取每组第一行 SELECT *,row_number() OVER (PARTITION BY rating ORDER BY release_year) as row_num FROM film; WITH myfilm AS ( SELECT *,row_number() OVER (PARTITION BY rating ORDER BY release_year) as row_num FROM film ) SELECT * FROM myfilm WHERE row_num = 1; +---------+------------------+------------------------------------------------------------------------------------------------------+--------------+-------------+----------------------+-----------------+-------------+--------+------------------+--------+----------------------------------+---------------------+---------+ | film_id | title | description | release_year | language_id | original_language_id | rental_duration | rental_rate | length | replacement_cost | rating | special_features | last_update | row_num | +---------+------------------+------------------------------------------------------------------------------------------------------+--------------+-------------+----------------------+-----------------+-------------+--------+------------------+--------+----------------------------------+---------------------+---------+ | 2 | ACE GOLDFINGER | A Astounding Epistle of a Database Administrator And a Explorer who must Find a Car in Ancient China | 2006 | 1 | NULL | 3 | 4.99 | 48 | 12.99 | G | Trailers,Deleted Scenes | 2006-02-15 05:03:42 | 1 | | 1 | ACADEMY DINOSAUR | A Epic Drama of a Feminist And a Mad Scientist who must Battle a Teacher in The Canadian Rockies | 2006 | 1 | NULL | 6 | 0.99 | 86 | 20.99 | PG | Deleted Scenes,Behind the Scenes | 2006-02-15 05:03:42 | 1 | | 7 | AIRPLANE SIERRA | A Touching Saga of a Hunter And a Butler who must Discover a Butler in A Jet Boat | 2006 | 1 | NULL | 6 | 4.99 | 62 | 28.99 | PG-13 | Trailers,Deleted Scenes | 2006-02-15 05:03:42 | 1 | | 8 | AIRPORT POLLOCK | A Epic Tale of a Moose And a Girl who must Confront a Monkey in Ancient India | 2006 | 1 | NULL | 6 | 4.99 | 54 | 15.99 | R | Trailers | 2006-02-15 05:03:42 | 1 | | 3 | ADAPTATION HOLES | A Astounding Reflection of a Lumberjack And a Car who must Sink a Lumberjack in A Baloon Factory | 2006 | 1 | NULL | 7 | 2.99 | 50 | 18.99 | NC-17 | Trailers,Deleted Scenes | 2006-02-15 05:03:42 | 1 | +---------+------------------+------------------------------------------------------------------------------------------------------+--------------+-------------+----------------------+-----------------+-------------+--------+------------------+--------+----------------------------------+---------------------+---------+ 5 rows in set (0.01 sec) ","date":"2023-09-19","objectID":"/posts/mysql-cheat-sheet/:4:3","tags":["MySQL"],"title":"MySQL 速查表","uri":"/posts/mysql-cheat-sheet/"},{"categories":["OS"],"content":"当多个进程在系统并发执行时，所有进程共享 CPU。当某一 CPU 上运行的进程因阻塞和进程运行结束而使 CPU 可以分配给其它进程使用时，如何从众多就绪的可运行进程中选择一个进程，将 CPU 分配给该进程，使系统有效运行，是多任务操作系统需要解决的问题。 ","date":"2023-09-08","objectID":"/posts/os-process-scheduling/:0:0","tags":["OS"],"title":"OS 进程调度","uri":"/posts/os-process-scheduling/"},{"categories":["OS"],"content":"进程调度的功能和时机 ","date":"2023-09-08","objectID":"/posts/os-process-scheduling/:1:0","tags":["OS"],"title":"OS 进程调度","uri":"/posts/os-process-scheduling/"},{"categories":["OS"],"content":"进程调度的功能 进程调度的功能是按照某种策略和算法从就绪态进程中为当前空闲的 CPU 选择在其上运行的新进程。 ","date":"2023-09-08","objectID":"/posts/os-process-scheduling/:1:1","tags":["OS"],"title":"OS 进程调度","uri":"/posts/os-process-scheduling/"},{"categories":["OS"],"content":"进程调度的时机 当一个进程运行结束、进程阻塞、中断返回、在支持抢占式调度的系统中有比当前运行进程优先级更高的进程到来、当前运行进程的时间片用完时，系统都会通过执行进程调度程序重新进行进程调度。 ","date":"2023-09-08","objectID":"/posts/os-process-scheduling/:1:2","tags":["OS"],"title":"OS 进程调度","uri":"/posts/os-process-scheduling/"},{"categories":["OS"],"content":"进程调度算法 ","date":"2023-09-08","objectID":"/posts/os-process-scheduling/:2:0","tags":["OS"],"title":"OS 进程调度","uri":"/posts/os-process-scheduling/"},{"categories":["OS"],"content":"选择调度方式和算法的若干准则 周转时间短。 周转时间：指从作业被提交给系统开始，到作业完成为止的这段时间间隔。 响应时间快。 截止时间有保证。 系统吞吐量高。 处理机利用率好。 ","date":"2023-09-08","objectID":"/posts/os-process-scheduling/:2:1","tags":["OS"],"title":"OS 进程调度","uri":"/posts/os-process-scheduling/"},{"categories":["OS"],"content":"调度算法 先来先服务调度算法（FCFS - First Come First Served） 调度算法：FCFS 就是从就绪队列的队首选择最先到达就绪队列的进程，为该进程分配 CPU。 性能分析：FCFS 适合 长 进程，不利于 短 进程，短进程等待时间相对运行时间而言太长。 假设有 3 个进程 p1、p2、p3 分别在 0、1、2 时刻进入系统，需要的运行时长分别为 24、3、3，如果按 FCFS 调度算法，3 个进程的等待时间和周转时间如下表所示： 进程名称 进入系统时间 开始运行时间 服务时间 等待时间 周转时间 p1 0 0 24 0 24 p2 1 24 3 23 26 p3 2 27 3 25 28 系统的平均周转时间：T=(24+26+28)/3=26 平均的带权周转时间：T=(24/24+26/3+28/3)≈6.33 短进程优先调度算法（SPF - Shortest Process First） 调度算法：SPF 是从就绪队列中选择估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行完成，或发生某事件而被阻塞放弃处理机时，再重新调度。 算法优点：有效降低进程的平均等待时间，提高系统的吞吐量。 算法缺点： 对长进程不利。如果系统中不断有短进程到来，长进程可能长时间得不到调度。 不能保证紧迫进程的及时处理，因为该算法不考虑进程的紧迫程度。 进程的长短根据用户的估计而定，故不一定能真正做到短进程优先。 假设有 3 个进程 p3、p2、p1 分别在 0、1、2 时刻进入系统，需要的运行时长分别为 24、3、3，如果按 SPF 调度算法，3 个进程的等待时间和周转时间如下表所示： 周转时间=服务时间+等待时间。 开始运行时间=上一次开始运行时间+上一次服务时间。 等待时间=开始运行时间-进入系统时间。 进程名称 进入系统时间 开始运行时间 服务时间 等待时间 周转时间 p1 2 6 24 4 28 p2 1 3 3 2 5 p3 0 0 3 0 3 或者 进程名称 进入系统时间 开始运行时间 服务时间 等待时间 周转时间 p3 0 0 3 0 3 p2 1 3 3 2 5 p1 2 6 24 4 28 系统的平均周转时间：T=(3+5+28)/3=12 平均的带权周转时间：T=()≈6.33 优先权调度算法（Priority Scheduling Algorithm） 调度算法：每个进程都有一个与之关联的优先权。优先权值通常是固定区间的数字（如：0~127）。 优先权调度算法的类型： 非抢占式（Nonpreemptive）优先权调度算法： 抢占式（Preemptive）优先权调度算法： 优先权的类型： 静态优先权：在进程创建时刻确定，在进程的整个运行期间保持不变。 动态优先权：在进程创建时被赋予优先权，随进程的推进或随其等待时间的增加而改变。 优先权调度算法存在的问题和解决方案： 存在问题：无穷阻塞，或称为饥饿（Starving）问题。 解决方案：老化（Aging）技术，以逐渐增加在系统中等待时间很长的进程的优先权，使低优先权进程在等待时间很长的情况下，优先权变高而获得 CPU 的执行。 时间片轮转调度算法（RR - Round Robin） 时间片轮转调度算法是现代分时系统中广泛使用的进程调度算法，Unix、Linux 和 Windows 操作系统都采用基于时间片轮转、支持优先权和抢占式调度的混合式进程调度算法。 多级队列调度算法（Multilevel Queue Scheduling） 多级队列调度算法将就绪队列分成多个独立队列，根据进程的某些属性，如需要占用的存在大小、进程优先权或进程类型，进程会被永久地分配到一个队列。每个队列有自己的调度算法。不同的队列优先权不同，调度算法也可能不同。 对于低优先权的进程会存在无穷阻塞（饥饿）问题，而多级反馈队列调度算法可以弥补这些不足。 多级反馈队列调度（Multilevel Feedback Queue Scheduling） 多级反馈队列调度算法的设计需要考虑的几个方面的问题： 就绪队列的数量。 根据进程优先权确定进程应该进入哪个就绪队列的算法。 用以确定进程何时转移到较高优先权队列的算法。 用以确定进程何时转移到较低优先权队列的算法。 用以确定进程在需要服务时应该进入哪个队列的算法。 ","date":"2023-09-08","objectID":"/posts/os-process-scheduling/:2:2","tags":["OS"],"title":"OS 进程调度","uri":"/posts/os-process-scheduling/"},{"categories":["OS"],"content":"实时系统中的调度 ","date":"2023-09-08","objectID":"/posts/os-process-scheduling/:3:0","tags":["OS"],"title":"OS 进程调度","uri":"/posts/os-process-scheduling/"},{"categories":["OS"],"content":"常用的几种实时调度算法 最早截止时间优先算法（EDF - Earliest Deadline First）。 最低松弛度优先算法（LLF - Least Laxity First）。 松弛度：来用表示一个实时进程的紧迫程度。如果一个进程的完成截止时间为 T，当前时间为 Tc，处理完该任务还需要的时间为 Ts，则松弛度 L 的计算式表示为：L=T-Tc-Ts。 假设在一个实时系统中，有两个周期性实时进程 A 和 B，要求进程 A 每 20ms 执行一次，执行时间为 10ms。要求进程 B 每 50ms 执行一次，执行时间为 25ms。由此可知进程 A 和 B 每次必须完成的时间分别为：A1、A2、A3… 和 B1、B2、B3…，如下图所示： A1 A2 A3 A4 A5 A6 A7 A8 | | | | | | | | | | | | | | | | ----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----\u003e t 20 40 | 60 80 100 120 140 | 160 | | | | | | B1 B2 B3 对进程 A 和进程 B 采用最低松弛度优先算法，保证两个进程在每个周期都能执行一次。 采用最低松弛度优先算法的调度时机和调度过程如下图，图中 A1、A2、A3、A4 分别表示进程 A 在第一、二、三、四个周期内的一次连续执行时间，B1、B2 分别表示进程 B 在第一、二个周期内的一次连续执行时间。 A1(10) A2(10) A3(10) A4(10) +--------+ +---------+ +---------+ +---------+ | | | | | | | | | | | | | | | | T1 T2 T3 T4 T5 T6 T7 T8 ---------+---------+---------+---------+----+----+----+----+---------+---------+---------\u003e t 10 20 30 40 | 50 | 60 70 80 | | | | | | | | | | | | | | +-------------------+ +----+ +--------------+ +---------- B1(20) B1(5) B2(15) B2(10) 上图的调度过程如下： Tn L(A) L(B) Memo T1=0 20-T1-10=20-0-10=10 50-T1-25=50-0-25=25 L(A)\u003cL(B) =\u003e A 执行 10ms T2=10 40-T2-10=40-10-10=20 50-T2-25=50-10-25=15 L(A)\u003eL(B) =\u003e B 执行 20ms T3=30 40-T3-10=40-30-10=0 50-T3-(25-20)=50-30-5=15 L(A)\u003cL(B) =\u003e A 执行 10ms（25-20 是因为 B1 已经运行了 20ms） T4=40 60-T4-10=60-40-10=10 50-T4-(25-20)=50-40-5=5 L(A)\u003eL(B) =\u003e B 执行 5ms T5=45 60-T5-10=60-45-10=5 100-T5-25=100-45-25=30 L(A)\u003cL(B) =\u003e A 执行 10ms T6=55 80-T6-10=80-55-10=15 100-T6-25=100-55-25=5 L(A)\u003cL(B) =\u003e A 没有进入新的执行周期，B 进程执行 15ms T7=70 80-T7-10=80-70-10=0 100-T7-(25-15)=100-70-10=20 L(A)\u003cL(B) =\u003e B 执行 10ms T7=80 100-T8-10=100-80-10=10 100-T8-(25-15)=100-80-10=10 L(A)=L(B) =\u003e 松弛度相同时，调度进程需要其它条件支持 ","date":"2023-09-08","objectID":"/posts/os-process-scheduling/:3:1","tags":["OS"],"title":"OS 进程调度","uri":"/posts/os-process-scheduling/"},{"categories":["OS"],"content":"进程切换 进程切换的步骤： 保存包括程序计数器和其它寄存器在内的 CPU 上下文环境。 更新被替换进程的进程控制块。 修改进程状态，把执行态改为就绪态或者阻塞态。 将被替换进程的进程控制块移到就绪队列或阻塞队列。 执行通过进程调度程序选择的新进程，并更新该进程的进程控制块。 更新内存管理的数据结构。 恢复被调度程序选中的进程的硬件上下文。 ","date":"2023-09-08","objectID":"/posts/os-process-scheduling/:4:0","tags":["OS"],"title":"OS 进程调度","uri":"/posts/os-process-scheduling/"},{"categories":["OS"],"content":"多处理器调度 ","date":"2023-09-08","objectID":"/posts/os-process-scheduling/:5:0","tags":["OS"],"title":"OS 进程调度","uri":"/posts/os-process-scheduling/"},{"categories":["OS"],"content":"多处理器系统的类型 紧密耦合的多处理器系统和松弛耦合的多处理器系统。 紧密耦合的多处理器系统通常通过高速总线或调整交叉开关实现多个处理器之间的互连，它们共享主存储器系统和 IO 设备，并要求将主存储器划分为若干个独立访问的存储器模块，以便多个处理器能同时对主存进程访问。 松弛耦合的多处理器系统通常通过通道或通信线路来实现多台计算机之间的互连。每台计算机都有自己的存储器和 IO 设备，并配置了操作系统来管理本地资源和在本地运行的进程。因此，每一台计算机都能独立工作。 对称多处理器系统和非对称多处理器系统：只有一个主处理器，有多个从处理器。 ","date":"2023-09-08","objectID":"/posts/os-process-scheduling/:5:1","tags":["OS"],"title":"OS 进程调度","uri":"/posts/os-process-scheduling/"},{"categories":["OS"],"content":"多处理器系统中的进程分配方式 对称多处理器系统中的进程分配方式。 非对称多处理器系统中的进程分配方式。 ","date":"2023-09-08","objectID":"/posts/os-process-scheduling/:5:2","tags":["OS"],"title":"OS 进程调度","uri":"/posts/os-process-scheduling/"},{"categories":["OS"],"content":"进程调度方式 自调度。 成组调度。 专用处理器分配。 ","date":"2023-09-08","objectID":"/posts/os-process-scheduling/:5:3","tags":["OS"],"title":"OS 进程调度","uri":"/posts/os-process-scheduling/"},{"categories":["OS"],"content":"死锁 ","date":"2023-09-08","objectID":"/posts/os-process-scheduling/:6:0","tags":["OS"],"title":"OS 进程调度","uri":"/posts/os-process-scheduling/"},{"categories":["OS"],"content":"产生死锁的主要原因和必要条件 死锁产生的主要原因：竞争共享资源且分配资源的顺序不当。 死锁产生的必要条件： 注意：只有当以下 4 个条件同时满足时才会发生死锁。 互斥条件。 请求和保持条件。 不剥夺条件。 环路等待条件。 ","date":"2023-09-08","objectID":"/posts/os-process-scheduling/:6:1","tags":["OS"],"title":"OS 进程调度","uri":"/posts/os-process-scheduling/"},{"categories":["OS"],"content":"处理死锁的基本方法 死锁的预防。 死锁的避免。 ","date":"2023-09-08","objectID":"/posts/os-process-scheduling/:6:2","tags":["OS"],"title":"OS 进程调度","uri":"/posts/os-process-scheduling/"},{"categories":["OS"],"content":"银行家算法 1965 年 Dijkstra 提出了一种能够避免死锁的资源分配算法。其思想是一个进程提出资源请求后，系统先进行资源的试分配。然后检测本次的试分配是否使系统处理安全状态，若安全则按试分配方案分配资源，否则不分配资源。 数据结构。 available[] 是一个一维数组。表示系统中某种资源的可用数量，也就是这种资源可分配的数量。 max[] 是一个 n*m 的二维数组。表示各进程需要各类资源的最大数量。 allocation[] 是二维数组。表示某时刻已分配给进程的某类资源数。 need[] 是二维数组。表示某个进程还需要某类资源的数量。 算法说明。 银行家算法分为两个过程：一是进行资源的试分配过程；二是对试分配后系统的状态做安全性检测的过程。经过安全性检测，若试分配后系统安全状态是安全的，则分配资源。若不安全，则阻塞申请资源的进程，暂不为它分配资源。 资源试分配算法： %%{ init: { 'theme': 'base', 'themeVariables': { 'fontSize': '12px', } } }%% graph TD A[开始] --\u003e B{request\u003csub\u003ei\u003c/sub\u003e\u003c=need?} B -- Y --\u003e C{request\u003csub\u003ei\u003c/sub\u003e\u003c=available?} C -- Y --\u003e D[available=available-request\u003csub\u003ei\u003c/sub\u003e\\nallocation\u003csub\u003ei\u003c/sub\u003e=allocation\u003csub\u003ei\u003c/sub\u003e+request\u003csub\u003ei\u003c/sub\u003e\\nneed\u003csub\u003ei\u003c/sub\u003e=need\u003csub\u003ei\u003c/sub\u003e-request\u003csub\u003ei\u003c/sub\u003e] D --\u003e E[调用安全检测过程] E -- Y --\u003e F{本次分配安全吗？} F -- Y --\u003e F1[分配资源] F -- N --\u003e F2[阻塞 pi] B -- N --\u003e Z[出错] 安全性检测算法：安全性检测算法用来判断系统的资源分配状态是否安全。 %%{ init: { 'theme': 'base', 'themeVariables': { 'fontSize': '12px', } } }%% graph TD A[开始] --\u003e B[work=available] B --\u003e C[ for i=0 to i=n-1 do\\n finish\u003csub\u003ei\u003c/sub\u003e=false ] C --\u003e D[while 存在一个 p\u003csub\u003ei\u003c/sub\u003e 且 finish\u003csub\u003ei\u003c/sub\u003e=false 且 need\u003csub\u003ei\u003c/sub\u003e\u003c=work do\\nwork=work+allocation\u003csub\u003ei\u003c/sub\u003e 进程运行完可以释放资源，使可分配资源增加\\nend do ] D --\u003e E{所有 finish\u003csub\u003ei\u003c/sub\u003e=true} E -- Y --\u003e F1[返回安全的标志] E -- N --\u003e F2[返回不安全标志] 实例。 假设系统中有 5 个进程 p0、p1、p2、p3、p4，有 3 种类型的资源 A、B 和 C。A 类资源有 10 个，B 类资源有 5 个，C 类资源有 7 个。假定在 T0 时刻，系统的资源分配状态如表所示： 进程名称 Allocationi(A,B,C) Max(A,B,C) Need(A,B,C) Available(A,B,C) p0 (0,1,0) (7,5,3) (7,4,3) (3,3,2) p1 (2,0,0) (3,2,2) (1,2,2) p2 (3,0,2) (9,0,2) (6,0,0) p3 (2,1,1) (2,2,2) (0,1,1) p4 (0,0,2) (4,3,3) (4,3,1) 在 T0 时刻，可以找到一个安全序列 \u003cp1,p3,p4,p0\u003e，系统在 T0 时刻处于安全状态。 若此时进程 pi 提出资源请求 requesti = (1,0,2)，通过银行家算法，先进行资源试分配，然后检测试分配后系统在 T1 时刻的状态是否安全。 对 p1 的请求进行试分配：T0 时刻 requesti = (1,0,2)，available = (3,3,2)，needi = (1,2,2) 可见满足 requesti \u003c= needi 并且 requesti \u003c= available。所以进行进一步试分配。 ","date":"2023-09-08","objectID":"/posts/os-process-scheduling/:6:3","tags":["OS"],"title":"OS 进程调度","uri":"/posts/os-process-scheduling/"},{"categories":["OS"],"content":"死锁的检测和解除 何时调用检测算法。 取决于两个因素：一是死锁可能发生的频率；二是当死锁发生时受影响的进程数量。 资源分配图。 死锁定理。 定理作用：用于检测系统所处的资源分配状态 S 是否为死锁状态。 死锁定理：S 为死锁状态的 充分条件 是当且仅当 S 状态的资源分配图是不可完全简化的。 死锁的解除。 解除死锁的途径：一是终止处于死锁的进程；二是抢占死锁进程占有的资源。 进程终止： 终止所有死锁进程。 一次只终止一个处于死锁的进程，直到死锁解除。 资源抢占：逐步从进程中抢占资源给其他进程使用，直到死锁环被打破为止。 抢占来处理死锁，需要处理三个问题： 抢占哪个进程和哪些资源。 回滚。 饥饿：进程因长时间不能获得所需要的资源而无限等待的状态。 ","date":"2023-09-08","objectID":"/posts/os-process-scheduling/:6:4","tags":["OS"],"title":"OS 进程调度","uri":"/posts/os-process-scheduling/"},{"categories":["Wiki"],"content":"记录一下数据尺寸大小的基本概念和度量单位。 ","date":"2023-07-29","objectID":"/posts/wiki-data-size/:0:0","tags":["Wiki"],"title":"Wiki - 兆字节和兆比特","uri":"/posts/wiki-data-size/"},{"categories":["Wiki"],"content":"数据尺寸的基本单位 在计算机科学中，位（Bit） 是最基本的数据尺寸单位，它只有两种可能的状态：0 或者 1。然而，位对于描述大规模数据来说过于微小，因此我们通常使用更大的单位——字节（Byte），1 字节等于 8 位。 字节 是计算机存储和处理数据的基础。例如，一个 ASCII 字符（包括大部分的拉丁字母，数字和符号）通常使用一个字节来存储。 ","date":"2023-07-29","objectID":"/posts/wiki-data-size/:1:0","tags":["Wiki"],"title":"Wiki - 兆字节和兆比特","uri":"/posts/wiki-data-size/"},{"categories":["Wiki"],"content":"数据尺寸的常用单位 当我们谈论更大的数据尺寸时，我们通常使用字节的倍数单位来描述： 千字节（KB - KiloByte）：1KB 等于 1024 字节。KB 是文档、小图片或者简短音频文件的常用度量单位。 兆字节（MB - MegaByte）：1MB 等于 1024KB 或者 1,048,576 字节。MB 是高质量图片、MP3 音频文件或者文本电子书的常用度量单位。 吉字节（GB - GigaByte）：1GB 等于 1024MB，或者 1,073,741,824 字节。GB 是大型视频文件、电影或者复杂软件应用的常用度量单位。 太字节（TB - TeraByte）：1TB 等于 1024GB，或者 1,099,511,627,776 字节。TB 是大型数据库、高清电影合集或者大规模云存储的常用度量单位。 拍字节（PB，PetaByte）：1PB 等于 1024TB。 艾字节（EB，ExaByte）：1EB 等于 1024PB。这个单位在互联网公司中被使用，用于描述他们存储和处理的海量数据。 泽字节（ZB，ZettaByte）：1ZB 等于 1024 ZB。 尧字节（YB，YottaByte）：1YB 等于 1024 ZB。 ","date":"2023-07-29","objectID":"/posts/wiki-data-size/:2:0","tags":["Wiki"],"title":"Wiki - 兆字节和兆比特","uri":"/posts/wiki-data-size/"},{"categories":["Wiki"],"content":"数据尺寸的实际影响 数据尺寸的大小对于存储、处理和传输数据都有直接的影响： 存储：存储空间是有限的。如果你的数据尺寸超过了你的存储容量，你将无法保存更多的数据。此外，大尺寸的数据文件还会使得备份和恢复数据更加困难。 处理：数据的尺寸大小直接影响了数据处理的时间。例如，排序一个包含百万条记录的数据集一般会比排序一个包含千条记录的数据集要慢很多。 传输：如果你需要通过网络发送或者接收数据，那么数据的尺寸大小将直接决定了传输的时间。大尺寸的数据文件可能需要很长时间才能完成上传或者下载。 理解数据尺寸的大小及其影响是使用计算机和网络的基本技能。通过合理地管理和处理数据，我们可以提高存储效率，优化数据处理过程，以及提高数据传输的速度。无论你是一名程序员、数据科学家，还是普通的电脑用户，都需要对数据尺寸有一个基本的理解。 ","date":"2023-07-29","objectID":"/posts/wiki-data-size/:3:0","tags":["Wiki"],"title":"Wiki - 兆字节和兆比特","uri":"/posts/wiki-data-size/"},{"categories":["Wiki"],"content":"1MB 与 1Mb 区别 1MB（Megabyte）：表示数据容量等于 1,048,576 或 2^20 字节，也就是兆字节。注意这里的 B 是大写的，它表示 Byte，也就是字节。这个单位通常用于表示文件大小，存储空间等数据容量。 1Mb（Megabit）：表示网络速度等于 1Mb/s，也就是兆比特。注意这里的 b 是小写的，它表示 bit，也就是比特，而不是 Byte 字节。1Mb 的网络速度意味着在每秒钟，网络可以传输 1,000,000 比特的数据。这个单位通常用于表示网络带宽、下载速度等。 由于 1 字节等于 8 比特，因此 1MB 等于 8Mb。换句话说，如果你的网络速度是 1Mb/s，那么在理想状态下（忽略了网络延迟、丢包等问题），你每秒可以下载 0.125MB（1Mb/8bit） 的数据。相当于你要下载一个 1MB 的文件，那么在 1Mb/s 的网络速度下，理想状态下你需要大约 8 秒才能下载完。 ","date":"2023-07-29","objectID":"/posts/wiki-data-size/:4:0","tags":["Wiki"],"title":"Wiki - 兆字节和兆比特","uri":"/posts/wiki-data-size/"},{"categories":["MySQL"],"content":"在我们使用 MySQL 进行开发时，字符集和排序规则是两个非常重要的概念。它们决定了我们如何存储和比较数据，也直接影响了数据的正确性和性能。 ","date":"2023-07-25","objectID":"/posts/mysql-characterset-collation/:0:0","tags":["MySQL"],"title":"MySQL 字符集和排序规则","uri":"/posts/mysql-characterset-collation/"},{"categories":["MySQL"],"content":"概念 字符集（Character Set）：或称字符编码，是一种标准，它定义了字符和字节之间的映射关系。常见的字符集有 ASCII、UTF-8、UTF-16、ISO-8859-1（也叫做 Latin1）等。这些字符集可以处理不同的字符范围，例如 ASCII 只能处理英文字符，而 UTF-8 则可以处理所有的 Unicode 字符，包括各种语言的字符。 排序规则（Collation）：是一种规则，它定义了字符在比较和排序时的行为。排序规则不仅决定了字符的大小写敏感性，还决定了字符的重音敏感性、空格敏感性等。例如：MySQL 的 utf8mb4_general_ci 是一种排序规则，其中的 ci 表示 case insensitive，也就是说这种排序规则在处理字符串比较时不区分大小写。另外，utf8mb4_bin 则是一种二进制排序规则，它在处理字符串比较时会严格区分大小写。 ","date":"2023-07-25","objectID":"/posts/mysql-characterset-collation/:1:0","tags":["MySQL"],"title":"MySQL 字符集和排序规则","uri":"/posts/mysql-characterset-collation/"},{"categories":["MySQL"],"content":"字符集 字符集问题不仅影响数据存储，还影响客户端程序与 MySQL 服务器之间的通信。如果客户端程序使用与默认字符集不同的字符集与服务器进行通信，需要指定使用哪个字符集。例如，要使用 utf8mb4 Unicode 字符集，需要在连接到服务器后发出以下语句： -- 修改客户端的显示的字符编码，解决有些默认客户端显示问号的情况 mysql\u003e SET NAMES 'utf8mb4'; Query OK, 0 rows affected (0.00 sec) 查看可用的字符集： mysql\u003e SELECT * FROM INFORMATION_SCHEMA.CHARACTER_SETS; +--------------------+----------------------+---------------------------------+--------+ | CHARACTER_SET_NAME | DEFAULT_COLLATE_NAME | DESCRIPTION | MAXLEN | +--------------------+----------------------+---------------------------------+--------+ | big5 | big5_chinese_ci | Big5 Traditional Chinese | 2 | | dec8 | dec8_swedish_ci | DEC West European | 1 | | cp850 | cp850_general_ci | DOS West European | 1 | | hp8 | hp8_english_ci | HP West European | 1 | | koi8r | koi8r_general_ci | KOI8-R Relcom Russian | 1 | | latin1 | latin1_swedish_ci | cp1252 West European | 1 | | latin2 | latin2_general_ci | ISO 8859-2 Central European | 1 | | swe7 | swe7_swedish_ci | 7bit Swedish | 1 | | ascii | ascii_general_ci | US ASCII | 1 | | ujis | ujis_japanese_ci | EUC-JP Japanese | 3 | | sjis | sjis_japanese_ci | Shift-JIS Japanese | 2 | | hebrew | hebrew_general_ci | ISO 8859-8 Hebrew | 1 | | tis620 | tis620_thai_ci | TIS620 Thai | 1 | | euckr | euckr_korean_ci | EUC-KR Korean | 2 | | koi8u | koi8u_general_ci | KOI8-U Ukrainian | 1 | | gb2312 | gb2312_chinese_ci | GB2312 Simplified Chinese | 2 | | greek | greek_general_ci | ISO 8859-7 Greek | 1 | | cp1250 | cp1250_general_ci | Windows Central European | 1 | | gbk | gbk_chinese_ci | GBK Simplified Chinese | 2 | | latin5 | latin5_turkish_ci | ISO 8859-9 Turkish | 1 | | armscii8 | armscii8_general_ci | ARMSCII-8 Armenian | 1 | | utf8mb3 | utf8mb3_general_ci | UTF-8 Unicode | 3 | | ucs2 | ucs2_general_ci | UCS-2 Unicode | 2 | | cp866 | cp866_general_ci | DOS Russian | 1 | | keybcs2 | keybcs2_general_ci | DOS Kamenicky Czech-Slovak | 1 | | macce | macce_general_ci | Mac Central European | 1 | | macroman | macroman_general_ci | Mac West European | 1 | | cp852 | cp852_general_ci | DOS Central European | 1 | | latin7 | latin7_general_ci | ISO 8859-13 Baltic | 1 | | cp1251 | cp1251_general_ci | Windows Cyrillic | 1 | | utf16 | utf16_general_ci | UTF-16 Unicode | 4 | | utf16le | utf16le_general_ci | UTF-16LE Unicode | 4 | | cp1256 | cp1256_general_ci | Windows Arabic | 1 | | cp1257 | cp1257_general_ci | Windows Baltic | 1 | | utf32 | utf32_general_ci | UTF-32 Unicode | 4 | | binary | binary | Binary pseudo charset | 1 | | geostd8 | geostd8_general_ci | GEOSTD8 Georgian | 1 | | cp932 | cp932_japanese_ci | SJIS for Windows Japanese | 2 | | eucjpms | eucjpms_japanese_ci | UJIS for Windows Japanese | 3 | | gb18030 | gb18030_chinese_ci | China National Standard GB18030 | 4 | | utf8mb4 | utf8mb4_0900_ai_ci | UTF-8 Unicode | 4 | +--------------------+----------------------+---------------------------------+--------+ 41 rows in set (0.08 sec) mysql\u003e SHOW CHARACTER SET; +----------+---------------------------------+---------------------+--------+ | Charset | Description | Default collation | Maxlen | +----------+---------------------------------+---------------------+--------+ | armscii8 | ARMSCII-8 Armenian | armscii8_general_ci | 1 | | ascii | US ASCII | ascii_general_ci | 1 | | big5 | Big5 Traditional Chinese | big5_chinese_ci | 2 | | binary | Binary pseudo charset | binary | 1 | | cp1250 | Windows Central European | cp1250_general_ci | 1 | | cp1251 | Windows Cyrillic | cp1251_general_ci | 1 | | cp1256 | Windows Arabic | cp1256_general_ci | 1 | | cp1257 | Windows Baltic | cp1257_general_ci | 1 | | cp850 | DOS West European | cp850_general_ci | 1 | | cp852 | DOS Central European | cp852_general_ci | 1 | | cp866 | DOS Russian | cp866_general_ci | 1 | | cp932 | SJIS for Windows Japanese | cp932_japanese_ci | 2 | | dec8 | DEC West European | dec8_swedish_ci | 1 | | eucjpms | UJIS for Windows Japanese | eucjpms_japanese_ci | 3 | | euckr | EUC-KR Korean | euckr_korean_ci | 2 | | gb18030 | China National Standard GB18030 | gb180","date":"2023-07-25","objectID":"/posts/mysql-characterset-collation/:2:0","tags":["MySQL"],"title":"MySQL 字符集和排序规则","uri":"/posts/mysql-characterset-collation/"},{"categories":["MySQL"],"content":"排序规则 查看当前支持的排序规则： mysql\u003e SHOW COLLATION WHERE Charset='utf8mb4'; +----------------------------+---------+-----+---------+----------+---------+---------------+ | Collation | Charset | Id | Default | Compiled | Sortlen | Pad_attribute | +----------------------------+---------+-----+---------+----------+---------+---------------+ | utf8mb4_0900_ai_ci | utf8mb4 | 255 | Yes | Yes | 0 | NO PAD | | utf8mb4_0900_as_ci | utf8mb4 | 305 | | Yes | 0 | NO PAD | | utf8mb4_0900_as_cs | utf8mb4 | 278 | | Yes | 0 | NO PAD | | utf8mb4_0900_bin | utf8mb4 | 309 | | Yes | 1 | NO PAD | | utf8mb4_bg_0900_ai_ci | utf8mb4 | 318 | | Yes | 0 | NO PAD | | utf8mb4_bg_0900_as_cs | utf8mb4 | 319 | | Yes | 0 | NO PAD | | utf8mb4_bin | utf8mb4 | 46 | | Yes | 1 | PAD SPACE | | utf8mb4_bs_0900_ai_ci | utf8mb4 | 316 | | Yes | 0 | NO PAD | | utf8mb4_bs_0900_as_cs | utf8mb4 | 317 | | Yes | 0 | NO PAD | | utf8mb4_croatian_ci | utf8mb4 | 245 | | Yes | 8 | PAD SPACE | | utf8mb4_cs_0900_ai_ci | utf8mb4 | 266 | | Yes | 0 | NO PAD | | utf8mb4_cs_0900_as_cs | utf8mb4 | 289 | | Yes | 0 | NO PAD | | utf8mb4_czech_ci | utf8mb4 | 234 | | Yes | 8 | PAD SPACE | | utf8mb4_danish_ci | utf8mb4 | 235 | | Yes | 8 | PAD SPACE | | utf8mb4_da_0900_ai_ci | utf8mb4 | 267 | | Yes | 0 | NO PAD | | utf8mb4_da_0900_as_cs | utf8mb4 | 290 | | Yes | 0 | NO PAD | | utf8mb4_de_pb_0900_ai_ci | utf8mb4 | 256 | | Yes | 0 | NO PAD | | utf8mb4_de_pb_0900_as_cs | utf8mb4 | 279 | | Yes | 0 | NO PAD | | utf8mb4_eo_0900_ai_ci | utf8mb4 | 273 | | Yes | 0 | NO PAD | | utf8mb4_eo_0900_as_cs | utf8mb4 | 296 | | Yes | 0 | NO PAD | | utf8mb4_esperanto_ci | utf8mb4 | 241 | | Yes | 8 | PAD SPACE | | utf8mb4_estonian_ci | utf8mb4 | 230 | | Yes | 8 | PAD SPACE | | utf8mb4_es_0900_ai_ci | utf8mb4 | 263 | | Yes | 0 | NO PAD | | utf8mb4_es_0900_as_cs | utf8mb4 | 286 | | Yes | 0 | NO PAD | | utf8mb4_es_trad_0900_ai_ci | utf8mb4 | 270 | | Yes | 0 | NO PAD | | utf8mb4_es_trad_0900_as_cs | utf8mb4 | 293 | | Yes | 0 | NO PAD | | utf8mb4_et_0900_ai_ci | utf8mb4 | 262 | | Yes | 0 | NO PAD | | utf8mb4_et_0900_as_cs | utf8mb4 | 285 | | Yes | 0 | NO PAD | | utf8mb4_general_ci | utf8mb4 | 45 | | Yes | 1 | PAD SPACE | | utf8mb4_german2_ci | utf8mb4 | 244 | | Yes | 8 | PAD SPACE | | utf8mb4_gl_0900_ai_ci | utf8mb4 | 320 | | Yes | 0 | NO PAD | | utf8mb4_gl_0900_as_cs | utf8mb4 | 321 | | Yes | 0 | NO PAD | | utf8mb4_hr_0900_ai_ci | utf8mb4 | 275 | | Yes | 0 | NO PAD | | utf8mb4_hr_0900_as_cs | utf8mb4 | 298 | | Yes | 0 | NO PAD | | utf8mb4_hungarian_ci | utf8mb4 | 242 | | Yes | 8 | PAD SPACE | | utf8mb4_hu_0900_ai_ci | utf8mb4 | 274 | | Yes | 0 | NO PAD | | utf8mb4_hu_0900_as_cs | utf8mb4 | 297 | | Yes | 0 | NO PAD | | utf8mb4_icelandic_ci | utf8mb4 | 225 | | Yes | 8 | PAD SPACE | | utf8mb4_is_0900_ai_ci | utf8mb4 | 257 | | Yes | 0 | NO PAD | | utf8mb4_is_0900_as_cs | utf8mb4 | 280 | | Yes | 0 | NO PAD | | utf8mb4_ja_0900_as_cs | utf8mb4 | 303 | | Yes | 0 | NO PAD | | utf8mb4_ja_0900_as_cs_ks | utf8mb4 | 304 | | Yes | 24 | NO PAD | | utf8mb4_latvian_ci | utf8mb4 | 226 | | Yes | 8 | PAD SPACE | | utf8mb4_la_0900_ai_ci | utf8mb4 | 271 | | Yes | 0 | NO PAD | | utf8mb4_la_0900_as_cs | utf8mb4 | 294 | | Yes | 0 | NO PAD | | utf8mb4_lithuanian_ci | utf8mb4 | 236 | | Yes | 8 | PAD SPACE | | utf8mb4_lt_0900_ai_ci | utf8mb4 | 268 | | Yes | 0 | NO PAD | | utf8mb4_lt_0900_as_cs | utf8mb4 | 291 | | Yes | 0 | NO PAD | | utf8mb4_lv_0900_ai_ci | utf8mb4 | 258 | | Yes | 0 | NO PAD | | utf8mb4_lv_0900_as_cs | utf8mb4 | 281 | | Yes | 0 | NO PAD | | utf8mb4_mn_cyrl_0900_ai_ci | utf8mb4 | 322 | | Yes | 0 | NO PAD | | utf8mb4_mn_cyrl_0900_as_cs | utf8mb4 | 323 | | Yes | 0 | NO PAD | | utf8mb4_nb_0900_ai_ci | utf8mb4 | 310 | | Yes | 0 | NO PAD | | utf8mb4_nb_0900_as_cs | utf8mb4 | 311 | | Yes | 0 | NO PAD | | utf8mb4_nn_0900_ai_ci | utf8mb4 | 312 | | Yes | 0 | NO PAD | | utf8mb4_nn_0900_as_cs | utf8mb4 | 313 | | Yes | 0 | NO PAD | | utf8mb4_persian_ci | utf8mb4 | 240 | | Yes | 8 | PAD SPACE | | utf8mb4_pl_0900_ai_ci | utf8mb4 | 261 | | Yes | 0 | NO PAD ","date":"2023-07-25","objectID":"/posts/mysql-characterset-collation/:3:0","tags":["MySQL"],"title":"MySQL 字符集和排序规则","uri":"/posts/mysql-characterset-collation/"},{"categories":["MySQL"],"content":"对数据库和数据表的操作 创建数据库时指定： mysql\u003e CREATE DATABASE IF NOT EXISTS db_name DEFAULT CHARSET utf8mb4 COLLATE utf8mb4_0900_ai_ci; Query OK, 1 row affected (0.05 sec) mysql\u003e SHOW CREATE DATABASE db_name; +----------+-----------------------------------------------------------------------------------------------------------------------------------+ | Database | Create Database | +----------+-----------------------------------------------------------------------------------------------------------------------------------+ | db_name | CREATE DATABASE `db_name` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */ | +----------+-----------------------------------------------------------------------------------------------------------------------------------+ 1 row in set (0.04 sec) 指定表和列的字符集和排序规则： mysql\u003e USE db_name; Database changed mysql\u003e CREATE TABLE tb_name( -\u003e id CHAR(32) COLLATE utf8mb4_0900_ai_ci NOT NULL, -\u003e name VARCHAR(255) COLLATE utf8mb4_0900_ai_ci NOT NULL, -\u003e PRIMARY KEY(id) -\u003e ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci; Query OK, 0 rows affected (0.14 sec) mysql\u003e SHOW CREATE TABLE tb_name; +---------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | Table | Create Table | +---------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | tb_name | CREATE TABLE `tb_name` ( `id` char(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL, `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci | +---------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ 1 row in set (0.02 sec) 修改数据库的字符集和排序无则： mysql\u003e ALTER DATABASE db_name CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci; Query OK, 1 row affected (0.02 sec) mysql\u003e SHOW CREATE DATABASE db_name; +----------+-----------------------------------------------------------------------------------------------------------------------------------+ | Database | Create Database | +----------+-----------------------------------------------------------------------------------------------------------------------------------+ | db_name | CREATE DATABASE `db_name` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */ | +----------+-----------------------------------------------------------------------------------------------------------------------------------+ 1 row in set (0.04 sec) 修改数据表的字符集和排序规则： mysql\u003e ALTER TABLE tb_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci; Query OK, 0 rows affected (0.07 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql\u003e SHOW CREATE TABLE tb_name; +---------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | Table | Create Table | +---------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | tb_name | CREATE TABLE `tb_name` ( `id","date":"2023-07-25","objectID":"/posts/mysql-characterset-collation/:4:0","tags":["MySQL"],"title":"MySQL 字符集和排序规则","uri":"/posts/mysql-characterset-collation/"},{"categories":["Linux"],"content":"Systemd 是 Linux 系统工具，是用来启动守护进程的，已经成为大多数发行版的标配了。每次用起来我能顺手的也就启动重启停止，其它的都要查，烦死了，还不如干脆记录一下。 ","date":"2023-04-17","objectID":"/posts/linux-systemd/:0:0","tags":["Linux"],"title":"Linux Systemd","uri":"/posts/linux-systemd/"},{"categories":["Linux"],"content":"Systemd 背景 在操作系统中，init 进程是一个特殊的进程，它是系统启动后运行的第一个进程。init 进程负责启动和管理其他系统进程，并在系统运行期间一直存在。它是操作系统中所有其他进程的祖先。 关于 init 进程的一些信息： 进程标识符：init 进程始终具有进程标识符 (PID) 为 1 的属性。这使得其他进程可以轻松地将其子进程传递给 init 进程进行管理，从而避免产生僵尸进程。 启动其他进程：init 进程负责启动其他系统进程，例如：守护进程、服务、用户空间应用程序等。通常，init 进程根据系统的初始化脚本或配置文件来启动这些进程。 管理孤儿进程：当一个父进程终止，而其子进程仍在运行时，这些子进程会成为孤儿进程。init 进程会自动采纳这些孤儿进程，并负责回收它们的资源，防止系统出现僵尸进程。 系统关机与重启：init 进程在系统关机或重启时负责正确地终止其他进程。它会按照预定顺序发送信号，通知进程执行清理操作并安全退出。 不同的 init 系统：随着时间的推移，有多种 init 系统出现，包括 System V init、Upstart 和 systemd。其中，System V init 是最早的 init 系统，而 systemd 目前是许多 Linux 发行版中的默认 init 系统，因为它提供了许多先进功能，如并行启动、进程监控和日志管理。 System V init 的缺点： 启动速度：System V init 使用串行启动过程，即一个进程启动完成后，才能启动下一个进程。这导致了系统启动速度较慢。现代的 init 系统，如 systemd，采用并行启动策略，可以大大提高系统启动速度。 依赖管理：System V init 对进程间的依赖关系管理不足。如果一个服务依赖于另一个服务，System V init 无法确保依赖项已启动。这可能导致启动失败或错误。相比之下，systemd 等现代 init 系统具有更好的依赖管理。 进程监控：System V init 在进程崩溃时无法自动重启进程。这可能导致系统不稳定，需要手动干预。systemd 等替代方案提供了自动进程监控和重启功能，以提高系统的可靠性。 日志管理：System V init 缺乏统一的日志管理。每个进程可能有自己的日志记录方式，这使得日志分析和故障排查变得困难。systemd 引入了 journald，提供了统一的日志管理，方便管理员分析问题。 配置复杂：System V init 使用启动脚本来管理服务，这些脚本可能难以编写和维护。systemd 使用更简单的配置文件来管理服务，降低了维护成本。 ","date":"2023-04-17","objectID":"/posts/linux-systemd/:1:0","tags":["Linux"],"title":"Linux Systemd","uri":"/posts/linux-systemd/"},{"categories":["Linux"],"content":"Systemd 概述 systemd 是一种现代化的 init 系统，用于启动、监视和管理 Linux 操作系统中的进程。它在许多主流 Linux 发行版中替代了传统的 System V init 系统，提供了许多改进和新功能。 systemd 的特点： 并行启动：systemd 支持并行启动服务，这意味着它可以同时启动多个服务和进程，从而加快系统启动速度。 依赖管理：systemd 可以自动处理服务和进程之间的依赖关系，确保按照正确的顺序启动它们。这有助于减少启动错误和服务启动失败的可能性。 进程监控与自动重启：systemd 可以监控进程的运行状态，并在它们意外崩溃时自动重启它们。这有助于提高系统的可靠性和稳定性。 资源管理：systemd 与 Linux 的 CGroups 功能紧密集成，允许对进程进行资源限制、隔离和管理。这有助于确保系统资源的公平分配，从而提高系统的稳定性。 集中式日志管理：通过 journald，systemd 提供了一个集中式日志管理系统。journald 可以收集、存储和管理系统日志，方便管理员分析问题和故障排查。 简化的服务配置：systemd 使用名为 Unit 文件的简单配置文件来管理服务。这些文件易于编写和维护，并提供了丰富的选项来定义服务的行为和属性。 命令行工具：systemd 提供了一组强大的命令行工具，如 systemctl 和 journalctl，用于管理和查询系统服务和日志。这些工具使管理员能够轻松地控制系统服务和获取相关信息。 向后兼容性：尽管 systemd 引入了许多新功能和改进，但它仍然保持了对传统 System V init 脚本的支持。这使得在过渡到 systemd 的过程中，现有的服务仍可以继续运行。 简单来说，systemd 是一个工具集，涉及到系统管理的方方面面。 ","date":"2023-04-17","objectID":"/posts/linux-systemd/:2:0","tags":["Linux"],"title":"Linux Systemd","uri":"/posts/linux-systemd/"},{"categories":["Linux"],"content":"Systemd 工具 ","date":"2023-04-17","objectID":"/posts/linux-systemd/:3:0","tags":["Linux"],"title":"Linux Systemd","uri":"/posts/linux-systemd/"},{"categories":["Linux"],"content":"systemctl // 重启系统 $ sudo systemctl reboot // 关闭系统，切断电源 $ sudo systemctl poweroff // CPU 停止工作 $ sudo systemctl halt // 暂停系统 $ sudo systemctl suspend // 系统进入冬眠状态 $ sudo systemctl hibernate // 系统进入交互式休眠状态 $ sudo systemctl hybrid-sleep // 启动进入救援模式（单用户状态） $ sudo systemctl rescue ","date":"2023-04-17","objectID":"/posts/linux-systemd/:3:1","tags":["Linux"],"title":"Linux Systemd","uri":"/posts/linux-systemd/"},{"categories":["Linux"],"content":"systemd-analyze // 查看启动耗时 $ systemd-analyze // 查看每个服务的启动耗时 $ systemd-analyze blame // 显示瀑布状的启动过程流 $ systemd-analyze critical-chain // 显示指定服务的启动流 $ systemd-analyze critical-chain nginx.service ","date":"2023-04-17","objectID":"/posts/linux-systemd/:3:2","tags":["Linux"],"title":"Linux Systemd","uri":"/posts/linux-systemd/"},{"categories":["Linux"],"content":"hostnamectl // 显示当前主机的信息 $ hostnamectl // 设置主机名称 $ sudo hostnamectl set-hostname ecs-ubuntu ","date":"2023-04-17","objectID":"/posts/linux-systemd/:3:3","tags":["Linux"],"title":"Linux Systemd","uri":"/posts/linux-systemd/"},{"categories":["Linux"],"content":"localectl // 查看本地化设置 $ localectl // 设置本地化参数 $ sudo localectl set-locale LANG=en_GB.utf8 $ sudo localectl set-keymap en_GB ","date":"2023-04-17","objectID":"/posts/linux-systemd/:3:4","tags":["Linux"],"title":"Linux Systemd","uri":"/posts/linux-systemd/"},{"categories":["Linux"],"content":"timedatectl // 查看当前时区设置 $ timedatectl // 显示所有可用的时区 $ timedatectl list-timezones // 设置当前时区 $ sudo timedatectl set-timezone Asia/Shanghai $ sudo timedatectl set-time YYYY-MM-DD $ sudo timedatectl set-time HH:MM:SS ","date":"2023-04-17","objectID":"/posts/linux-systemd/:3:5","tags":["Linux"],"title":"Linux Systemd","uri":"/posts/linux-systemd/"},{"categories":["Linux"],"content":"loginctl // 列表当前 Session $ loginctl list-sessions // 列出当前登录用户 $ loginctl list-users // 列出显示指定用户的信息 $ loginctl show-user ubuntu ","date":"2023-04-17","objectID":"/posts/linux-systemd/:3:6","tags":["Linux"],"title":"Linux Systemd","uri":"/posts/linux-systemd/"},{"categories":["Linux"],"content":"journalctl // 查看所有日志（默认情况下，仅保存本次启动的日志） $ sudo journalctl // 查看内核日志 $ sudo journalctl -k // 查看系统本次启动的日志 $ sudo journalctl -b -0 // 查看上一次启动的日志 $ sudo journalctl -b -1 // 查看指定时间的日志 $ sudo journalctl --since=\"2023-04-18 12:13:14\" $ sudo journalctl --since \"30 min ago\" $ sudo journalctl --since yesterday $ sudo journalctl --since \"2017-12-31\" --until \"2019-12-20\" $ sudo journalctl --since 5:30 --until \"3 hour ago\" // 显示结尾的最近 10 行日志 $ sudo journalctl -n // 显示结尾的指定行数的日志 $ sudo journalctl -n 50 // 显示最新实时滚动的日志 $ sudo journalctl -f // 查看指定服务的日志 $ sudo journalctl /usr/sbin/nginx // 查看指定进程的日志 $ sudo journalctl _PID=1 // 查看某个路径的脚本的日志 $ sudo journalctl /usr/bin/bash // 查看指定用户的日志 $ sudo journalctl _UID=104 --since today // 查看某个 Unit 的日志 $ sudo journalctl -u nginx.service $ sudo journalctl -u nginx.service --since today // 显示某个 Unit 的实时滚动最新日志 $ sudo journalctl -u nginx.service -f // 合并显示多个 Unit 的日志 $ sudo journalctl -u sshd.service -u nginx.service --since today // 查看指定优先级的日志（0:emerg 1:alert 2:crit 3:err 4:warning 5:notice 6:info 7:debug） $ sudo journalctl -p err -b // 日志默认分页输出 $ sudo journalctl --no-pager // 日志以 JSON 单行格式输出 $ sudo journalctl -b -u nginx.service -o json // 日志以 JSON 多行格式输出 $ sudo journalctl -b -u nginx.service -o json-pretty // 显示日志占据的磁盘空间 $ sudo journalctl --disk-usage // 显示指定日志文件占据的最大空间 $ sudo journalctl --vacuum-size=1G // 指定日志文件保存多久 $ sudo journalctl --vacuum-time=1years ","date":"2023-04-17","objectID":"/posts/linux-systemd/:3:7","tags":["Linux"],"title":"Linux Systemd","uri":"/posts/linux-systemd/"},{"categories":["Linux"],"content":"Unit systemd.unit — Unit configuration ","date":"2023-04-17","objectID":"/posts/linux-systemd/:4:0","tags":["Linux"],"title":"Linux Systemd","uri":"/posts/linux-systemd/"},{"categories":["Linux"],"content":"Unit 类型 类型 扩展名 说明 Service .service 表示系统服务，用于管理系统服务，如启动、停止、重启等操作。 Socket .socket 表示套接字，描述 IPC（进程间通信）或网络套接字，使服务按需启动。 Device .device 表示硬件设备，描述系统设备，通常由 udev 或 systemd 自动生成。 Mount .mount 表示文件系统挂载点。描述文件系统挂载点，用于挂载、卸载、管理文件系统。 Automount .automount 表示自动挂载点，描述文件系统自动挂载点，用于按需挂载文件系统。 Timer .timer 表示定时器，描述定时任务，基于时间或日历事件触发相关 Unit 启动。 Swap .swap 表示交换分区或交换文件。描述交换分区或交换文件，用于激活、停用交换空间。 Path .path 表示文件系统路径。描述文件系统路径的监控，用于触发服务启动。 Slice .slice 表示一组 Unit 的层次结构，用于对资源进行分组和管理。描述分层资源分配，用于 systemd 进程资源控制。 Scope .scope 表示运行时创建的一组相关进程。描述动态创建的外部进程，用于将一组相关进程归为一组资源管理。 Target .target 表示同步点或系统状态。定义系统状态节点，用于对一组相关的 Unit 进行分组和同步。 ","date":"2023-04-17","objectID":"/posts/linux-systemd/:4:1","tags":["Linux"],"title":"Linux Systemd","uri":"/posts/linux-systemd/"},{"categories":["Linux"],"content":"Unit 状态 // 列出正在运行的 Unit $ systemctl list-units // 列出所有 Unit，包括没有找到配置文件的或者启动失败的 $ systemctl list-units --all // 列出所有没有运行的 Unit $ systemctl list-units --all --state=inactive // 列出所有加载失败的 Unit $ systemctl list-units --failed // 列出所有正在运行的、类型为 service 的 Unit $ systemctl list-units --type=service ","date":"2023-04-17","objectID":"/posts/linux-systemd/:4:2","tags":["Linux"],"title":"Linux Systemd","uri":"/posts/linux-systemd/"},{"categories":["Linux"],"content":"Unit 操作 // 显示系统状态 $ systemctl status // 显示单个 Unit 的状态 $ systemctl status bluetooth.service // 显示远程主机的某个 Unit 的状态 $ systemctl -H root@ip status httpd.service // 显示某个 Unit 是否正在运行 $ systemctl is-active application.service // 显示某个 Unit 是否处于启动失败状态 $ systemctl is-failed application.service // 显示某个 Unit 服务是否建立了启动链接 $ systemctl is-enabled applicaation.service // 启动一个服务 $ sudo systemctl start nginx.service // 停止一个服务 $ sudo systemctl stop nginx.service // 重启一个服务 $ sudo systemctl restart nginx.service // 杀死一个服务的所有子进程 $ sudo systemctl kill nginx.service // 重新加载一个服务的配置文件 $ sudo systemctl reload nginx.service // 重载所有修改过的配置文件 $ sudo systemctl daemon-reload // 显示某个 Unit 所有的底层参数 $ sudo show nginx.service // 显示某个 Unit 指定的属性域值 $ sudo show -p CPUShares nginx.service // 设置某个 Unit 指定的属性 $ sudo systemctl set-property nginx.service CPUShares=500 // 列出某个 Unit 的所有依赖 $ systemctl list-dependencies nginx.service // 列出某个 Unit 的所有依赖（显示所有） $ systemctl list-dependencies --all nginx.service // 开启某个 Unit 开机启动 $ sudo systemctl enable name.service // 禁止某个 Unit 开机启动 $ sudo systemctl disable name.service ","date":"2023-04-17","objectID":"/posts/linux-systemd/:4:3","tags":["Linux"],"title":"Linux Systemd","uri":"/posts/linux-systemd/"},{"categories":["Linux"],"content":"Unit 配置 Systemd Unit 文件由多个配置区块组成，每个区块包含有关该 Systemd Unit 的特定信息。以下是一些常见的 Systemd Unit 配置区块： Block Name Desc [Unit] 包含 Unit 的通用选项，如描述、依赖关系等 [Service] 仅适用于 .service 文件，包含与服务相关的选项，如启动类型、命令等 [Socket] 仅适用于 .socket 文件，包含与套接字相关的选项，如监听地址等 [Device] 仅适用于 .device 文件，包含与设备相关的选项，如设备匹配规则等 [Mount] 仅适用于 .mount 文件，包含与挂载点相关的选项，如文件系统类型等 [Automount] 仅适用于 .automount 文件，包含与自动挂载点相关的选项，如超时等 [Swap] 仅适用于 .swap 文件，包含与交换空间相关的选项，如优先级等 [Target] 仅适用于 .target 文件，包含与系统状态节点相关的选项 [Path] 仅适用于 .path 文件，包含与文件系统路径监控相关的选项，如路径等 [Timer] 仅适用于 .timer 文件，包含与定时任务相关的选项，如触发时间等 [Slice] 仅适用于 .slice 文件，包含与分层资源分配相关的选项，如内存限制等 [Scope] 仅适用于 .scope 文件，包含与动态创建的外部进程相关的选项 [Install] 包含有关 Unit 安装和启用的选项，如所需的目标等 Systemd Unit 文件中 [Unit] 配置区块的一些常见配置键名及其含义： Key Name Desc Description 对 Unit 的简短描述 Documentation 提供 Unit 文档的 URL 链接 Requires 定义必须在此 Unit 之前启动的其他 Unit，如果它们失败，此 Unit 也将失败 Wants 类似于 Requires，但失败的依赖不会导致本 Unit 失败 BindsTo 当依赖的 Unit 启动/停止时，同步启动/停止本 Unit PartOf 当依赖的 Unit 启动/停止/重新加载时，同步启动/停止/重新加载本 Unit Conflicts 指定与此 Unit 冲突的其他 Unit，当冲突的 Unit 启动时，本 Unit 将停止 Before 确保本 Unit 在指定的其他 Unit 之前启动 After 确保本 Unit 在指定的其他 Unit 之后启动 OnFailure 当本 Unit 失败时启动的其他 Unit OnSuccess 当本 Unit 成功时启动的其他 Unit ConditionPathExists 如果指定的文件路径存在，则启动此 Unit ConditionPathIsDirectory 如果指定的文件路径是目录，则启动此 Unit ConditionKernelCommandLine 如果内核命令行参数包含指定的选项，则启动此 Unit ConditionArchitecture 如果系统架构匹配指定的架构，则启动此 Unit AssertPathExists 如果指定的文件路径存在，则启动此 Unit，否则将失败 AssertPathIsDirectory 如果指定的文件路径是目录，则启动此 Unit，否则将失败 AssertKernelCommandLine 如果内核命令行参数包含指定的选项，则启动此 Unit，否则将失败 AssertArchitecture 如果系统架构匹配指定的架构，则启动此 Unit，否则将失败 Systemd Unit 文件中 [Service] 配置区块的一些常见配置键名及其含义： Key Name Desc Type 定义服务的启动类型，如 simple、forking、oneshot、dbus、notify 等 ExecStart 定义启动服务时执行的命令 ExecStartPre 在 ExecStart 命令执行之前运行的命令 ExecStartPost 在 ExecStart 命令执行之后运行的命令 ExecReload 定义重新加载服务配置时执行的命令 ExecStop 定义停止服务时执行的命令 ExecStopPost 在 ExecStop 命令执行之后运行的命令 Restart 定义何时自动重启服务，如 always、on-success、on-failure、on-abnormal 等 RestartSec 自动重启服务之间的时间间隔 TimeoutStartSec 服务启动超时时间 TimeoutStopSec 服务停止超时时间 RuntimeMaxSec 服务的最长运行时间，超过该时间将被终止 WatchdogSec 服务的看门狗超时时间，超过该时间未收到任何信号将被视为不正常 User 以指定用户身份运行服务 Group 以指定组身份运行服务 Environment 定义服务运行时的环境变量 EnvironmentFile 从指定文件中导入环境变量 WorkingDirectory 定义服务运行时的工作目录 LimitNOFILE 定义服务允许打开的最大文件描述符数量 LimitNPROC 定义服务允许创建的最大进程数量 Nice 定义服务的优先级 OOMScoreAdjust 调整服务在内存不足时被杀死的优先级 KillMode 定义服务终止时的进程杀死模式，如 control-group、process、mixed、none 等 StandardInput 定义服务的标准输入来源，如 null、tty、socket 等 StandardOutput 定义服务的标准输出目的地，如 null、journal、tty、socket 等 StandardError 定义服务的标准错误输出目的地，如 null、journal、tty、socket 等 // 查看某个服务的配置文件 $ systemctl cat nginx.service // 列出所有配置文件 $ systemctl list-unit-files // 列出指定类型的配置文件 $ systemctl list-unit-files --type=service // 一旦修改配置文件，需要重新加载配置并重启启动 $ sudo systemctl daemon-reload $ sudo systemctl restart nginx.service 为 systemd 创建和配置 unit 文件，需要遵循以下步骤： 创建 unit 文件：在 /etc/systemd/system 目录下创建一个新的 unit 文件。文件名应该包含服务名称和适当的扩展名，例如 my-custom-service.service： $ sudo touch /etc/systemd/system/my-custom-service.service 编辑 unit 文件：使用文本编辑器（如 nano、vim 或 gedit）打开新创建的 unit 文件，并添加相应的配置： $ sudo vim /etc/systemd/system/my-custom-service.service 编写 unit 文件内容：根据服务的需求，在 unit 文件中添加相应的配置。以下是一个简单的 service unit 示例： [Unit] Description=My Custom Service After=network.target [Service] ExecStart=/usr/bin/my-custom-service --option1 Restart=always User=myuser Group=mygroup [Install] WantedBy=multi-user.target 保存并关闭 unit 文件：在编辑器中保存更改并关闭 unit 文件。 重新加载 systemd 配置：运行以下命令，让 systemd 重新加载配置： $ sudo systemctl daemon-reload 启动新创建的 unit：使用以下命令启动新创建的 unit： $ sudo systemctl start my-custom-service 设置 unit 开机启动（可选）：如有必要，可以使用以下命令使 unit 随系统启动： $ sudo systemctl enable my-custom-service 检查 unit 状态：要检查 unit 的状态，可以使用以下命令： $ sudo systemctl status my-custom-service Service unit (.service) Service unit 文件用于描述系统服务的启动、停止、重启等行为。一个简单的 service unit 示例： [Unit] Description=My Custom Service After=network.target [Service] ExecStart=/usr/bin/my-custom-service --option1 Restart=always User=myuser Group=mygroup [Install] WantedBy=multi-user.target Socket unit (.socket) Socket unit 文件用于描述进程间通信的 socket。一个简单的 socket unit 示例： [Unit] Descr","date":"2023-04-17","objectID":"/posts/linux-systemd/:4:4","tags":["Linux"],"title":"Linux Systemd","uri":"/posts/linux-systemd/"},{"categories":["Linux"],"content":"Target Working with systemd targets 在 Systemd 中，Target（目标）的作用是将一组相关的 Unit（单元）组织到一起，为它们提供一个统一的同步点。Target 本身并不执行任何操作，但它们定义了系统中不同服务和组件之间的关系，提供了一个有序的启动和停止方式。这有点类似于 System V init 系统中的运行级别（runlevels），但比运行级别更灵活。 Target可以帮助管理系统的不同状态和功能，例如： 将系统从单用户模式切换到多用户模式。 在系统启动过程中，确保基本系统服务（如日志记录、网络配置等）已启动，然后再启动其他服务。 根据需要启动和停止一组相关服务，而不是逐个启动和停止它们。 通过使用 Target，系统管理员可以轻松地按需启动、停止和管理服务，以及在不同的系统状态之间进行切换。一些常见的 Target 示例包括无图形界面多用户模式（multi-user.target）、图形模式（graphical.target）和引导系统重启的目标（reboot.target）等。 // 查看当前系统的所有 Target $ systemctl list-unit-files --type=target // 查看一个 Target 包含的所有 Unit $ systemctl list-dependencies multi-user.target // 查看启动时的默认 Target $ systemctl get-default // 设置启动时的默认 Target $ sudo systemctl set-default multi-user.target // 关闭前一个 Target 里面所有不属于后一个 Target 的进程 $ sudo systemctl isolate multi-user.target Target 与 System V init 系统中的 RunLevel 有一定的对应关系，但请注意，Target 提供了更灵活的方式来管理系统状态。以下是一些常见的 Target 与 RunLevel 之间的对应关系： RunLevel Target Desc 0 runlevel0.target 关闭系统 1 runlevel1.target 单用户模式，用于系统维护 2 runlevel2.target 多用户模式，不包含网络服务 3 runlevel3.target 多用户模式，包含网络服务 4 runlevel4.target 未定义，可由系统管理员自定义用途 5 runlevel5.target 多用户模式，包含网络服务和图形用户界面（GUI） 6 runlevel6.target 重新启动系统 - emergency.target 紧急模式，提供最小系统功能以进行故障排除 - rescue.target 救援模式，类似于单用户模式，用于系统维护和故障排除 - multi-user .target 多用户模式，不包含图形用户界面 - graphical.target 多用户模式，包含图形用户界面 - halt.target 关闭系统，但不断电 ","date":"2023-04-17","objectID":"/posts/linux-systemd/:5:0","tags":["Linux"],"title":"Linux Systemd","uri":"/posts/linux-systemd/"},{"categories":["Linux"],"content":"安装软件编译问题 在启动 MongoDB 时报 /lib64/libc.so.6: version GLIBC_2.14 not found: // 升级 glibc 版本到 2.17 # wget http://ftp.gnu.org/gnu/glibc/glibc-2.17.tar.gz # tar xf glibc-2.14.tar.gz # cd glibc-2.14 # mkdir build # ../configure --prefix=/usr --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin # make -j 8 # make install // 查看版本 # ldd --version # strings /lib64/libc.so.6 | grep GLIBC_ ","date":"2023-02-01","objectID":"/posts/linux-issues/:1:0","tags":["Linux"],"title":"Linux 问题收集","uri":"/posts/linux-issues/"},{"categories":["Linux"],"content":"Ubuntu 23.04 安装不了 PHP 8.2 ","date":"2023-02-01","objectID":"/posts/linux-issues/:2:0","tags":["Linux"],"title":"Linux 问题收集","uri":"/posts/linux-issues/"},{"categories":["Linux"],"content":"PHP 8.2 on Ubuntu 22.04 在 Ubuntu 22.04 上安装没什么问题，纯粹记录一下。 sudo apt update \u0026\u0026 sudo apt -y upgrade sudo apt autoremove [ -f /var/run/reboot-required ] \u0026\u0026 sudo reboot -f sudo apt install -y lsb-release gnupg2 ca-certificates apt-transport-https software-properties-common sudo add-apt-repository ppa:ondrej/php sudo apt update sudo apt install php8.2 -y php --version sudo apt install php8.2-{common,bcmath,fpm,xml,mysql,zip,intl,ldap,gd,cli,bz2,curl,mbstring,pgsql,opcache,soap,cgi} -y php -m ","date":"2023-02-01","objectID":"/posts/linux-issues/:2:1","tags":["Linux"],"title":"Linux 问题收集","uri":"/posts/linux-issues/"},{"categories":["Linux"],"content":"PHP 8.2 on Ubuntu 23.04 但是在 Ubuntu 23.04 上安装 PHP 8.2 就出些问题，原因是 ppa:ondrej/php 还未对 Ubuntu 23.04 做对应的源，所以属于 临时修改，以解决安装问题。 sudo apt update \u0026\u0026 sudo apt -y upgrade sudo apt autoremove [ -f /var/run/reboot-required ] \u0026\u0026 sudo reboot -f sudo apt install -y lsb-release gnupg2 ca-certificates apt-transport-https software-properties-common sudo add-apt-repository ppa:ondrej/php # change lunar to jammy vim /etc/apt/sources.list.d/ondrej-ubuntu-php-lunar.list deb https://ppa.launchpadcontent.net/ondrej/php/ubuntu/ jammy main # 如果你需要 intl 扩展，可以从 jammy 仓库下载并手动安装 libicu70_70.1-2_amd64.deb。它没有任何依赖项。 touch /etc/apt/preferences.d/ondrejphp vim /etc/apt/preferences.d/ondrejphp Package: libgd3 Pin: release n=lunar Pin-Priority: 900 sudo apt update sudo apt install php8.2 -y php --version sudo apt install php8.2-{common,bcmath,fpm,xml,mysql,zip,intl,ldap,gd,cli,bz2,curl,mbstring,pgsql,opcache,soap,cgi} -y php -m ","date":"2023-02-01","objectID":"/posts/linux-issues/:2:2","tags":["Linux"],"title":"Linux 问题收集","uri":"/posts/linux-issues/"},{"categories":["Linux"],"content":"在维护多台机器时，传统的用户名密码登录存在一些弊端，所以就分出一台当跳板机，从跳板机上登录其它机器。 ","date":"2022-11-30","objectID":"/posts/linux-ssh-password-free-login/:0:0","tags":["Linux"],"title":"Linux SSH 免密码登录","uri":"/posts/linux-ssh-password-free-login/"},{"categories":["Linux"],"content":"SSH 服务 ","date":"2022-11-30","objectID":"/posts/linux-ssh-password-free-login/:1:0","tags":["Linux"],"title":"Linux SSH 免密码登录","uri":"/posts/linux-ssh-password-free-login/"},{"categories":["Linux"],"content":"安装 SSH 服务 // CentOS $ yum install openssh-server // Ubuntu $ apt install openssh-server // sshd.service 启动|重启|停止|状态 $ systemctl start|restart|stop|status sshd.service ","date":"2022-11-30","objectID":"/posts/linux-ssh-password-free-login/:1:1","tags":["Linux"],"title":"Linux SSH 免密码登录","uri":"/posts/linux-ssh-password-free-login/"},{"categories":["Linux"],"content":"配置 SSH 服务 $ vim /etc/ssh/sshd_config RSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized_keys UsePAM yes ClientAliveInterval 300 ClientAliveCountMax 3 UseDNS no AddressFamily inet SyslogFacility AUTHPRIV PermitRootLogin without-password Protocol 2 PasswordAuthentication no $ systemctl restart sshd.service ","date":"2022-11-30","objectID":"/posts/linux-ssh-password-free-login/:1:2","tags":["Linux"],"title":"Linux SSH 免密码登录","uri":"/posts/linux-ssh-password-free-login/"},{"categories":["Linux"],"content":"生成密钥对 本地机器，跳板机，跳板机登录的其它机器都需要生成密钥对。 $ ssh-keygen -t rsa -C \"email|instance-id|hostname|xxx 均可\" $ chmod 0700 .ssh $ chmod 0600 .ssh/authorized_keys // 复制跳板机的公钥粘贴到跳板登录的其它机器的 authorized_keys 文件中 $ cat ~/.ssh/id_rsa.pub 或 $ ssh-copy-id -i .ssh/id_rsa.pub username@ip ","date":"2022-11-30","objectID":"/posts/linux-ssh-password-free-login/:2:0","tags":["Linux"],"title":"Linux SSH 免密码登录","uri":"/posts/linux-ssh-password-free-login/"},{"categories":["Linux"],"content":"登录测试 $ ssh root@ip ","date":"2022-11-30","objectID":"/posts/linux-ssh-password-free-login/:2:1","tags":["Linux"],"title":"Linux SSH 免密码登录","uri":"/posts/linux-ssh-password-free-login/"},{"categories":["Linux"],"content":"快捷配置 $ vim ~/.ssh/config Host a-instance User root HostName 10.10.10.11 PubkeyAuthentication yes IdentityFile ~/.ssh/id_rsa Host b-instance User root HostName 10.10.10.12 PubkeyAuthentication yes IdentityFile ~/.ssh/id_rsa $ ssh a-instance ","date":"2022-11-30","objectID":"/posts/linux-ssh-password-free-login/:2:2","tags":["Linux"],"title":"Linux SSH 免密码登录","uri":"/posts/linux-ssh-password-free-login/"},{"categories":["Android"],"content":"收集一些遇到的安卓问题解决方案。 ","date":"2022-11-08","objectID":"/posts/android-issues/:0:0","tags":["Android"],"title":"Android 问题收集","uri":"/posts/android-issues/"},{"categories":["Android"],"content":"安卓常见问题 Android SDK - reposit: $ touch ~/.android/repositories.cfg $ ./Android/Sdk/tools/bin/sdkmanager --update $ ./Android/Sdk/tools/bin/sdkmanager --licenses Expiring Daemon because JVM heap space is exhausted: // gradle.properties org.gradle.daemon=true org.gradle.configureondemand=true org.gradle.jvmargs=-Xmx4g -XX:MaxPermSize=2048m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8 Expiring Daemon because JVM heap space is exhausted Could not find com.jakewharton:butterknife-compiler:7.0.1: // app/build.gradle implementation 'com.jakewharton:butterknife:7.0.1' annotationProcessor 'com.jakewharton:butterknife:7.0.1' 8.0 以上版本参考： java.lang.NullPointerException #801 Could not find ButterKnife compiler Butter Knife Butterknife 黄油刀找不到控件 java.security.cert.CertPathValidatorException: Trust anchor for certification path not found: // 将证书下载到 app/src/main/raw 目录下，然后在 app/src/main/res/xml 目录下添加 network_secruity_config.xml 文件 $ touch app/src/main/res/xml/network_secruity_config.xml $ vim app/src/main/res/xml/network_secruity_config.xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cnetwork-security-config xmlns:tools=\"http://schemas.android.com/tools\"\u003e \u003cdebug-overrides\u003e \u003ctrust-anchors\u003e \u003ccertificates overridePins=\"true\" src=\"system\" /\u003e \u003ccertificates overridePins=\"true\" src=\"user\" /\u003e \u003ccertificates src=\"@raw/certificate\" /\u003e \u003c/trust-anchors\u003e \u003c/debug-overrides\u003e \u003cdomain-config\u003e \u003cdomain includeSubdomains=\"true\"\u003eexample.com\u003c/domain\u003e \u003ctrust-anchors\u003e \u003ccertificates src=\"@raw/certificate\" /\u003e \u003c/trust-anchors\u003e \u003c/domain-config\u003e \u003cbase-config cleartextTrafficPermitted=\"true\"\u003e \u003ctrust-anchors\u003e \u003ccertificates src=\"@raw/certificate\" /\u003e \u003ccertificates src=\"system\" /\u003e \u003c/trust-anchors\u003e \u003c/base-config\u003e \u003c/network-security-config\u003e // 在 app/src/main/AndroidManifest.xml 文件中添加以下配置 $ vim app/src/main/AndroidManifest.xml \u003capplication ... android:networkSecurityConfig=\"@xml/network_secruity_config\" ...\u003e ... \u003c/application\u003e 网络安全配置 ","date":"2022-11-08","objectID":"/posts/android-issues/:1:0","tags":["Android"],"title":"Android 问题收集","uri":"/posts/android-issues/"},{"categories":["Linux","Go"],"content":"要在 Linux 上运行 Go 代码，需要安装 Go 编译器和设置 Go 环境变量。 ","date":"2022-11-08","objectID":"/posts/linux-go-env/:0:0","tags":["Linux"],"title":"Linux Go 运行环境搭建","uri":"/posts/linux-go-env/"},{"categories":["Linux","Go"],"content":"Linux 服务器配置 鉴于目前大部分服务器使用 CentOS 系统，本文将介绍在 CentOS 上搭建 Go 环境。 用 root 用户登录 Linux 系统，并创建普通用户： // 添加用户 $ useradd -m -s /bin/bash golang // 修改密码 $ passwd golang 将普通用户加入到 sudoers 中，以便普通用户就可以通过 sudo 命令来暂时获取 root 的权限： $ # sed -i '/^root.*ALL=(ALL).*ALL/a\\golang\\tALL=(ALL) \\tALL' /etc/sudoers 或 $ echo \"golang ALL=(ALL) NOPASSWD:ALL\" | sudo tee /etc/sudoers.d/golang 或 $ vi sudo $ golang ALL=(ALL) NOPASSWD:ALL // 退出后以 golang 用户登录 $ exit 配置 .bashrc 文件： $ mkdir -pv $HOME/workspace $ vim ~/.bashrc # User specific aliases and functions alias rm='rm -i' alias cp='cp -i' alias mv='mv -i' # Source global definitions if [ -f /etc/bashrc ]; then . /etc/bashrc fi # User specific environment export LANG=\"en_US.UTF-8\" export PS1='[\\u@dev \\W]\\$ ' export WORKSPACE=\"$HOME/workspace\" export PATH=$HOME/bin:$PATH # Default entry folder cd $WORKSPACE ","date":"2022-11-08","objectID":"/posts/linux-go-env/:1:0","tags":["Linux"],"title":"Linux Go 运行环境搭建","uri":"/posts/linux-go-env/"},{"categories":["Linux","Go"],"content":"依赖安装和配置 // 安装依赖 $ sudo yum -y install make autoconf automake cmake perl-CPAN libcurl-devel libtool gcc gcc-c++ glibc-headers zlib-devel git-lfs telnet lrzsz jq expat-devel openssl-devel // 安装 git $ cd /tmp $ wget --no-check-certificate https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.38.1.tar.gz $ tar -xvzf git-2.38.1.tar.gz $ cd git-2.38.1/ $ ./configure $ make $ sudo make install $ git --version git version 2.36.1 $ tee -a $HOME/.bashrc \u003c\u003c'EOF' # Configure for git export PATH=/usr/local/libexec/git-core:$PATH EOF // 配置 git $ git config --global user.name \"username\" $ git config --global user.email \"username@email.com\" $ git config --global credential.helper store $ git config --global core.longpaths true $ git config --global core.quotepath off $ git lfs install --skip-repo ","date":"2022-11-08","objectID":"/posts/linux-go-env/:2:0","tags":["Linux"],"title":"Linux Go 运行环境搭建","uri":"/posts/linux-go-env/"},{"categories":["Linux","Go"],"content":"Go 编译环境安装和配置 // 下载 Go 安装包 $ wget -P /tmp/ https://golang.google.cn/dl/go1.19.3.linux-amd64.tar.gz // 解压安装 $ mkdir -pv $HOME/go $ tar -xvzf /tmp/go1.19.3.linux-amd64.tar.gz -C $HOME/go $ mv $HOME/go/go $HOME/go/go1.19.3 // 将以下环境变量追加到 $HOME/.bashrc 文件中 $ tee -a $HOME/.bashrc \u003c\u003c'EOF' # Go envs export GOVERSION=go1.19.3 # Go 版本设置 export GO_INSTALL_DIR=$HOME/go # Go 安装目录 export GOROOT=$GO_INSTALL_DIR/$GOVERSION # GOROOT 设置 export GOPATH=$WORKSPACE/golang # GOPATH 设置 export PATH=$GOROOT/bin:$GOPATH/bin:$PATH # 将 Go 语言自带的和通过 go install 安装的二进制文件加入到 PATH 路径中 export GO111MODULE=\"on\" # 开启 Go moudles 特性 export GOPROXY=https://goproxy.cn,direct # 安装 Go 模块时，代理服务器设置 export GOPRIVATE= export GOSUMDB=off # 关闭校验 Go 依赖包的哈希值 EOF // 测试 go 命令 $ go version go version go1.19.3 linux/amd64 // 初始化工作区 $ mkdir -p $GOPATH \u0026\u0026 cd $GOPATH $ go work init $ go env GOWORK # 执行此命令，查看 go.work 工作区文件路径 /home/going/workspace/golang/go.work // ProtoBuf 编译环境安装 $ cd /tmp/ $ git clone -b v3.21.9 --depth=1 https://github.com/protocolbuffers/protobuf $ cd protobuf $ ./autogen.sh $ ./configure $ make $ sudo make install $ protoc --version libprotoc 3.21.9 $ go install github.com/golang/protobuf/protoc-gen-go@v1.5.2 开发工具配置： $ rm -f $HOME/.vim; mkdir -p ~/.vim/pack/plugins/start/ $ git clone --depth=1 https://github.com/fatih/vim-go.git ~/.vim/pack/plugins/start/vim-go $ vim :GoInstallBinaries ","date":"2022-11-08","objectID":"/posts/linux-go-env/:3:0","tags":["Linux"],"title":"Linux Go 运行环境搭建","uri":"/posts/linux-go-env/"},{"categories":["Go","GPM"],"content":"基本概念 普通栈：需要调度的 Goroutine 组成的函数栈，是可增长的栈，因为 Goroutine 可以越开越多； 线程栈：需要将 Goroutine 放置到线程上的 M 们组成，实质上 M 也是由 Goroutine 生成的，线程栈大小固定（设置了 M 的数量）。所有调度相关的代码，会先切换到该 Goroutine 的栈中再执行。也就是说线程的栈也是用的 G 实现，而不是使用的 OS 的； 全局队列：该队列存储的 G 将被所有的 M 全局共享，为保证数据竞争问题，需加锁处理； 本地队列：该队列存储数据资源相同的任务，每个本地队列都会绑定一个 M ，指定其完成任务，没有数据竞争，无需加锁处理，处理速度远高于全局队列； 上下文切换： 对于代码中某个值来说，上下文是指这个值所在的局部（全局）作用域对象； 对于进程而言，上下文就是进程执行时的环境，具体来说就是各个变量和数据，包括所有的寄存器变量、进程打开的文件、内存（堆栈）信息等； 线程清理：由于每个 P 都需要绑定一个 M 进行任务执行，所以当清理线程的时候，只需要将 P 释放，即解除绑定（M 就没有任务）即可。P 被释放主要由两种情况： 主动释放：最典型的例子是，当执行 G 任务时有系统调用，当发生系统调用时 M 会处于阻塞状态。调度器会设置一个超时时间，当超时时会将 P 释放； 被动释放：如果发生系统调用，有一个专门监控程序，进行扫描当前处于阻塞的 PM 组合。当超过系统程序设置的超时时间，会自动将 P 资源抢走。去执行队列的其它 G 任务； ","date":"2022-10-15","objectID":"/posts/go-gpm-model/:1:0","tags":["Go"],"title":"Go GPM 模型","uri":"/posts/go-gpm-model/"},{"categories":["Go","GPM"],"content":"调度器演进 Go 程序是用户层程序，它本身就是整体运行在一个或多个操作系统线程上的。所以 Goroutine 们要竞争的「CPU」资源就是操作系统线程。因此，调度器的任务就是将 Goroutine 按照一定算法放到不同的操作系统线程中去执行。 单线程调度器 - 0.x 包含少量的代码； 程序中只能存在一个活跃线程，由 G-M 模型组成； 多线程调度器 - 1.0 允许运行多线程的程序； 全局锁导致竞争严重； 任务窃取调度器 - 1.1 引入了处理器 P，构成了目前的 G-M-P 模型； 在处理器 P 的基础上实现了基于工作窃取的调度器； 在某些情况下，Goroutine 不会让出线程，进而造成饥饿问题； 时间过长的垃圾回收（STW 问题）会导致程序长时间无法工作； 抢占式调度器 - 1.2~至今 基于协作的抢占式调度器 - 1.2~1.3 通过编译器在函数调用时插入抢占检查指令，在函数调用时检查当前 Goroutine 是否发起了抢占请求，实现基于协作的抢占式调度； Goroutine 可能会因为垃圾回收和循环长时间占用资源导致程序暂停； 基于信号的抢占式调度器 - 1.14~至今 实现基于信号的真抢占式调度； 垃圾回收在扫描栈时会触发抢占调度； 抢占的时间点不够多，还不能覆盖全部的边缘情况； 非均匀存储访问（NUMA - Non-Uniform Memory Access）调度器（仅有提案） 对运行时的各种资源进行分区； 实现非常复杂，未提上日程； 德米特里·维尤科夫 - Dmitry Vyukov 在其 Scalable Go Scheduler Design Doc 一文中指出了 G-M 模型的一个重要不足：限制了 Go 并发程序的伸缩性，尤其是对那些有高吞吐或并行计算需求的服务程序。 为了解决这些问题，德米特里·维尤科夫又亲自操刀改进了 Go 调度器，在 Go 1.1 版本中实现了 GPM 调度模型和 Work Stealing 算法，这个模型一直沿用至今。模型如下图所示： +---------------------sysmon-------------------+ | | | | +---+ +---|-------+ +--------+ +---|---+ go func() ----\u003e| G |--\u003e| P | Local | \u003c== balance ==\u003e | global | \u003c----\u003e| P | M | +---+ +-----------+ +--------+ +---|---+ | | | | +---+ | | +---\u003e| M | \u003c--- find runnable -----------+----- steal \u003c--+ +---+ | | +----execute \u003c----schedule--+ | | | | +---\u003e G.fn ---\u003e goexit -----+ 1. go creates a new goroutine 2. newly created goroutine being put into local or global queue 3. a M is being waken or created to execute goroutine 4. schedule loop 5. try its best to get a goroutine to execute 6. clear, reenter schedule loop GPM 模型的实现算是 Go 调度器的一大进步，但调度器仍然有一个令人头疼的问题，那就是不支持抢占式调度，这导致一旦某个 G 中出现死循环的代码逻辑，那么 G 将永久占用分配给它的 P 和 M，而位于同一个 P 中的其他 G 将得不到调度，出现「饿死」的情况。 更为严重的是，当只有一个 P（GOMAXPROCS=1）时，整个 Go 程序中的其他 G 都将「饿死」。于是德米特里·维尤科夫又提出了 Go Preemptive Scheduler Design 并在 Go 1.2 中实现了 基于协作的抢占式 调度。 抢占式调度的原理：Go 编译器在每个函数或方法的入口处加上了一段额外的代码 (runtime.morestack_noctxt)，让运行时有机会在这段代码中检查是否需要执行抢占调度。 这种解决方案只能说局部解决了「饿死」问题，只在有函数调用的地方才能插入「抢占」代码（埋点），对于没有函数调用而是纯算法循环计算的 G，Go 调度器依然无法抢占。比如，死循环等并没有给编译器插入抢占代码的机会，这就会导致 GC 在等待所有 Goroutine 停止时的等待时间过长，从而 导致 GC 延迟，内存占用瞬间冲高；甚至在一些特殊情况下，导致在 STW 时死锁。 为了解决这些问题，Go 在 1.14 版本中接受了 奥斯汀·克莱门茨（Austin Clements） 的提案，增加了对非协作的抢占式调度的支持，这种抢占式调度是基于系统信号的，也就是通过向线程发送信号的方式来抢占正在运行的 Goroutine。除了这些大的迭代外，Goroutine 的调度器还有一些小的优化改动，比如通过文件 I/O Poller 减少 M 的阻塞等。 Go 运行时已经实现了 Netpoller，这使得即便 G 发起网络 I/O 操作，也不会导致 M 被阻塞（仅阻塞 G），也就不会导致大量线程（M）被创建出来。但是对于文件 I/O 操作来说，一旦阻塞，那么线程（M）将进入挂起状态，等待 I/O 返回后被唤醒。这种情况下 P 将与挂起的 M 分离，再选择一个处于空闲状态（idle）的 M。如果此时没有空闲的 M，就会新创建一个 M（线程），所以，这种情况下，大量 I/O 操作仍然会导致大量线程被创建。 为了解决这个问题，Go 开发团队的 伊恩·兰斯·泰勒（Ian Lance Taylor） 在 Go 1.9 中增加了一个针对文件 I/O 的 Poller 的功能，这个功能可以像 Netpoller 那样，在 G 操作那些支持监听（pollable）的文件描述符时，仅会阻塞 G，而不会阻塞 M。不过这个功能依然不能对常规文件有效，常规文件是不支持监听的（pollable）。但对于 Go 调度器而言，这也算是一个不小的进步了。 从 Go 1.2 以后，Go 调度器就一直稳定在 GPM 调度模型上，尽管有各种优化和改进，但也都是基于这个模型之上的。德米特里·维尤科夫在 2014 年 9 月提出了一个新的设计草案文档：NUMA‐aware scheduler for Go，作为对未来 Goroutine 调度器演进方向的一个提议，不过至今似乎这个提议也没有列入开发计划。 ","date":"2022-10-15","objectID":"/posts/go-gpm-model/:2:0","tags":["Go"],"title":"Go GPM 模型","uri":"/posts/go-gpm-model/"},{"categories":["Go","GPM"],"content":"GPM 调度模型 GPM 代表了三个角色，分别是 Goroutine、Processor、Machine。 Goroutine：携带任务，使用 go 关键字创建的执行体，它对应一个结构体 g，结构体里保存了 Goroutine 的堆栈信息，即并发任务状态。G 并非执行体，每个 G 需要绑定到 P 才能被调度执行，而且 G 对象是可以重用的。 Processor：分配任务，表示处理器，可以被看做运行在线程上的本地调度器，对 G 来说，P 相当于 CPU 核，G 只有绑定到 P（在 P 的 local runq 中）才能被调度。对 M 来说，P 提供了相关的执行环境（Context），如内存分配状态，任务队列等，有了它才能建立 G、M 的联系。 Machine：寻找任务，表示操作系统的线程，OS 线程抽象，负责调度任务，和某个有效的 P 绑定，从 P 的 runq 中不断取出 G，切换到 G 的执行栈上并执行 G 的函数，调用 goexit 做清理工作并回到 M，如此反复。M 本身不具备执行状态，在需要任务切换时，M 将堆栈状态写回 G，任何其它 M 都能据此恢复执行。M 并不保留 G 状态，这是 G 可以跨 M 调度的基础。 注意： P 的个数由 GOMAXPROCS 指定，是固定的，因此限制最大并发数。 M 的个数是不定的，由 Go Runtime 调整，默认最大限制为 10000 个。 Go 使用协程的几个主要原因： 内核线程创建与切换太重：创建和切换都要进入到内核态，进入到内核态开销较大，性能代价大，而协程切换不需要进入到内核态。 线程内存使用太重：创建一个内核线程默认栈大小为 8M，而创建一个用户线程即 Goroutine 只需要 2K 内存，当 Goroutine 栈不够用时也会自动增加。 Goroutine 的调度更灵活，所有协程的调度、切换都发生在用户态，没有创建线程的开销，即使出现某个协程运行阻塞时，线程上的其他协程也会被调度到其他线程上运行。 基本调度过程： 创建一个 G 对象。 将 G 保存至 P 中。 P 去唤醒一个 M，然后继续执行它的执行序（分配下一个 G）。 M 寻找空闲的 P，读取该 P 要分配的 G。 接下来 M 执行一个调度循环，调用 G → 执行 → 清理线程 → 继续找新的 G 执行。 ","date":"2022-10-15","objectID":"/posts/go-gpm-model/:3:0","tags":["Go"],"title":"Go GPM 模型","uri":"/posts/go-gpm-model/"},{"categories":["Go","GPM"],"content":"G - Goroutine Goroutine 是 Go 语言调度器中待执行的任务，它在运行时调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销。 Goroutine 只存在于 Go 语言的运行时，它是 Go 语言在用户态提供的线程，作为一种粒度更细的资源调度单元，如果使用得当能够在高并发的场景下更高效地利用机器的 CPU。 G 的调度方式： 抢占式调度：如果某个 G 没有进行系统调用（syscall）、没有进行 IO 操作、没有阻塞在一个 channel 操作上，那么，调度器通过抢占式调度让当前 G 停下来并调度下一个可运行的 G。除非极端的无限循环，否则只要 G 调用函数，Go 运行时就有了抢占 G 的机会。Go 程序启动时，运行时会去启动一个名为 sysmon 的 M（一般称为监控线程），这个 M 的特殊之处在于它不需要绑定 P 就可以运行（以 g0 这个 G 的形式存在）。 // $GOROOT/src/runtime/proc.go // Always runs without a P, so write barriers are not allowed. // //go:nowritebarrierrec func sysmon() { lock(\u0026sched.lock) sched.nmsys++ checkdead() unlock(\u0026sched.lock) lasttrace := int64(0) idle := 0 // how many cycles in succession we had not wokeup somebody delay := uint32(0) for { if idle == 0 { // start with 20us sleep... delay = 20 } else if idle \u003e 50 { // start doubling the sleep after 1ms... delay *= 2 } if delay \u003e 10*1000 { // up to 10ms delay = 10 * 1000 } usleep(delay) // sysmon should not enter deep sleep if schedtrace is enabled so that // it can print that information at the right time. // // It should also not enter deep sleep if there are any active P's so // that it can retake P's from syscalls, preempt long running G's, and // poll the network if all P's are busy for long stretches. // // It should wakeup from deep sleep if any P's become active either due // to exiting a syscall or waking up due to a timer expiring so that it // can resume performing those duties. If it wakes from a syscall it // resets idle and delay as a bet that since it had retaken a P from a // syscall before, it may need to do it again shortly after the // application starts work again. It does not reset idle when waking // from a timer to avoid adding system load to applications that spend // most of their time sleeping. now := nanotime() if debug.schedtrace \u003c= 0 \u0026\u0026 (sched.gcwaiting != 0 || atomic.Load(\u0026sched.npidle) == uint32(gomaxprocs)) { lock(\u0026sched.lock) if atomic.Load(\u0026sched.gcwaiting) != 0 || atomic.Load(\u0026sched.npidle) == uint32(gomaxprocs) { syscallWake := false next := timeSleepUntil() if next \u003e now { atomic.Store(\u0026sched.sysmonwait, 1) unlock(\u0026sched.lock) // Make wake-up period small enough // for the sampling to be correct. sleep := forcegcperiod / 2 if next-now \u003c sleep { sleep = next - now } shouldRelax := sleep \u003e= osRelaxMinNS if shouldRelax { osRelax(true) } syscallWake = notetsleep(\u0026sched.sysmonnote, sleep) if shouldRelax { osRelax(false) } lock(\u0026sched.lock) atomic.Store(\u0026sched.sysmonwait, 0) noteclear(\u0026sched.sysmonnote) } if syscallWake { idle = 0 delay = 20 } } unlock(\u0026sched.lock) } lock(\u0026sched.sysmonlock) // Update now in case we blocked on sysmonnote or spent a long time // blocked on schedlock or sysmonlock above. now = nanotime() // trigger libc interceptors if needed if *cgo_yield != nil { asmcgocall(*cgo_yield, nil) } // poll network if not polled for more than 10ms lastpoll := int64(atomic.Load64(\u0026sched.lastpoll)) if netpollinited() \u0026\u0026 lastpoll != 0 \u0026\u0026 lastpoll+10*1000*1000 \u003c now { atomic.Cas64(\u0026sched.lastpoll, uint64(lastpoll), uint64(now)) list := netpoll(0) // non-blocking - returns list of goroutines if !list.empty() { // Need to decrement number of idle locked M's // (pretending that one more is running) before injectglist. // Otherwise it can lead to the following situation: // injectglist grabs all P's but before it starts M's to run the P's, // another M returns from syscall, finishes running its G, // observes that there is no work to do and no other running M's // and reports deadlock. incidlelocked(-1) injectglist(\u0026list) incidlelocked(1) } } if GOOS == \"netbsd\" \u0026\u0026 needSysmonWorkaround { // netpoll is responsible for waiting for timer // expiration, so we typically don't have to worry // about starting an M to service timers. (Note that // sleep for timeSleepUntil above simply ensures sysmon // starts running again when that timer expiration may // cause Go code to run again). // // However, netbsd has a kernel bug that sometimes // misses netpollBreak wake-ups,","date":"2022-10-15","objectID":"/posts/go-gpm-model/:3:1","tags":["Go"],"title":"Go GPM 模型","uri":"/posts/go-gpm-model/"},{"categories":["Go","GPM"],"content":"P - Processor 调度器中的处理器 P 是线程和 Goroutine 的中间层，它能提供线程需要的上下文环境，也会负责调度线程上的等待队列，通过处理器 P 的调度，每一个内核线程都能够执行多个 Goroutine，它能在 Goroutine 进行一些 I/O 操作时及时让出计算资源，提高线程的利用率。 因为调度器在启动时就会创建 GOMAXPROCS 个处理器，所以 Go 语言程序的处理器数量一定会等于 GOMAXPROCS，这些处理器会绑定到不同的内核线程上。 ","date":"2022-10-15","objectID":"/posts/go-gpm-model/:3:2","tags":["Go"],"title":"Go GPM 模型","uri":"/posts/go-gpm-model/"},{"categories":["Go","GPM"],"content":"M - Machine Go 语言并发模型中的 M 是操作系统线程。调度器最多可以创建 10000 个线程，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），最多只会有 GOMAXPROCS 个活跃线程能够正常运行。 在默认情况下，运行时会将 GOMAXPROCS 设置成当前机器的核数，我们也可以在程序中使用 runtime.GOMAXPROCS 来改变最大的活跃线程数。 在默认情况下，一个四核机器会创建四个活跃的操作系统线程，每一个线程都对应一个运行时中的 runtime.m 结构体。 在大多数情况下，我们都会使用 Go 的默认设置，也就是线程数等于 CPU 数，默认的设置不会频繁触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由 Go 语言调度器触发，能够减少很多额外开销。 M 是 Go 代码运行的真实载体，包括 Goroutine 调度器自身的逻辑也是在 M 中运行的。 注意：如果 G 被阻塞在某个 channel 操作或网络 IO 操作上时，M 可以不被阻塞，这避免了大量创建 M 导致的开销。但如果 G 因慢系统调用而阻塞，那么 M 也会一起阻塞，但在阻塞前会与 P 解绑，P 会尝试与其他 M 绑定继续运行其他 G。但若没有现成的 M，Go 运行时会建立新的 M，这也是系统调用可能导致系统线程数量增加的原因。 ","date":"2022-10-15","objectID":"/posts/go-gpm-model/:3:3","tags":["Go"],"title":"Go GPM 模型","uri":"/posts/go-gpm-model/"},{"categories":["Go","GPM"],"content":"参考 https://golang.org/s/go11sched ","date":"2022-10-15","objectID":"/posts/go-gpm-model/:4:0","tags":["Go"],"title":"Go GPM 模型","uri":"/posts/go-gpm-model/"},{"categories":["Linux"],"content":"线程模型 目前存在的线程模型： 传统阻塞 IO 服务模型。 Reactor 模型。 传统阻塞 IO 服务模型的特点： 采用阻塞 IO 模式获取输入的数据。 每个连接都需要独立的线程完成 read -\u003e 业务逻辑 -\u003e send。 传统阻塞 IO 服务模型的缺点： 当并发数很大，就会创建大量的线程，占用很大系统资源，所以它是没办法处理高并发的。 连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在读操作，造成线程资源浪费。 // 传统 IO 服务模型图： +------Application-----------------------------+ | +-------------Handler----------------+ | +---------+ | | +------+ +--------+ +------+ | | | Client1 |-- Request --\u003e| | read | -\u003e | handle | -\u003e | send | | | +---------+ | | +------+ +--------+ +------+ | | | +------------------------------------+ | | | | | | +-------------Handler----------------+ | +---------+ | | +------+ +--------+ +------+ | | | Client2 |-- Request --\u003e| | read | -\u003e | handle | -\u003e | send | | | +---------+ | | +------+ +--------+ +------+ | | | +------------------------------------+ | | | | | | +-------------Handler----------------+ | +---------+ | | +------+ +--------+ +------+ | | | Client3 |-- Request --\u003e| | read | -\u003e | handle | -\u003e | send | | | +---------+ | | +------+ +--------+ +------+ | | | +------------------------------------+ | +----------------------------------------------+ ","date":"2022-10-07","objectID":"/posts/linux-reactor/:1:0","tags":["Linux"],"title":"线程模型之 Reactor 模型","uri":"/posts/linux-reactor/"},{"categories":["Linux"],"content":"Reactor 简介 Reactor 模式也叫分发者（Dispatcher）模式，又叫反应器模式，又称通知者模式（Notifier），即 IO 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程。 Reactor 模型的特点： Reactor 中的 Selector 是可以实现应用程序通过一个阻塞对象监听多路连接请求。 Reactor 对象通过 Selector 监控客户端请求事件，收到事件后通过 Dispatch 进行分发。 Acceptor 通过 accept 来处理建立连接请求事件，然后创建一个 Handler 对象处理连接完成后的后续业务处理。 Handler 会完成 read -\u003e 业务逻辑 -\u003e send。 Reactor 模型的优点： 响应快，不必为单个同步事件所阻塞，虽然 Reactor 本身依然是同步的。 可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程 / 进程的切换开销。 扩展性好，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源。 复用性好，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性。 模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成。 Reactor 模型的缺点： 性能问题：只有一个线程，无法完全发挥多核 CPU 的性能。Handler 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈。 可靠性问题：线程意外终止或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。 Reactor 模型的核心是 Reactor 加上对应的处理器 Handler，Reactor 在一个单独的线程中运行，负责监听和分发事件，将接收到的事件交给不同的 Handler 来处理，Handler 是处理程序执行 IO 事件的实际操作，它俩负责的事情如下： Reactor：负责监听和分发事件，事件类型包含连接事件、读写事件。 Handler：负责处理 Reactor 分发的事件，如 read -\u003e 业务逻辑 -\u003e send。 Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于： Reactor 的数量可以只有一个，也可以有多个。 Handler 可以是单个进程 / 线程，也可以是多个进程 /线程。 将上面的两个因素排列组合一下，理论上就可以有 4 种方案选择： 单 Reactor 单进程 / 线程，通俗点就是「接待员和服务员是同一个人，全程为顾客服务」。 单 Reactor 多进程 / 线程，通俗点就是「一个接待员，多个服务员，接待员只负责接待顾客，打个招呼就让服务员上」。 多 Reactor 单进程 / 线程，通俗点就是「多个接待员，一个服务员，暂时还没见过这么变态的」。 多 Reactor 多进程 / 线程，通俗点就是「多个接待员，多个服务员」。 其中，「多 Reactor 单进程 / 线程」实现方案相比「单 Reactor 单进程 / 线程」方案，不仅复杂而且也没有性能优势，因此实际中并没有应用。 剩下的 3 个方案都是比较经典的，且都有应用在实际的项目中： 单 Reactor 单进程 / 线程。 单 Reactor 多线程 / 进程。 多 Reactor 多进程 / 线程。 方案具体使用进程还是线程，要看使用的编程语言以及平台有关： Java 语言一般使用线程，比如 Netty。 C 语言使用进程和线程都可以，例如 Nginx 使用的是进程，Memcache 使用的是线程。 ","date":"2022-10-07","objectID":"/posts/linux-reactor/:2:0","tags":["Linux"],"title":"线程模型之 Reactor 模型","uri":"/posts/linux-reactor/"},{"categories":["Linux"],"content":"单 Reactor 单进程 / 线程 单 Reactor 单进程有 Reactor、Acceptor、Handler 这三个对象： Reactor：监听和分发事件。 Acceptor：获取连接。 Handler：处理业务。 所以，单 Reactor 单进程的方案不适用 计算密集型（CPU 密集型） 的场景，只适用于业务处理非常快速的场景。 Redis 是由 C 语言实现的，它采用的正是「单 Reactor 单进程」的方案，因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上，所以 Redis 对于命令的处理是单进程的方案。 单 Reactor 单进程 / 线程处理过程： Reactor 对象通过 select（IO 多路复用接口）监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型。 如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件。 如果不是连接建立事件，则交由当前连接对应的 Handler 对象来进行响应。 Handler 对象通过 read -\u003e 业务处理 -\u003e send 的流程来完成完整的业务流程。 单 Reactor 单进程 / 线程方案的缺点： 只有一个进程，无法充分利用多核 CPU 的性能。 Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，如果业务处理耗时比较长，那么就造成响应的延迟。 ","date":"2022-10-07","objectID":"/posts/linux-reactor/:3:0","tags":["Linux"],"title":"线程模型之 Reactor 模型","uri":"/posts/linux-reactor/"},{"categories":["Linux"],"content":"单 Reactor 多线程 / 多进程 单 Reactor 多线程 / 多进程处理过程： Reactor 对象通过 select（IO 多路复用接口）监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型。 如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件。 如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应。Handler 对象不再负责业务处理，只负责数据的接收和发送，Handler 对象通过 read 读取到数据后，会将数据发给子线程里的 Processor 对象进行业务处理。 子线程里的 Processor 对象就进行业务处理，处理完后，将结果发给主线程中的 Handler 对象，接着由 Handler 通过 send 方法将响应结果发送给 client。 单 Reator 多线程的方案优势在于能够充分利用多核 CPU 的能，那既然引入多线程，那么自然就带来了多线程竞争资源的问题。要避免多线程由于竞争共享资源而导致数据错乱的问题，就需要在操作共享资源前加上互斥锁，以保证任意时间里只有一个线程在操作共享资源，待该线程操作完释放互斥锁后，其他线程才有机会操作共享数据。 单 Reactor 多进程相比单 Reactor 多线程实现起来很麻烦，主要因为要考虑子进程 \u003c-\u003e 父进程的双向通信，并且父进程还得知道子进程要将数据发送给哪个客户端。 而多线程间可以共享数据，虽然要额外考虑并发问题，但是这远比进程间通信的复杂度低得多，因此实际应用中也看不到单 Reactor 多进程的模式。 单 Reactor 多线程 / 多进程优点：可以充分地利用多核 CPU 的处理能力。 单 Reactor 多线程 / 多进程缺点：一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方。 ","date":"2022-10-07","objectID":"/posts/linux-reactor/:4:0","tags":["Linux"],"title":"线程模型之 Reactor 模型","uri":"/posts/linux-reactor/"},{"categories":["Linux"],"content":"多 Reactor 多进程 / 线程 多 Reactor 多进程 / 线程处理过程： 主线程中的 MainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 对象中的 accept 获取连接，将新的连接分配给某个子线程。 子线程中的 SubReactor 对象将 MainReactor 对象分配的连接加入 select 继续进行监听，并创建一个 Handler 用于处理连接的响应事件。 如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应。 Handler 对象通过 read -\u003e 业务处理 -\u003e send 的流程来完成完整的业务流程。 多 Reactor 多线程的方案虽然看起来复杂的，但是实际实现时比单 Reactor 多线程的方案要简单的多，原因如下： 主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理。 主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端。 多 Reactor 多进程 / 线程优点： 父线程与子线程的数据交互简单职责明确, 父线程只需要接收新连接, 子线程完成后续的业务处理。 父线程与子线程的数据交互简单, Reactor 主线程只需要把新连接传给子线程, 子线程无需返回数据。 多 Reactor 多进程 / 线程缺点：编程复杂度较高。 惊群效应（Thundering Herd）是指多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），但是最终却只能有一个进程（线程）获得这个时间的「控制权」，对该事件进行处理，而其他进程（线程）获取「控制权」失败，只能重新进入休眠状态，会产生不必要的 CPU 空转，导致的这种现象和性能浪费就称惊群效应或惊群现象。 开源软件 Netty 和 Memcache 都采用了「多 Reactor 多线程」的方案。而采用了「多 Reactor 多进程」方案的开源软件是 Nginx，不过方案与标准的多 Reactor 多进程有些差异。具体差异表现在主进程中仅仅用来初始化 socket，并没有创建 MainReactor 来 accept 连接，而是由子进程的 Reactor 来 accept 连接，通过锁来控制一次只有一个子进程进行 accept（防止出现惊群现象），子进程 accept 新连接后就放到自己的 Reactor 进行处理，不会再分配给其他子进程。 ","date":"2022-10-07","objectID":"/posts/linux-reactor/:5:0","tags":["Linux"],"title":"线程模型之 Reactor 模型","uri":"/posts/linux-reactor/"},{"categories":["Linux"],"content":"参考 Scalable IO in Java Why Threads Are A Bad Idea (for most purposes) ","date":"2022-10-07","objectID":"/posts/linux-reactor/:6:0","tags":["Linux"],"title":"线程模型之 Reactor 模型","uri":"/posts/linux-reactor/"},{"categories":["Go","gRPC"],"content":"gRPC 是一个现代的开源高性能远程过程调用（RPC - Remote Procedure Call）框架，可以在任何环境中运行。它可以通过对负载平衡、跟踪、健康检查和身份验证的可插拔支持，有效地连接数据中心内和跨数据中心的服务。它也适用于分布式计算的最后一英里，将设备、移动应用程序和浏览器连接到后端服务。 ","date":"2022-06-20","objectID":"/posts/go-grpc/:0:0","tags":["Go"],"title":"Go gRPC","uri":"/posts/go-grpc/"},{"categories":["Go","gRPC"],"content":"gRPC 的特性 简单服务定义：使用 Protocol Buffers 定义你的服务，这是一个强大的二进制序列化工具集和语言； 快速启动并扩展：只需一行代码即可安装运行时和开发环境，还可以通过该框架扩展到每秒数百万个 RPCs； 跨语言和平台工作：使用多种语言和平台自动为你的服务生成惯用的客户端和服务器桩； 双向流和集成身份验证：双向流式传输和完全集成的可插拔身份验证，以及基于 HTTP/2 的传输； ","date":"2022-06-20","objectID":"/posts/go-grpc/:1:0","tags":["Go"],"title":"Go gRPC","uri":"/posts/go-grpc/"},{"categories":["Go","gRPC"],"content":"gRPC 与 RPC 的关系 RPC 是一种协议，gRPC 是基于 RPC 协议实现的一种框架； gRPC 解决了 RPC 的三大问题： 协议约定； 传输协议； 服务发现； ","date":"2022-06-20","objectID":"/posts/go-grpc/:2:0","tags":["Go"],"title":"Go gRPC","uri":"/posts/go-grpc/"},{"categories":["Go","gRPC"],"content":"gRPC 适用场景 ","date":"2022-06-20","objectID":"/posts/go-grpc/:3:0","tags":["Go"],"title":"Go gRPC","uri":"/posts/go-grpc/"},{"categories":["Go","gRPC"],"content":"gRPC 环境配置 ","date":"2022-06-20","objectID":"/posts/go-grpc/:4:0","tags":["Go"],"title":"Go gRPC","uri":"/posts/go-grpc/"},{"categories":["Go","gRPC"],"content":"安装 protobuf $ brew install autoconf automake libtool $ brew install protobuf --HEAD 或 $ git clone https://github.com/protocolbuffers/protobuf.git $ cd protobuf $ git submodule update --init --recursive $ ./autogen.sh $ ./configure $ make $ make check $ sudo make install ","date":"2022-06-20","objectID":"/posts/go-grpc/:4:1","tags":["Go"],"title":"Go gRPC","uri":"/posts/go-grpc/"},{"categories":["Go","gRPC"],"content":"安装 Go 的协议编译器插件 $ go install github.com/golang/protobuf/protoc-gen-go@v1.5.2 $ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2.0 ","date":"2022-06-20","objectID":"/posts/go-grpc/:4:2","tags":["Go"],"title":"Go gRPC","uri":"/posts/go-grpc/"},{"categories":["Go","gRPC"],"content":"更新 PATH 路径 $ export PATH=\"$PATH:$(go env GOPATH)/bin\" ","date":"2022-06-20","objectID":"/posts/go-grpc/:4:3","tags":["Go"],"title":"Go gRPC","uri":"/posts/go-grpc/"},{"categories":["Go","gRPC"],"content":"实例 ","date":"2022-06-20","objectID":"/posts/go-grpc/:5:0","tags":["Go"],"title":"Go gRPC","uri":"/posts/go-grpc/"},{"categories":["Go","gRPC"],"content":"实例一 定义服务 $ mkdir greeter $ cd greeter $ mkdir hello 在 hello 目录下创建 hello.proto 文件并复制以下内容： syntax = \"proto3\"; option go_package = \"greeter.io/greeter/examples/hello/hello\"; option java_multiple_files = true; option java_package = \"io.greeter.examples.hello\"; option java_outer_classname = \"HelloProto\"; package hello; // The greeting service definition. service Greeter { // Sends a greeting. rpc hello(HelloRequest) returns (HelloResponse) {} } // The request message containing the user's name. message HelloRequest { string name = 1; } // The response message containing the greetings. message HelloResponse { string message = 1; } 完成后在 greeter 目录下执行以下命令： $ protoc --go_out=. --go_opt=paths=source_relative \\ --go-grpc_out=. --go-grpc_opt=paths=source_relative \\ hello/hello.proto 命令完成后在 hello 目录下会生成 hello_grpc.pb.go 和 hello.pb.go 文件。 编写服务端 在 greeter/cmd/server/main.go 文件中添加以下代码： package main import ( \"context\" \"flag\" \"fmt\" \"greeter/hello\" \"log\" \"net\" \"google.golang.org/grpc\" ) var ( port = flag.Int(\"port\", 50051, \"The server port\") ) type server struct { hello.UnimplementedGreeterServer } func (s *server) Hello(ctx context.Context, in *hello.HelloRequest) (*hello.HelloResponse, error) { log.Printf(\"Received: %v\", in.GetName()) return \u0026hello.HelloResponse{Message: \"Hello \" + in.GetName()}, nil } func main() { flag.Parse() lis, err := net.Listen(\"tcp\", fmt.Sprintf(\":%d\", *port)) if err != nil { log.Fatalf(\"failed to listen: %v\", err) } s := grpc.NewServer() hello.RegisterGreeterServer(s, \u0026server{}) log.Printf(\"Server listening at %v\", lis.Addr()) if err := s.Serve(lis); err != nil { log.Fatalf(\"failed to serve: %v\", err) } } 启动 grpc server 服务： $ go run cmd/server/main.go 2022/06/21 13:49:19 Server listening at [::]:50051 编写客户端 在 greeter/cmd/client/main.go 文件中添加以下代码： package main import ( \"context\" \"flag\" \"greeter/hello\" \"log\" \"time\" \"google.golang.org/grpc\" \"google.golang.org/grpc/credentials/insecure\" ) const ( defaultName = \"World, Hello Go! 🎉\" ) var ( addr = flag.String(\"addr\", \"localhost:50051\", \"The address to connect to\") name = flag.String(\"name\", defaultName, \"The name to greet\") ) func main() { flag.Parse() // Set up a connection to the server. conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(insecure.NewCredentials())) if err != nil { log.Fatalf(\"did not connect: %v\", err) } defer conn.Close() c := hello.NewGreeterClient(conn) ctx, cancel := context.WithTimeout(context.Background(), time.Second) defer cancel() r, err := c.Hello(ctx, \u0026hello.HelloRequest{Name: *name}) if err != nil { log.Fatalf(\"could not greet: %v\", err) } log.Printf(\"Greeting: %s\", r.GetMessage()) } 启动 grpc client 服务： $ go run cmd/client/main.go --name=\"World, Hello Go 🎉\" 2022/06/21 13:51:36 Greeting: Hello World, Hello Go 🎉 最终的代码目录结构： . ├── cmd │ ├── client │ │ └── main.go │ └── server │ └── main.go ├── go.mod ├── go.sum └── hello ├── hello.pb.go ├── hello.proto └── hello_grpc.pb.go ","date":"2022-06-20","objectID":"/posts/go-grpc/:5:1","tags":["Go"],"title":"Go gRPC","uri":"/posts/go-grpc/"},{"categories":["Go","gRPC"],"content":"实例二 定义服务 $ mkdir routeguide $ cd routeguide $ mkdir route 在 route 目录下创建 route.proto 文件并复制以下内容： syntax = \"proto3\"; option go_package = \"routeguide/route\"; option java_multiple_files = true; option java_package = \"io.routeguide.route\"; option java_outer_classname = \"RouteProto\"; package route; // Interface exported by the server. service Route { // A simple RPC. // // Obtains the feature at a given position. // // A feature with an empty name is returned if there's no feature // at the give position. rpc GetFeature(Point) returns (Feature) {} // A server-to-client streaming RPC. // // Obtains the features available within the given Rectangle. Results // are streamed rather than returned at once (e.g. in a response message // with a repeated field), as the rectangle may cover a large area and // contain a huge number of features. rpc GetFeatures(Rectangle) returns (stream Feature) {} // A client-to-server streaming RPC. // // Accepts a stream of Points on a route being traversed, returning // a RouteSummary when traversal is completed. rpc RecordRoute(stream Point) returns (RouteSummary) {} // A Bidirectional streaming RPC. // // Accepts a stream of RouteNotes sent whil a route is being traversed, // while receiving other RouteNotes (e.g. from other users). rpc RouteChat(stream RouteNote) returns (stream RouteNote) {} } // Points are represented as latitude-longitude pairs in the E7 representation // (degrees multiplied by 10**7 and rounded to the nearest interger). // Latitude should be in the range +/- 90 degrees and longitude should be in // the range +/- 180 degrees (inclusive). message Point { int32 latitude = 1; int32 longitude = 2; } // A latitude-longitude rectangle, represented as two diagonally opposite // points \"lo\" and \"hi\". message Rectangle { // One corner of the rectangle. Point lo = 1; // The other corner of the rectangle. Point hi = 2; } // A feature names something at a given point. // // If a feature could not be named, the name is empty. message Feature { // The name of the feature. string name = 1; // The point where the feature is detected. Point location = 2; } // A RouteNote is a message sent while at a given point. message RouteNote { // The location from which the message is sent. Point location = 1; // The message to be sent. string message = 2; } // A RouteSummary is received in response to a RecordRoute rpc. // // It contains the number of individual points received, the number // of detected features, and the total distance covered as the // cumulative sum of the distance between eath point. message RouteSummary { // The number of points received. int32 point_count = 1; // The number of known features passed while traversing the route. int32 feature_count = 2; // The distance covered in metres. int32 distance = 3; // The duration of the traversal in seconds. int32 elapsed_time = 4; } 完成后在 routeguide 目录下执行以下命令： $ protoc --go_out=. --go_opt=paths=source_relative \\ --go-grpc_out=. --go-grpc_opt=paths=source_relative \\ route/route.proto 编写服务端 在 routeguide/cmd/server/main.go 文件中添加以下代码： // Package main implements a simple gRPC server that demonstrates how to use gRPC-Go libraries // to perform unary, client streaming, server streaming and full duplex RPCs. // // It implements the route service whose definition can be found in routeguide/route.proto. package main import ( \"context\" \"encoding/json\" \"flag\" \"fmt\" \"io\" \"io/ioutil\" \"log\" \"math\" \"net\" \"sync\" \"time\" \"github.com/golang/protobuf/proto\" \"google.golang.org/grpc\" \"google.golang.org/grpc/credentials\" \"routeguide/data\" pb \"routeguide/route\" ) var ( tls = flag.Bool(\"tls\", false, \"Connection uses TLS if true, else plain TCP\") keyfile = flag.String(\"keyfile\", \"\", \"The TLS key file\") certfile = flag.String(\"certfile\", \"\", \"The TLS certificate file\") jsonfile = flag.String(\"jsonfile\", \"\", \"A JSON file containing a list of features\") port = flag.Int(\"port\", 50051, \"The server port\") ) type routeServer struct { pb.UnimplementedRouteServer // read-only after in","date":"2022-06-20","objectID":"/posts/go-grpc/:5:2","tags":["Go"],"title":"Go gRPC","uri":"/posts/go-grpc/"},{"categories":null,"content":"文档手册 ","date":"2022-06-17","objectID":"/docs/:1:0","tags":null,"title":"Docs","uri":"/docs/"},{"categories":null,"content":"技术文档 PHP PHP Programming Language Rust Rust Programming Language Go Go Programming Language MySQL MySQL 8.0 Reference Manual Nginx NGINX is a free, open-source, high-performance HTTP server Server Programming Guide Server Programming Guide Linux Tools Quick Tutorial Linux Tools Quick Tutorial Docker Develop faster. Run anywhere Kubernetes Production-Grade Container Orchestration ","date":"2022-06-17","objectID":"/docs/:1:1","tags":null,"title":"Docs","uri":"/docs/"},{"categories":null,"content":"工具手册 golangci-lint Go linters aggregator go-swagger Swagger 2.0 implementation for go jaeger Jaeger: open source, end-to-end distributed tracing ","date":"2022-06-17","objectID":"/docs/:1:2","tags":null,"title":"Docs","uri":"/docs/"},{"categories":null,"content":"效率工具 ","date":"2022-06-17","objectID":"/docs/:2:0","tags":null,"title":"Docs","uri":"/docs/"},{"categories":null,"content":"协作工具 腾讯文档 让协作更高效，创作更轻松。 石墨文档 全新一代云端 Office，面向未来的办公软件 金山文档 一起办公才高效 语雀 用语雀，构建你的数字花园 ","date":"2022-06-17","objectID":"/docs/:2:1","tags":null,"title":"Docs","uri":"/docs/"},{"categories":null,"content":"翻译工具 剑桥英语翻译 剑桥英语词典 DeepL 翻译 人工智能辅助翻译系统 句酷 例句搜索 CNKI翻译助手 知网旗下翻译网站 谷歌翻译 谷歌翻译官网 百度翻译 全球领先的翻译能力 Saladict 沙拉查词 聚合词典专业划词翻译 ","date":"2022-06-17","objectID":"/docs/:2:2","tags":null,"title":"Docs","uri":"/docs/"},{"categories":null,"content":"网页工具 颜色选择器 颜色选择器、颜色表和HTML颜色名称 颜色值 CSS 数据类型 \u003ccolor\u003e 表示一种标准 RGB 色彩空间（sRGB color space）的颜色。 excalidraw Virtual whiteboard for sketching hand-drawn like diagrams ","date":"2022-06-17","objectID":"/docs/:2:3","tags":null,"title":"Docs","uri":"/docs/"},{"categories":null,"content":"制图工具 figma Design, prototype, and gather feedback all in one place with Figma. AI 人工智能图片放大 Bigjpg - AI 人工智能图片无损放大 iconfont 阿里巴巴矢量图库 Color Hunt Color Palettes for Designers and Artists Design screenshots Beautify screenshots in seconds Favicon Favicon Generator. For real. ","date":"2022-06-17","objectID":"/docs/:2:4","tags":null,"title":"Docs","uri":"/docs/"},{"categories":null,"content":"代码工具 ","date":"2022-06-17","objectID":"/docs/:3:0","tags":null,"title":"Docs","uri":"/docs/"},{"categories":null,"content":"效率工具 JSON to YAMl Convert JSON to YAML online FeHelper Web 开发者助手 FeHelper k8s yaml generator Kubernetes YAML Generator ","date":"2022-06-17","objectID":"/docs/:3:1","tags":null,"title":"Docs","uri":"/docs/"},{"categories":null,"content":"代码分享 codeimg Create and share beautiful images of your source code. carbon Create and share beautiful images of your source code showcode Create beautiful images of code. ","date":"2022-06-17","objectID":"/docs/:3:2","tags":null,"title":"Docs","uri":"/docs/"},{"categories":null,"content":"代码速查 Dot Net Perls Visit example pages for many languages. ","date":"2022-06-17","objectID":"/docs/:3:3","tags":null,"title":"Docs","uri":"/docs/"},{"categories":null,"content":"命令工具 httpie HTTPie: human-friendly CLI HTTP client for the API era ","date":"2022-06-17","objectID":"/docs/:3:4","tags":null,"title":"Docs","uri":"/docs/"},{"categories":null,"content":"AI 工具 chatpdf Chat with any PDF ","date":"2022-06-17","objectID":"/docs/:4:0","tags":null,"title":"Docs","uri":"/docs/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"栈和队列可看作是特殊的线性表。它们的特殊性表现在它们的基本运算是线性表运算的子集，它们是运算受限的线性表。 数据结构与算法起步 线性表 栈和队列 ","date":"2022-05-14","objectID":"/posts/ds-stack-queue/:0:0","tags":["Data Structure \u0026 Algorithm"],"title":"栈和队列","uri":"/posts/ds-stack-queue/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"栈 ","date":"2022-05-14","objectID":"/posts/ds-stack-queue/:1:0","tags":["Data Structure \u0026 Algorithm"],"title":"栈和队列","uri":"/posts/ds-stack-queue/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"栈的概念 栈（Stack） ：是运算受限的线性表，其上的插入和删除运算限定在表的某一端进行，允许进行插入和删除的一端称为 栈顶，另一端称为 栈底。不含任何数据元素的栈称为 空栈。处于栈顶位置的数据元素称为 栈顶元素。 栈的修改原则：后进先出（LIFO - Last In First Out），因此，栈又称为后进先出的线性表，简称 后进先出表。栈的插入和删除运算分别称为 进栈 和 出栈。 上溢：栈中的数据元素已经填满了，如果再进行进栈操作，会发生「上溢」，为了防止数据丢失，在进栈操作之前应该判断是否栈满。 下溢：栈初始化运算得到一个空栈，此时，栈顶下标值 top==0，如果此时做出栈运算，则产生「下溢」。 栈相关函数定义： #ifndef DS_ALGO_DEMO_STACK_H #define DS_ALGO_DEMO_STACK_H #include \u003cstdbool.h\u003e #define MAX_STACK_SIZE 5 // 顺序栈 typedef struct stack { int data[MAX_STACK_SIZE]; // 存储栈中数据元素的数组 int top; // 标志栈顶位置的变量 } ArrayStack; ArrayStack *CreateArrayStack(); bool PushArrayStack(ArrayStack *stack, int value); bool PopArrayStack(ArrayStack *stack); int GetTopArrayStack(ArrayStack *stack); bool IsEmptyArrayStack(ArrayStack *stack); // 链式栈 typedef struct node { int data; struct node *next; } LinkedStack; LinkedStack *CreateLinkedStack(); bool PushLinkedStack(LinkedStack *stack, int value); bool PopLinkedStack(LinkedStack *stack); int GetTopLinkedStack(LinkedStack *stack); bool IsEmptyLinkedStack(LinkedStack *stack); #endif ","date":"2022-05-14","objectID":"/posts/ds-stack-queue/:1:1","tags":["Data Structure \u0026 Algorithm"],"title":"栈和队列","uri":"/posts/ds-stack-queue/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"顺序栈 实现代码： #include \"stack.h\" #include \u003cstdlib.h\u003e ArrayStack *CreateArrayStack() { ArrayStack *stack = (ArrayStack *) malloc(sizeof(ArrayStack)); if (stack == NULL) { return NULL; } stack-\u003etop = 0; return stack; } bool PushArrayStack(ArrayStack *stack, int value) { if (stack-\u003etop == MAX_STACK_SIZE - 1) { return false; } stack-\u003etop++; stack-\u003edata[stack-\u003etop] = value; return true; } bool PopArrayStack(ArrayStack *stack) { if (IsEmptyArrayStack(stack)) { return false; } stack-\u003etop--; return true; } int GetTopArrayStack(ArrayStack *stack) { if (IsEmptyArrayStack(stack)) { return 0; } return stack-\u003edata[stack-\u003etop]; } bool IsEmptyArrayStack(ArrayStack *stack) { return stack-\u003etop == 0; } 测试代码： #include \u003cgtest/gtest.h\u003e extern \"C\" { #include \"../src/stack/stack.h\" } TEST(TestArrayStack, CreateArrayStack) { ArrayStack *stack = CreateArrayStack(); ASSERT_EQ(0, GetTopArrayStack(stack)); ASSERT_EQ(0, stack-\u003etop); ASSERT_TRUE(IsEmptyArrayStack(stack)); } TEST(TestArrayStack, PushArrayStack) { ArrayStack *stack = CreateArrayStack(); for (int i = 1; i \u003c 5; i++) { ASSERT_TRUE(PushArrayStack(stack, i)); ASSERT_EQ(i, GetTopArrayStack(stack)); ASSERT_EQ(i, stack-\u003etop); } ASSERT_FALSE(PushArrayStack(stack, 5)); ASSERT_EQ(4, GetTopArrayStack(stack)); ASSERT_EQ(4, stack-\u003etop); } TEST(TestArrayStack, PopArrayStack) { ArrayStack *stack = CreateArrayStack(); for (int i = 1; i \u003c 5; i++) { ASSERT_TRUE(PushArrayStack(stack, i)); ASSERT_EQ(i, GetTopArrayStack(stack)); ASSERT_EQ(i, stack-\u003etop); } for (int i = 1; i \u003c 5; i++) { ASSERT_TRUE(PopArrayStack(stack)); } ASSERT_FALSE(PopArrayStack(stack)); ASSERT_EQ(0, GetTopArrayStack(stack)); ASSERT_EQ(0, stack-\u003etop); ASSERT_TRUE(IsEmptyArrayStack(stack)); } ","date":"2022-05-14","objectID":"/posts/ds-stack-queue/:1:2","tags":["Data Structure \u0026 Algorithm"],"title":"栈和队列","uri":"/posts/ds-stack-queue/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"链式栈 实现代码： #include \"stack.h\" #include \u003cstdlib.h\u003e LinkedStack *CreateLinkedStack() { LinkedStack *stack = (LinkedStack *) malloc(sizeof(LinkedStack)); if (stack == NULL) { return NULL; } stack-\u003enext = NULL; return stack; } bool PushLinkedStack(LinkedStack *stack, int value) { LinkedStack *temp; temp = (LinkedStack *) malloc(sizeof(LinkedStack)); if (temp == NULL) { return false; } temp-\u003edata = value; temp-\u003enext = stack-\u003enext; stack-\u003enext = temp; return true; } bool PopLinkedStack(LinkedStack *stack) { if (IsEmptyLinkedStack(stack)) { return false; } LinkedStack *temp; temp = stack-\u003enext; stack-\u003enext = temp-\u003enext; free(temp); return true; } int GetTopLinkedStack(LinkedStack *stack) { if (IsEmptyLinkedStack(stack)) { return 0; } return stack-\u003enext-\u003edata; } bool IsEmptyLinkedStack(LinkedStack *stack) { return stack-\u003enext == NULL; } 测试代码： #include \u003cgtest/gtest.h\u003e extern \"C\" { #include \"../src/stack/stack.h\" } TEST(TestLinkedStack, CreateLinkedStack) { LinkedStack *stack = CreateLinkedStack(); ASSERT_EQ(0, GetTopLinkedStack(stack)); ASSERT_EQ(NULL, stack-\u003enext); ASSERT_TRUE(IsEmptyLinkedStack(stack)); } TEST(TestLinkedStack, PushLinkedStack) { LinkedStack *stack = CreateLinkedStack(); for (int i = 1; i \u003c MAX_STACK_SIZE * 2; i++) { ASSERT_TRUE(PushLinkedStack(stack, i)); ASSERT_EQ(i, GetTopLinkedStack(stack)); ASSERT_EQ(i, stack-\u003enext-\u003edata); } ASSERT_EQ(9, stack-\u003enext-\u003edata); } TEST(TestLinkedStack, PopLinkedStack) { LinkedStack *stack = CreateLinkedStack(); for (int i = 1; i \u003c MAX_STACK_SIZE * 2; i++) { ASSERT_TRUE(PushLinkedStack(stack, i)); ASSERT_EQ(i, GetTopLinkedStack(stack)); ASSERT_EQ(i, stack-\u003enext-\u003edata); } for (int i = 1; i \u003c MAX_STACK_SIZE * 2; i++) { ASSERT_TRUE(PopLinkedStack(stack)); } ASSERT_FALSE(PopLinkedStack(stack)); ASSERT_TRUE(IsEmptyLinkedStack(stack)); ASSERT_EQ(0, GetTopLinkedStack(stack)); ASSERT_EQ(NULL, stack-\u003enext); ASSERT_EQ(0, stack-\u003edata); } ","date":"2022-05-14","objectID":"/posts/ds-stack-queue/:1:3","tags":["Data Structure \u0026 Algorithm"],"title":"栈和队列","uri":"/posts/ds-stack-queue/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"递归与栈 递归（Recursion）：如果在一个函数或数据结构的定义中又应用了它自身（作为定义项之一），那么这个函数或数据结构称为是递归定义的，简称递归。 递归定义不能是「循环定义」，为此要求任何递归定义必须同时满足如下两个条件： 被定义项在定义中的应用（即作为定义项的出现）具有更小的「规模」； 被定义项在最小「规模」上的定义是非递归，这是递归的结束条件； 递归函数的运行引起递归调用。为了保证在不同层次的递归调用能正确地返回，必须将每一次递归调用的参数和返回地址保存起来。由于函数的递归调用是后进先出的，所以要用栈来保存这些值。 ","date":"2022-05-14","objectID":"/posts/ds-stack-queue/:1:4","tags":["Data Structure \u0026 Algorithm"],"title":"栈和队列","uri":"/posts/ds-stack-queue/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"对列 ","date":"2022-05-14","objectID":"/posts/ds-stack-queue/:2:0","tags":["Data Structure \u0026 Algorithm"],"title":"栈和队列","uri":"/posts/ds-stack-queue/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"对列的概念 队列（Queue）：是有限个同类型数据元素的线性序列，是一种先进先出（FIFO - First In First Out）的线性表，新加入的数据元素插在队列尾端，出队列的数据元素在队列首端被删除。 队列结构的几个属性： 队尾：插入的一端叫做队尾； 队头：删除的一端叫做队头； 入队：向队列中插入新节点元素称为入队； 出队：从队列中删除节点元素称为出队； 队空：当队列中无节点元素时，表示队空； 队满：当队列中节点超过允许存储空间时，表示队满（链队无队满的状态）； 循环队列中的几个约束： 队空：head = tail； 队满：head = (tail+1)%size； 进队：head = (head+1)%size； 出队：tail = (tail+1)%size； 个数：(tail-head+size)%size； 队列相关函数定义： #ifndef DS_ALGO_DEMO_QUEUE_H #define DS_ALGO_DEMO_QUEUE_H #include \u003cstdbool.h\u003e #define MAX_QUEUE_SIZE 100 // 顺序队列 typedef struct queue { int data[MAX_QUEUE_SIZE]; int head, tail; } ArrayQueue; ArrayQueue *CreateArrayQueue(); bool EnArrayQueue(ArrayQueue *queue, int value); bool DeArrayQueue(ArrayQueue *queue); int GetHeadArrayQueue(ArrayQueue *queue); bool IsFullArrayQueue(ArrayQueue *queue); bool IsEmptyArrayQueue(ArrayQueue *queue); // 循环顺序队列 typedef struct caqueue { int data[MAX_QUEUE_SIZE]; int head, tail; } CircularArrayQueue; CircularArrayQueue *CreateCircularArrayQueue(); bool EnCircularArrayQueue(CircularArrayQueue *queue, int value); bool DeCircularArrayQueue(CircularArrayQueue *queue); int GetHeadCircularArrayQueue(CircularArrayQueue *queue); bool IsFullCircularArrayQueue(CircularArrayQueue *queue); bool IsEmptyCircularArrayQueue(CircularArrayQueue *queue); // 链式队列 typedef struct node { int data; struct node *next; } LinkedQueueNode; typedef struct lkqueue { LinkedQueueNode *head, *tail; } LinkedQueue; LinkedQueue *CreateLinkedQueue(); bool EnLinkedQueue(LinkedQueue *queue, int value); bool DeLinkedQueue(LinkedQueue *queue); int GetHeadLinkedQueue(LinkedQueue *queue); bool IsEmptyLinkedQueue(LinkedQueue *queue); // 循环链式队列 typedef struct cnode { int data; struct cnode *next; } CircularLinkedQueueNode; typedef struct clkqueue { CircularLinkedQueueNode *head, *tail; int len; int cap; } CircularLinkedQueue; CircularLinkedQueue *CreateCircularLinkedQueue(int cap); bool EnCircularLinkedQueue(CircularLinkedQueue *queue, int value); bool DeCircularLinkedQueue(CircularLinkedQueue *queue); int GetHeadCircularLinkedQueue(CircularLinkedQueue *queue); bool IsEmptyCircularLinkedQueue(CircularLinkedQueue *queue); bool IsFullCircularLinkedQueue(CircularLinkedQueue *queue); #endif ","date":"2022-05-14","objectID":"/posts/ds-stack-queue/:2:1","tags":["Data Structure \u0026 Algorithm"],"title":"栈和队列","uri":"/posts/ds-stack-queue/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"顺序对列 顺序对列（Sequential Queue）：是由一个一维数组（用于存储对列中元素）及两个分别指示队列首和队列尾元素的变量组成，这两个变量分别称为「队列首指针」和「队列尾指针」。 实现代码： #include \"queue.h\" #include \u003cstdlib.h\u003e ArrayQueue *CreateArrayQueue() { ArrayQueue *queue = (ArrayQueue *) malloc(sizeof(ArrayQueue)); if (queue == NULL) { return NULL; } queue-\u003ehead = queue-\u003etail = 0; return queue; } bool EnArrayQueue(ArrayQueue *queue, int value) { if (IsFullArrayQueue(queue) || value \u003c= 0) { return false; } queue-\u003edata[queue-\u003etail] = value; queue-\u003etail++; return true; } bool DeArrayQueue(ArrayQueue *queue) { if (IsEmptyArrayQueue(queue)) { return false; } queue-\u003ehead++; return true; } int GetHeadArrayQueue(ArrayQueue *queue) { if (IsEmptyArrayQueue(queue)) { return 0; } return queue-\u003edata[queue-\u003ehead]; } bool IsFullArrayQueue(ArrayQueue *queue) { return queue-\u003etail == MAX_QUEUE_SIZE; } bool IsEmptyArrayQueue(ArrayQueue *queue) { return queue-\u003ehead == queue-\u003etail; } 测试代码： #include \u003cgtest/gtest.h\u003e extern \"C\" { #include \"../src/queue/queue.h\" } TEST(TestArrayQueue, CreateArrayQueue) { ArrayQueue *queue = CreateArrayQueue(); ASSERT_EQ(0, queue-\u003ehead); ASSERT_EQ(0, queue-\u003etail); ASSERT_TRUE(IsEmptyArrayQueue(queue)); ASSERT_FALSE(IsFullArrayQueue(queue)); ASSERT_EQ(0, GetHeadArrayQueue(queue)); } TEST(TestArrayQueue, EnArrayQueue) { ArrayQueue *queue = CreateArrayQueue(); ASSERT_FALSE(EnArrayQueue(queue, 0)); for (int i = 1; i \u003c= MAX_QUEUE_SIZE; i++) { ASSERT_TRUE(EnArrayQueue(queue, i)); ASSERT_EQ(1, GetHeadArrayQueue(queue)); } ASSERT_TRUE(IsFullArrayQueue(queue)); ASSERT_FALSE(EnArrayQueue(queue, MAX_QUEUE_SIZE)); ASSERT_EQ(1, GetHeadArrayQueue(queue)); } TEST(TestArrayQueue, DeArrayQueue) { int i; ArrayQueue *queue = CreateArrayQueue(); ASSERT_FALSE(DeArrayQueue(queue)); for (i = 1; i \u003c= MAX_QUEUE_SIZE; i++) { EnArrayQueue(queue, i); } for (i = 1; i \u003c= MAX_QUEUE_SIZE; i++) { ASSERT_EQ(i, GetHeadArrayQueue(queue)); ASSERT_TRUE(DeArrayQueue(queue)); } ASSERT_FALSE(DeArrayQueue(queue)); ASSERT_TRUE(IsEmptyArrayQueue(queue)); ASSERT_EQ(0, GetHeadArrayQueue(queue)); } ","date":"2022-05-14","objectID":"/posts/ds-stack-queue/:2:2","tags":["Data Structure \u0026 Algorithm"],"title":"栈和队列","uri":"/posts/ds-stack-queue/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"循环顺序队列 实现代码： #include \"queue.h\" #include \u003cstdlib.h\u003e CircularArrayQueue *CreateCircularArrayQueue() { CircularArrayQueue *queue = (CircularArrayQueue *) malloc(sizeof(CircularArrayQueue)); if (queue == NULL) { return NULL; } queue-\u003ehead = queue-\u003etail = 0; queue-\u003edata[queue-\u003ehead] = 0; return queue; } bool EnCircularArrayQueue(CircularArrayQueue *queue, int value) { if (IsFullCircularArrayQueue(queue) || value \u003c= 0) { return false; } queue-\u003etail = (queue-\u003etail + 1) % MAX_QUEUE_SIZE; queue-\u003edata[queue-\u003etail] = value; return true; } bool DeCircularArrayQueue(CircularArrayQueue *queue) { if (IsEmptyCircularArrayQueue(queue)) { return false; } queue-\u003ehead = (queue-\u003ehead + 1) % MAX_QUEUE_SIZE; return true; } int GetHeadCircularArrayQueue(CircularArrayQueue *queue) { if (IsEmptyCircularArrayQueue(queue)) { return 0; } return queue-\u003edata[(queue-\u003ehead + 1) % MAX_QUEUE_SIZE]; } bool IsFullCircularArrayQueue(CircularArrayQueue *queue) { return (queue-\u003etail + 1) % MAX_QUEUE_SIZE == queue-\u003ehead; } bool IsEmptyCircularArrayQueue(CircularArrayQueue *queue) { return queue-\u003ehead == queue-\u003etail; } 测试代码： #include \u003cgtest/gtest.h\u003e extern \"C\" { #include \"../src/queue/queue.h\" } TEST(TestCircularArrayQueue, CreateCircularArrayQueue) { CircularArrayQueue *queue = CreateCircularArrayQueue(); ASSERT_EQ(0, queue-\u003ehead); ASSERT_EQ(0, queue-\u003etail); ASSERT_EQ(0, queue-\u003edata[queue-\u003ehead]); } TEST(TestCircularArrayQueue, EnCircularArrayQueue) { CircularArrayQueue *queue = CreateCircularArrayQueue(); ASSERT_TRUE(IsEmptyCircularArrayQueue(queue)); ASSERT_FALSE(DeCircularArrayQueue(queue)); ASSERT_FALSE(EnCircularArrayQueue(queue, 0)); for (int i = 1; i \u003c MAX_QUEUE_SIZE; i++) { ASSERT_TRUE(EnCircularArrayQueue(queue, i)); ASSERT_EQ(1, GetHeadCircularArrayQueue(queue)); } ASSERT_TRUE(IsFullCircularArrayQueue(queue)); ASSERT_FALSE(EnCircularArrayQueue(queue, MAX_QUEUE_SIZE)); ASSERT_EQ(1, GetHeadCircularArrayQueue(queue)); } TEST(TestCircularArrayQueue, DeCircularArrayQueue) { int i; CircularArrayQueue *queue = CreateCircularArrayQueue(); ASSERT_TRUE(IsEmptyCircularArrayQueue(queue)); for (i = 1; i \u003c MAX_QUEUE_SIZE; i++) { ASSERT_TRUE(EnCircularArrayQueue(queue, i)); } for (i = 1; i \u003c MAX_QUEUE_SIZE; i++) { ASSERT_FALSE(IsEmptyCircularArrayQueue(queue)); ASSERT_EQ(i, GetHeadCircularArrayQueue(queue)); ASSERT_TRUE(DeCircularArrayQueue(queue)); } ASSERT_TRUE(IsEmptyCircularArrayQueue(queue)); ASSERT_EQ(0, GetHeadCircularArrayQueue(queue)); ASSERT_FALSE(DeCircularArrayQueue(queue)); } ","date":"2022-05-14","objectID":"/posts/ds-stack-queue/:2:3","tags":["Data Structure \u0026 Algorithm"],"title":"栈和队列","uri":"/posts/ds-stack-queue/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"链式对列 实现代码： #include \"queue.h\" #include \u003cstdlib.h\u003e LinkedQueue *CreateLinkedQueue() { LinkedQueue *queue = (LinkedQueue *) malloc(sizeof(LinkedQueue)); if (queue == NULL) { return NULL; } LinkedQueueNode *node = (LinkedQueueNode *) malloc(sizeof(LinkedQueueNode)); if (node == NULL) { return NULL; } queue-\u003ehead = queue-\u003etail = node; return queue; } bool EnLinkedQueue(LinkedQueue *queue, int value) { if (queue == NULL || value \u003c= 0) { return false; } LinkedQueueNode *node; node = (LinkedQueueNode *) malloc(sizeof(LinkedQueueNode)); if (node == NULL) { return false; } node-\u003edata = value; node-\u003enext = NULL; queue-\u003etail-\u003enext = node; queue-\u003etail = node; return true; } bool DeLinkedQueue(LinkedQueue *queue) { if (IsEmptyLinkedQueue(queue)) { return false; } LinkedQueueNode *node = queue-\u003ehead-\u003enext; // 使 node 指向队列的首结点 queue-\u003ehead-\u003enext = node-\u003enext; // 修改头结点的指针域指向新的首结点 if (node-\u003enext == NULL) { queue-\u003etail = queue-\u003ehead; } free(node); return true; } int GetHeadLinkedQueue(LinkedQueue *queue) { if (IsEmptyLinkedQueue(queue)) { return 0; } LinkedQueueNode *node = queue-\u003ehead-\u003enext; return node-\u003edata; } bool IsEmptyLinkedQueue(LinkedQueue *queue) { return queue-\u003ehead == queue-\u003etail; } 测试代码： #include \u003cgtest/gtest.h\u003e extern \"C\" { #include \"../src/queue/queue.h\" } TEST(TestLinkedQueue, CreateLinkedQueue) { LinkedQueue *queue = CreateLinkedQueue(); ASSERT_EQ(NULL, queue-\u003ehead-\u003enext); ASSERT_EQ(NULL, queue-\u003etail-\u003enext); ASSERT_EQ(0, GetHeadLinkedQueue(queue)); ASSERT_TRUE(IsEmptyLinkedQueue(queue)); } TEST(TestLinkedQueue, EnLinkedQueue) { LinkedQueue *queue = CreateLinkedQueue(); ASSERT_FALSE(EnLinkedQueue(queue, 0)); ASSERT_TRUE(IsEmptyLinkedQueue(queue)); for (int i = 1; i \u003c= MAX_QUEUE_SIZE; i++) { ASSERT_TRUE(EnLinkedQueue(queue, i)); ASSERT_EQ(1, GetHeadLinkedQueue(queue)); } ASSERT_FALSE(IsEmptyLinkedQueue(queue)); ASSERT_EQ(1, GetHeadLinkedQueue(queue)); } TEST(TestLinkedQueue, DeLinkedQueue) { int i; LinkedQueue *queue = CreateLinkedQueue(); ASSERT_FALSE(DeLinkedQueue(queue)); for (i = 1; i \u003c= MAX_QUEUE_SIZE; i++) { ASSERT_TRUE(EnLinkedQueue(queue, i)); ASSERT_EQ(1, GetHeadLinkedQueue(queue)); } for (i = 1; i \u003c= MAX_QUEUE_SIZE; i++) { ASSERT_TRUE(DeLinkedQueue(queue)); } ASSERT_FALSE(DeLinkedQueue(queue)); ASSERT_TRUE(IsEmptyLinkedQueue(queue)); ASSERT_EQ(0, GetHeadLinkedQueue(queue)); } ","date":"2022-05-14","objectID":"/posts/ds-stack-queue/:2:4","tags":["Data Structure \u0026 Algorithm"],"title":"栈和队列","uri":"/posts/ds-stack-queue/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"循环链式队列 实现代码： #include \"queue.h\" #include \u003cstdlib.h\u003e CircularLinkedQueue *CreateCircularLinkedQueue(int cap) { if (cap \u003c= 0) { return NULL; } CircularLinkedQueue *queue = (CircularLinkedQueue *) malloc(sizeof(CircularLinkedQueue)); if (queue == NULL) { return NULL; } CircularLinkedQueueNode *p, *q; p = (CircularLinkedQueueNode *) malloc(sizeof(CircularLinkedQueueNode)); queue-\u003ehead = queue-\u003etail = p; queue-\u003elen = 0; queue-\u003ecap = cap; p-\u003enext = q = p; for (int i = 0; i \u003c cap; i++) { q-\u003enext = (CircularLinkedQueueNode *) malloc(sizeof(CircularLinkedQueueNode)); q = q-\u003enext; } q-\u003enext = p; // 首尾链接 return queue; } bool EnCircularLinkedQueue(CircularLinkedQueue *queue, int value) { if (IsFullCircularLinkedQueue(queue) || value \u003c= 0) { return false; } queue-\u003etail-\u003edata = value; queue-\u003etail = queue-\u003etail-\u003enext; queue-\u003elen++; return true; } bool DeCircularLinkedQueue(CircularLinkedQueue *queue) { if (IsEmptyCircularLinkedQueue(queue)) { return false; } queue-\u003ehead = queue-\u003ehead-\u003enext; queue-\u003elen--; return true; } int GetHeadCircularLinkedQueue(CircularLinkedQueue *queue) { if (IsEmptyCircularLinkedQueue(queue)) { return 0; } return queue-\u003ehead-\u003edata; } bool IsEmptyCircularLinkedQueue(CircularLinkedQueue *queue) { return queue-\u003elen == 0; } bool IsFullCircularLinkedQueue(CircularLinkedQueue *queue) { return queue-\u003elen == queue-\u003ecap; } 测试代码： #include \u003cgtest/gtest.h\u003e extern \"C\" { #include \"../src/queue/queue.h\" } TEST(TestCircularLinkedQueue, CreateCircularLinkedQueue) { CircularLinkedQueue *queue = CreateCircularLinkedQueue(MAX_QUEUE_SIZE); ASSERT_EQ(NULL, queue-\u003ehead-\u003enext-\u003edata); ASSERT_EQ(NULL, queue-\u003etail-\u003enext-\u003edata); ASSERT_EQ(0, GetHeadCircularLinkedQueue(queue)); } TEST(TestCircularLinkedQueue, EnCircularArrayQueue) { CircularLinkedQueue *queue = CreateCircularLinkedQueue(MAX_QUEUE_SIZE); ASSERT_FALSE(EnCircularLinkedQueue(queue, 0)); ASSERT_TRUE(IsEmptyCircularLinkedQueue(queue)); for (int i = 1; i \u003c= MAX_QUEUE_SIZE; i++) { ASSERT_TRUE(EnCircularLinkedQueue(queue, i)); ASSERT_EQ(1, GetHeadCircularLinkedQueue(queue)); } ASSERT_FALSE(IsEmptyCircularLinkedQueue(queue)); ASSERT_EQ(1, GetHeadCircularLinkedQueue(queue)); } TEST(TestCircularLinkedQueue, DeCircularArrayQueue) { int i; CircularLinkedQueue *queue = CreateCircularLinkedQueue(MAX_QUEUE_SIZE); ASSERT_FALSE(DeCircularLinkedQueue(queue)); for (i = 1; i \u003c= MAX_QUEUE_SIZE; i++) { ASSERT_TRUE(EnCircularLinkedQueue(queue, i)); ASSERT_EQ(1, GetHeadCircularLinkedQueue(queue)); } for (i = 1; i \u003c= MAX_QUEUE_SIZE; i++) { ASSERT_TRUE(DeCircularLinkedQueue(queue)); } ASSERT_FALSE(DeCircularLinkedQueue(queue)); ASSERT_TRUE(IsEmptyCircularLinkedQueue(queue)); ASSERT_EQ(0, GetHeadCircularLinkedQueue(queue)); } ","date":"2022-05-14","objectID":"/posts/ds-stack-queue/:2:5","tags":["Data Structure \u0026 Algorithm"],"title":"栈和队列","uri":"/posts/ds-stack-queue/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"数组 ","date":"2022-05-14","objectID":"/posts/ds-stack-queue/:3:0","tags":["Data Structure \u0026 Algorithm"],"title":"栈和队列","uri":"/posts/ds-stack-queue/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"数组的逻辑结构 数组可以看成线性表的一种推广。一维数组又称 向量，它由一组具有相同类型的数据元素组成，并存储在一组连续的存储单元中。若一维数组中的元素又是一个二维数组结构，则称为 二维数组，依次类推，逐渐升维。 一般地，一个 n 维数组可以看成元素为 n-1 维数组的线性表。 数组通常有两种基本运算： 读：给定一组下标，返回该位置的元素内容； 写：给定一组下标，修改该位置的元素内容； ","date":"2022-05-14","objectID":"/posts/ds-stack-queue/:3:1","tags":["Data Structure \u0026 Algorithm"],"title":"栈和队列","uri":"/posts/ds-stack-queue/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"数组的存储结构 一维数组元素的内存单元地址是连续的，二维数组可能有两种存储方法：一种是以 列序 为主的存储；另一种是以 行序 为主的存储。在类 C 语言的编译程序中，数组采用的是以 行序 为主序的存储方法。 数组元素的存储位置是 下标 的线性函数，假设二维数组 a[m][n]，如果每个元素占 k 个存储单元，则有： 行序位置：loc[i,j] = loc[0,0] + (n*i+j)*k； 列序位置：loc[i,j] = loc[0,0] + (m*j+i)*k； ","date":"2022-05-14","objectID":"/posts/ds-stack-queue/:3:2","tags":["Data Structure \u0026 Algorithm"],"title":"栈和队列","uri":"/posts/ds-stack-queue/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"矩阵的压缩存储 矩阵的压缩存储：在数值分析中经常出现一些高阶矩阵，这些高阶矩阵中有许多值相同的元素或零元素，为了节省存储空间，对这类矩阵采用多个值相同的元素只分配一个存储空间，零元素不存储的策略，称为矩阵的压缩存储。 特殊矩阵 如果值相同的元素或零元素在矩阵中的分布有一定规律，称此矩阵为 特殊矩阵。 对称矩阵 对称矩阵：若有一个 n 阶方阵 A 中的元素满足 aij= aji(0\u003c=i, j\u003c=n-1\u003e)，则称 A 为对称矩阵。 对称矩阵有近一半的元素可以通过其对称元素获得，为每一对对称元素只分配一个存储单元，则可将 n2 个元素压缩存储到 n(n+1)/2 个元素的一维数组中。 设矩阵元素 aij 在数组 M 中的位置为 k，(i, k) 和 k 存在如下对应关系： ⎧ i(i+1)/2+j (i\u003e=j) k = ⎨ ⎩ j(j+1)/2+i (i\u003cj) 三角矩阵 三角矩阵：以主对角线为界的上（下）半部分是一个固定的值 c 或零，这样的矩阵叫做下（上）三角矩阵。 上三角矩阵： 上三角矩阵中，M[k] 和 aij 的对应关系是： ⎧ i(2n-i+1)/2+j-i (i\u003c=j) k = ⎨ ⎩ n(n+1)/2 (i\u003ej) 下三角矩阵： 下三角矩阵中，M[k] 和 aij 的对应关系是： ⎧ i(i+1)/2+j (i\u003e=j) k = ⎨ ⎩ n(n+1)/2 (i\u003cj) 稀疏矩阵 假设 m 行 n 列的矩阵有 t 个非零元素，当 t\u003c=m*n 时，则称矩阵为 稀疏矩阵（Sparse Matrix），稀疏矩阵中非零元素的个数很少。 ","date":"2022-05-14","objectID":"/posts/ds-stack-queue/:3:3","tags":["Data Structure \u0026 Algorithm"],"title":"栈和队列","uri":"/posts/ds-stack-queue/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"习题 设一个链栈的输入序列为 A、B、C，试写出所有得到的可能输出序列，即输出出栈操作得到的数据元素序列。 共有 5 种可能的输出序列： ABC，A 进 A 出，B 进 B 出，C 进 C 出； BCA，A 进 B 进，B 出 C 进，C 出 A 出； BAC，A 进 B 进，B 出 A 出，C 进 C 出； CBA，A 进 B 进，C 进 C 出，B 出 A 出； ACB，A 进 A 出，B 进 C 进，C 出 B 出； 写出下列程序的运行结果。 #include \"stack.h\" #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main() { char ch; ArrayStack *stack = CreateArrayStack(); for (ch = 'A'; ch \u003c= 'A' + 10; ch++) { PushArrayStack(stack, ch); printf(\"%c\", ch); } printf(\"\\n\"); while (!IsEmptyArrayStack(stack)) { ch = GetTopArrayStack(stack); PopArrayStack(stack); printf(\"%c\", ch); } printf(\"\\n\"); } ABCDEFGHIJK KJIHGFEDCBA 设有二维数组 int M[10][20]，每个元素（整数）占 2 个存储单元，数组的起始地址为 2000，求元素 M[5][10] 的存储位置，M[8][19] 的存储位置。 M[5][10] = 2000+(20*5+10)*2 = 2220 M[8][19] = 2000+(20*8+19)*2 = 2358 使用一个元素个数为 100 的数组存储循环队列，如果采取少用一个元素空间的方法来区别循环队列的队列空和队列满，约定队列首指针 front 等于队列尾指针 rear 时表示队列为空。若 front=8, rear=7 时，求队列中的元素个数。 队列中的元素个数 = (7-8+100)%100 = 99 ","date":"2022-05-14","objectID":"/posts/ds-stack-queue/:4:0","tags":["Data Structure \u0026 Algorithm"],"title":"栈和队列","uri":"/posts/ds-stack-queue/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"线性表是最基本、最简单、也是最常用的一种数据结构。线性表（linear list）是数据结构的一种，一个线性表是 n 个具有相同特性的数据元素的有限序列。 数据结构与算法起步 线性表 栈和队列 ","date":"2022-05-04","objectID":"/posts/ds-linear-list/:0:0","tags":["Data Structure \u0026 Algorithm"],"title":"线性表","uri":"/posts/ds-linear-list/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"基本概念 ","date":"2022-05-04","objectID":"/posts/ds-linear-list/:1:0","tags":["Data Structure \u0026 Algorithm"],"title":"线性表","uri":"/posts/ds-linear-list/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"定义 线性表（Linear List）：是一种线性结构，它是由 n(n\u003e=0) 个数据元素组成的有穷序列，数据元素又称结点。结点个数 n 称为表长。 当 n=0 时，线性表不含任何数据元素，称为空表，记为 () 或 ø； 当 n\u003e0 时，线性表通常表示成 (a1, a2, …, an)，a1 称为起始结点，an 称为终端结点。对任意一对相邻结点 ai 和 ai+1 (1\u003c=i\u003cn)，ai 称为 ai+1 的直接前驱，ai+1 称为 ai 的直接后继； ","date":"2022-05-04","objectID":"/posts/ds-linear-list/:1:1","tags":["Data Structure \u0026 Algorithm"],"title":"线性表","uri":"/posts/ds-linear-list/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"基本特征 线性表基本特征：线性表中结点具有一对一的关系，如果结点数不为零，则除起始结点没有直接前驱外，其它每个结点有且仅有一个直接前驱；除终点结点没有直接后继外，其它每个结点有且仅有一个直接后继。 ","date":"2022-05-04","objectID":"/posts/ds-linear-list/:1:2","tags":["Data Structure \u0026 Algorithm"],"title":"线性表","uri":"/posts/ds-linear-list/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"线性表的顺序存储 ","date":"2022-05-04","objectID":"/posts/ds-linear-list/:2:0","tags":["Data Structure \u0026 Algorithm"],"title":"线性表","uri":"/posts/ds-linear-list/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"顺序表 顺序表：线性表的顺序存储是指在内存中用地址连续的一块存储空间顺序存放线性表中的各数据元素，用这种存储形式存储的线性表称为顺序表。 设 a1 的存储地址为 Loc(a1)，每个数据元素占 d 个存储单元，则第 i 个数据元素的地址为：Loc(ai)=Loc(a1)+(i-1)*d (1≤i≤n)。 ","date":"2022-05-04","objectID":"/posts/ds-linear-list/:2:1","tags":["Data Structure \u0026 Algorithm"],"title":"线性表","uri":"/posts/ds-linear-list/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"顺序表的基本操作 创建空表：SeqList *CreateSeqList();； 插入元素：int InsertSeqList(SeqList *list, int pos, int value);； 删除元素：int DeleteSeqList(SeqList *list, int pos);； 更新元素：int UpdateSeqList(SeqList *list, int pos, int value);； 查找元素：int SearchSeqList(SeqList *list, int pos);； 定位元素：int LocateSeqList(SeqList *list, int value);； 求表长度：int GetSeqListLength(SeqList *list);； 合并有序表：void MergeSeqList(SeqList p, SeqList q, SeqList *t)； #include \u003cgtest/gtest.h\u003e #include \u003cstdbool.h\u003e #include \u003cstdlib.h\u003e const int MaxSize = 100; typedef struct { int data[MaxSize]; // 存放数据的数组 int length; // 顺序表的实际长度 } SeqList; // 顺序表类型名为 SeqList SeqList *CreateSeqList(); bool InsertSeqList(SeqList *list, int pos, int value); bool DeleteSeqList(SeqList *list, int pos); bool UpdateSeqList(SeqList *list, int pos, int value); int SearchSeqList(SeqList *list, int pos); int LocateSeqList(SeqList *list, int value); int GetSeqListLength(SeqList *list); SeqList *CreateSeqList() { SeqList *list = (SeqList *)malloc(sizeof(SeqList)); list-\u003elength = 0; return list; } bool InsertSeqList(SeqList *list, int pos, int value) { if (list-\u003elength \u003e= MaxSize) { return false; } if (pos \u003c 1 || pos \u003e list-\u003elength + 1) { return false; } for (int i = list-\u003elength; i \u003e= pos; i--) { list-\u003edata[i] = list-\u003edata[i - 1]; } list-\u003edata[pos - 1] = value; list-\u003elength++; return true; } bool DeleteSeqList(SeqList *list, int pos) { if (list-\u003elength == 0) { return false; } if (pos \u003c 1 || pos \u003e list-\u003elength) { return false; } for (int i = pos - 1; i \u003c list-\u003elength - 1; i++) { list-\u003edata[i] = list-\u003edata[i + 1]; } list-\u003elength--; return true; } bool UpdateSeqList(SeqList *list, int pos, int value) { if (list-\u003elength == 0) { return false; } if (pos \u003c 1 || pos \u003e list-\u003elength) { return false; } list-\u003edata[pos - 1] = value; return true; } int SearchSeqList(SeqList *list, int pos) { if (list-\u003elength == 0) { return 0; } if (pos \u003c 1 || pos \u003e list-\u003elength) { return 0; } return list-\u003edata[pos - 1]; } int LocateSeqList(SeqList *list, int value) { if (list-\u003elength == 0) { return 0; } for (int i = 0; i \u003c list-\u003elength; i++) { if (list-\u003edata[i] == value) { return i + 1; } } return 0; } int GetSeqListLength(SeqList *list) { return list-\u003elength; } void MergeSeqList(SeqList p, SeqList q, SeqList *t) { int i = 0, j = 0, k = 0; while (i \u003c p.length \u0026\u0026 j \u003c q.length) { if (p.data[i] \u003c q.data[j]) { t-\u003edata[k++] = p.data[i++]; } else { t-\u003edata[k++] = q.data[j++]; } } while (i \u003c p.length) { t-\u003edata[k++] = p.data[i++]; } while (j \u003c q.length) { t-\u003edata[k++] = q.data[j++]; } t-\u003elength = k; } TEST(TestSeqList, CreateSeqList) { SeqList *list = CreateSeqList(); ASSERT_EQ(0, GetSeqListLength(list)); ASSERT_EQ(0, list-\u003edata[list-\u003elength]); } TEST(TestSeqList, InsertSeqList) { SeqList *list = CreateSeqList(); ASSERT_TRUE(InsertSeqList(list, 1, 1)); ASSERT_EQ(1, GetSeqListLength(list)); ASSERT_TRUE(InsertSeqList(list, 2, 2)); ASSERT_EQ(2, GetSeqListLength(list)); ASSERT_TRUE(InsertSeqList(list, 3, 3)); ASSERT_EQ(3, GetSeqListLength(list)); ASSERT_TRUE(InsertSeqList(list, 4, 4)); ASSERT_FALSE(InsertSeqList(list, -1, 1 - MaxSize)); ASSERT_FALSE(InsertSeqList(list, MaxSize + 1, MaxSize + 1)); ASSERT_TRUE(InsertSeqList(list, 4, 44)); list-\u003elength = 100; ASSERT_FALSE(InsertSeqList(list, 100, 100)); } TEST(TestSeqList, DeleteSeqList) { SeqList *list = CreateSeqList(); ASSERT_FALSE(DeleteSeqList(list, 0)); ASSERT_FALSE(DeleteSeqList(list, 1 - MaxSize)); ASSERT_FALSE(DeleteSeqList(list, MaxSize + 1)); InsertSeqList(list, 1, 1); InsertSeqList(list, 2, 2); InsertSeqList(list, 3, 3); InsertSeqList(list, 4, 4); InsertSeqList(list, 5, 5); ASSERT_TRUE(DeleteSeqList(list, 1)); ASSERT_EQ(4, GetSeqListLength(list)); ASSERT_TRUE(DeleteSeqList(list, 2)); ASSERT_EQ(3, GetSeqListLength(list)); ASSERT_FALSE(DeleteSeqList(list, 0)); ASSERT_TRUE(DeleteSeqList(list, 1)); ASSERT_TRUE(DeleteSeqList(list, 2)); } TEST(TestSeqList, UpdateSeqList) { SeqList *list = CreateSeqList(); ASSERT_FALSE(UpdateSeqList(list, 1, 1)); InsertSeqList(list, 1, 1); ASSERT_TRUE(UpdateSeqList(list, 1,","date":"2022-05-04","objectID":"/posts/ds-linear-list/:2:2","tags":["Data Structure \u0026 Algorithm"],"title":"线性表","uri":"/posts/ds-linear-list/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"顺序表实现算法的分析 建表算法：时间复杂度为 O(n)； 插入算法：最坏情况下，时间复杂度为 O(n)，比较和移动的次数为 n-i+1；平均移动次数为 n/2，时间复杂度为 O(n)； 删除算法：最坏情况下，时间复杂度为 O(n)，比较和移动的次数为 n-1；平均移动次数为 (n-1)/2，时间复杂度为 O(n)； 更新算法：最坏情况下，时间复杂度为 O(n)； 查找算法：按序号查找元素，平均时间复杂度为 O(n)，求表长和读表元素算法的时间复杂度为 O(1)； 定位算法：按域值查找元素，时间复杂度为 O(1)； 合并有序表：算法的时间复杂度是 O(m+n)，其中 m 是 A 的表长，n 是 B 的表长； ","date":"2022-05-04","objectID":"/posts/ds-linear-list/:2:3","tags":["Data Structure \u0026 Algorithm"],"title":"线性表","uri":"/posts/ds-linear-list/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"线性表的链接存储 为了方便操作，有时在链表的头部加入一个「头结点」，头结点的类型与数据结点一致，标识链表的头指针变量 head 中存放该结点的地址，这样即使是空表，头指针变量 head 也不为空了。头结点的加入使得「第一个结点」的问题不再存在，也使得「空表」和「非空表」的处理一致。头结点的加入完全是为了操作的方便，它的数据域无定义，指针域中存放的是第一个数据结点的地址，当空表时该指针域为空。 ","date":"2022-05-04","objectID":"/posts/ds-linear-list/:3:0","tags":["Data Structure \u0026 Algorithm"],"title":"线性表","uri":"/posts/ds-linear-list/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"单链表 单链表：就是线性表的数据元素用指针链接起来的存储结构，指针表示数据元素之间的逻辑关系。 线性表的链接存储是指它的存储结构是链式的，常见的链式存储结构有 单链表、循环链表 和 双向循环链表。 单链表中的 data 部分称为 数据域，用于存储线性表的一个数据元素，next 部分称为 指针或链域，用于存放一个指针，该指针指向本结点所含数据元素的直接后继结点。 所有结点通过指针链接形成 链表（Link List），head 称为头指针变量，该变量的值是指向单链表的第一个结点的指针。尾结点指针域的值 NULL 称为空指针，它不指向任何结点，表示链表结束。如果 head 等于 NULL，则表示该链表无任何结点，是空单链表。 单链表的第一个结点之前增设一个类型相同的结点，称之为 头结点，其它结点称为 表结点。表结点中的第一个和最后一个结点分别就是首结点和尾结点。 单链表基本操作： 创建空表：LinkedList CreateLinkedList();； 插入元素：void InsertLinkedList(LinkedList head, int pos, int value);； 删除元素：void DeleteLinkedList(LinkedList head, int value);； 更新元素：void UpdateLinkedList(LinkedList head, int pos, int value);； 查找元素：Node *SearchLinkedList(LinkedList head, int pos);； 定位元素：int LocateLinkedList(LinkedList head, int value);； 求表长度：int GetLinkedListLength(LinkedList head);； 单链表算法分析： 建表算法：时间复杂度为 O(n)； 插入算法：时间复杂度为 O(n)； 删除算法：时间复杂度为 O(n)； 查找算法：按序号查找元素，时间复杂度为 O(n)，求表长和读表元素算法的时间复杂度为 O(n)； 定位算法：按域值查找元素，时间复杂度为 O(n)； #include \u003cgtest/gtest.h\u003e #include \u003cstdbool.h\u003e #include \u003cstdlib.h\u003e typedef struct node { int data; // 数据域 struct node *next; // 指针域 } Node, *SinglyLinkedList; SinglyLinkedList CreateSinglyLinkedList(); bool InsertSinglyLinkedList(SinglyLinkedList head, int pos, int value); bool DeleteSinglyLinkedList(SinglyLinkedList head, int pos); bool UpdateSinglyLinkedList(SinglyLinkedList head, int pos, int value); Node *SearchSinglyLinkedList(SinglyLinkedList head, int pos); int LocateSinglyLinkedList(SinglyLinkedList head, int value); int GetSinglyLinkedListLength(SinglyLinkedList head); SinglyLinkedList MergeSinglyLinkedList(SinglyLinkedList a, SinglyLinkedList b); SinglyLinkedList CreateSinglyLinkedList() { SinglyLinkedList head = (SinglyLinkedList)malloc(sizeof(Node)); if (head == NULL) { return NULL; } head-\u003enext = NULL; return head; } bool InsertSinglyLinkedList(SinglyLinkedList head, int pos, int value) { Node *p, *q; p = (Node *)malloc(sizeof(Node)); if (p == NULL) { return false; } p-\u003edata = value; q = pos == 1 ? head : SearchSinglyLinkedList(head, pos - 1); if (q == NULL) { return false; } p-\u003enext = q-\u003enext; q-\u003enext = p; return true; } bool DeleteSinglyLinkedList(SinglyLinkedList head, int pos) { if (head == NULL) { return false; } Node *p, *q; q = pos == 1 ? head : SearchSinglyLinkedList(head, pos - 1); if (q == NULL || q-\u003enext == NULL) { return false; } p = q-\u003enext; q-\u003enext = p-\u003enext; free(p); return true; } bool UpdateSinglyLinkedList(SinglyLinkedList head, int pos, int value) { if (head == NULL) { return false; } Node *node; node = pos == 1 ? head : SearchSinglyLinkedList(head, pos - 1); if (node == NULL || node-\u003enext == NULL) { return false; } node-\u003enext-\u003edata = value; return true; } Node *SearchSinglyLinkedList(SinglyLinkedList head, int pos) { int i = 1; if (head == NULL || pos \u003c i) { return NULL; } Node *p = head-\u003enext; while (p != NULL \u0026\u0026 i \u003c pos) { p = p-\u003enext; i++; } return i == pos ? p : NULL; } int LocateSinglyLinkedList(SinglyLinkedList head, int value) { if (head == NULL) { return 0; } int i = 0; Node *p = head-\u003enext; while (p != NULL \u0026\u0026 p-\u003edata != value) { p = p-\u003enext; i++; } return i; } int GetSinglyLinkedListLength(SinglyLinkedList head) { if (head == NULL) { return 0; } int cnt = 0; SinglyLinkedList p = head-\u003enext; while (p != NULL) { p = p-\u003enext; cnt++; } return cnt; } SinglyLinkedList MergeSinglyLinkedList(SinglyLinkedList a, SinglyLinkedList b) { if (a == NULL) { return b; } else if (b == NULL) { return a; } SinglyLinkedList head, tail; Node *p, *q, *t; p = a; q = b; head = p-\u003edata \u003c= q-\u003edata ? a : b; tail = head; p = p-\u003enext; q = q-\u003enext; while (p \u0026\u0026 q) { if (p-\u003edata \u003c= q-\u003edata) { t = p; p = p-\u003enext; } else { t = q; q = q-\u003enext; } tail-\u003enext = t; tail = t; } if (p) { tail-\u003enext = p; } else if (q) { tail-\u003enext = q; } return head; } TEST(TestSinglyLinkedList, CreateSinglyLinkedList) { SinglyLinkedList head = CreateSinglyLinkedList(); EXPECT_FALSE(head == NULL); EXPECT_EQ(NULL, head-\u003enext); EXPECT_EQ(0, GetSinglyLinkedListLength(head)); } TEST(TestSinglyLinkedList, InsertSinglyLinkedList) { SinglyLinkedList he","date":"2022-05-04","objectID":"/posts/ds-linear-list/:3:1","tags":["Data Structure \u0026 Algorithm"],"title":"线性表","uri":"/posts/ds-linear-list/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"单向循环链表 #include \u003cgtest/gtest.h\u003e #include \u003cstdbool.h\u003e #include \u003cstdlib.h\u003e typedef struct node { int data; struct node *next; } Node, *SCLinkedList; SCLinkedList CreateSCLinkedList(); bool InsertSCLinkedList(SCLinkedList head, int pos, int value); bool DeleteSCLinkedList(SCLinkedList head, int pos); bool UpdateSCLinkedList(SCLinkedList head, int pos, int value); Node *SearchSCLinkedList(SCLinkedList head, int pos); int LocateSCLinkedList(SCLinkedList head, int value); int GetSCLinkedListLength(SCLinkedList head); SCLinkedList CreateSCLinkedList() { Node *head = (Node *)malloc(sizeof(Node)); if (head == NULL) { return NULL; } head-\u003enext = NULL; return head; } bool InsertSCLinkedList(SCLinkedList head, int pos, int value) { Node *p, *q; p = (Node *)malloc(sizeof(Node)); if (p == NULL) { return false; } p-\u003edata = value; q = pos == 1 ? head : SearchSCLinkedList(head, pos - 1); if (q == NULL) { return false; } p-\u003enext = q-\u003enext; q-\u003enext = p; return true; } bool DeleteSCLinkedList(SCLinkedList head, int pos) { if (head == NULL) { return false; } Node *p, *q; p = (Node *)malloc(sizeof(Node)); if (p == NULL) { return false; } q = pos == 1 ? head : SearchSCLinkedList(head, pos - 1); if (q == NULL || q-\u003enext == NULL) { return false; } p = q-\u003enext; q-\u003enext = p-\u003enext; free(p); return true; } bool UpdateSCLinkedList(SCLinkedList head, int pos, int value) { if (head == NULL) { return false; } Node *node; node = pos == 1 ? head : SearchSCLinkedList(head, pos - 1); if (node == NULL) { return false; } node-\u003enext-\u003edata = value; return true; } Node *SearchSCLinkedList(SCLinkedList head, int pos) { int i = 1; if (head == NULL || pos \u003c i) { return NULL; } Node *p, *q; p = head-\u003enext; q = head; while (p != NULL \u0026\u0026 p != q \u0026\u0026 i \u003c pos) { p = p-\u003enext; i++; } return i == pos ? p : NULL; } int LocateSCLinkedList(SCLinkedList head, int value) { if (head == NULL) { return 0; } int i = 0; Node *p = head-\u003enext; while (p != NULL \u0026\u0026 p != head \u0026\u0026 p-\u003edata != value) { p = p-\u003enext; i++; } return i; } int GetSCLinkedListLength(SCLinkedList head) { if (head == NULL) { return 0; } int cnt = 0; Node *p = head-\u003enext; while (p != NULL \u0026\u0026 p != head) { p = p-\u003enext; cnt++; } return cnt; } TEST(TestSCLinkedList, CreateSCLinkedList) { SCLinkedList head = CreateSCLinkedList(); EXPECT_FALSE(head == NULL); EXPECT_EQ(NULL, head-\u003enext); EXPECT_EQ(0, GetSCLinkedListLength(head)); } TEST(TestSCLinkedList, InsertSCLinkedList) { SCLinkedList head = CreateSCLinkedList(); EXPECT_EQ(0, GetSCLinkedListLength(head)); EXPECT_TRUE(InsertSCLinkedList(head, 1, 1)); EXPECT_EQ(1, GetSCLinkedListLength(head)); EXPECT_TRUE(InsertSCLinkedList(head, 2, 2)); EXPECT_EQ(2, GetSCLinkedListLength(head)); EXPECT_TRUE(InsertSCLinkedList(head, 3, 3)); EXPECT_EQ(3, GetSCLinkedListLength(head)); } TEST(TestSCLinkedList, DeleteSCLinkedList) { SCLinkedList p = CreateSCLinkedList(); InsertSCLinkedList(p, 1, 1); InsertSCLinkedList(p, 2, 2); InsertSCLinkedList(p, 3, 3); EXPECT_EQ(3, GetSCLinkedListLength(p)); EXPECT_TRUE(DeleteSCLinkedList(p, 3)); EXPECT_EQ(2, GetSCLinkedListLength(p)); EXPECT_TRUE(DeleteSCLinkedList(p, 2)); EXPECT_EQ(1, GetSCLinkedListLength(p)); EXPECT_TRUE(DeleteSCLinkedList(p, 1)); EXPECT_EQ(0, GetSCLinkedListLength(p)); SCLinkedList q = CreateSCLinkedList(); InsertSCLinkedList(q, 1, 1); InsertSCLinkedList(q, 2, 2); InsertSCLinkedList(q, 3, 3); EXPECT_TRUE(DeleteSCLinkedList(q, 2)); EXPECT_EQ(2, GetSCLinkedListLength(q)); EXPECT_TRUE(DeleteSCLinkedList(q, 1)); EXPECT_EQ(1, GetSCLinkedListLength(q)); EXPECT_FALSE(DeleteSCLinkedList(q, 3)); EXPECT_EQ(1, GetSCLinkedListLength(q)); EXPECT_TRUE(DeleteSCLinkedList(q, 1)); EXPECT_EQ(0, GetSCLinkedListLength(q)); EXPECT_EQ(NULL, q-\u003enext); SCLinkedList t = NULL; EXPECT_FALSE(DeleteSCLinkedList(t, 1)); SCLinkedList r = CreateSCLinkedList(); InsertSCLinkedList(r, 1, 11); EXPECT_TRUE(DeleteSCLinkedList(r, 1)); EXPECT_EQ(NULL, r-\u003enext); } TEST(TestSCLinkedList, UpdateSCLinkedList) { SCLinkedList p = CreateSCLinkedList(); InsertSCLinkedList(p, 1, 1); EXPECT_","date":"2022-05-04","objectID":"/posts/ds-linear-list/:3:2","tags":["Data Structure \u0026 Algorithm"],"title":"线性表","uri":"/posts/ds-linear-list/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"双链表 #include \u003cgtest/gtest.h\u003e #include \u003cstdlib.h\u003e typedef struct node { int data; struct node *prev; // 前驱结点 struct node *next; // 后驱结点 } Node, *DoublyLinkedList; DoublyLinkedList CreateDoublyLinkedList(); bool InsertDoublyLinkedList(DoublyLinkedList head, int pos, int value); bool DeleteDoublyLinkedList(DoublyLinkedList head, int pos); bool UpdateDoublyLinkedList(DoublyLinkedList head, int pos, int value); Node *SearchDoublyLinkedList(DoublyLinkedList head, int pos); int LocateDoublyLinkedList(DoublyLinkedList head, int value); int GetDoublyLinkedListLength(DoublyLinkedList head); DoublyLinkedList CreateDoublyLinkedList() { DoublyLinkedList head = (DoublyLinkedList)malloc(sizeof(Node)); if (head == NULL) { return NULL; } head-\u003eprev = head-\u003enext = NULL; return head; } bool InsertDoublyLinkedList(DoublyLinkedList head, int pos, int value) { Node *p, *q; p = (Node *)malloc(sizeof(Node)); p-\u003edata = value; p-\u003eprev = p-\u003enext = NULL; q = pos == 1 ? head : SearchDoublyLinkedList(head, pos - 1); if (q == NULL) { return false; } p-\u003eprev = q; p-\u003enext = q-\u003enext; if (q-\u003enext != NULL) { q-\u003enext-\u003eprev = p; } q-\u003enext = p; return true; } bool DeleteDoublyLinkedList(DoublyLinkedList head, int pos) { if (head == NULL) { return false; } Node *p, *q; q = pos == 1 ? head : SearchDoublyLinkedList(head, pos - 1); if (q == NULL || q-\u003enext == NULL) { return false; } p = q-\u003enext; if (p-\u003eprev != NULL) { p-\u003eprev-\u003enext = p-\u003enext; } if (p-\u003enext != NULL) { p-\u003enext-\u003eprev = p-\u003eprev; } free(p); return true; } bool UpdateDoublyLinkedList(DoublyLinkedList head, int pos, int value) { if (head == NULL) { return false; } Node *p; p = pos == 1 ? head : SearchDoublyLinkedList(head, pos - 1); if (p == NULL || p-\u003enext == NULL) { return false; } if (p-\u003enext != NULL) { p-\u003enext-\u003edata = value; } return true; } int LocateDoublyLinkedList(DoublyLinkedList head, int value) { if (head == NULL) { return 0; } int i = 0; Node *p = head-\u003enext; while (p != NULL \u0026\u0026 p-\u003edata != value) { p = p-\u003enext; i++; } return i; } Node *SearchDoublyLinkedList(DoublyLinkedList head, int pos) { int i = 1; if (head == NULL || pos \u003c i) { return NULL; } Node *p = head-\u003enext; while (p != NULL \u0026\u0026 p != head \u0026\u0026 i \u003c pos) { p = p-\u003enext; i++; } return i == pos ? p : NULL; } int GetDoublyLinkedListLength(DoublyLinkedList head) { if (head == NULL) { return 0; } int cnt = 0; DoublyLinkedList p = head-\u003enext; while (p != NULL \u0026\u0026 p != head) { p = p-\u003enext; cnt++; } return cnt; } TEST(TestDoublyLinkedList, CreateDLinkedList) { DoublyLinkedList head = CreateDoublyLinkedList(); EXPECT_EQ(NULL, head-\u003eprev); EXPECT_EQ(NULL, head-\u003enext); EXPECT_EQ(0, GetDoublyLinkedListLength(head)); } TEST(TestDoublyLinkedList, InsertDLinkedList) { DoublyLinkedList p = CreateDoublyLinkedList(); EXPECT_TRUE(InsertDoublyLinkedList(p, 1, 1)); EXPECT_EQ(1, GetDoublyLinkedListLength(p)); EXPECT_TRUE(InsertDoublyLinkedList(p, 2, 2)); EXPECT_EQ(2, GetDoublyLinkedListLength(p)); EXPECT_TRUE(InsertDoublyLinkedList(p, 3, 3)); EXPECT_EQ(3, GetDoublyLinkedListLength(p)); DoublyLinkedList q = CreateDoublyLinkedList(); EXPECT_TRUE(InsertDoublyLinkedList(q, 1, 11)); EXPECT_TRUE(InsertDoublyLinkedList(q, 2, 22)); EXPECT_TRUE(InsertDoublyLinkedList(q, 3, 33)); EXPECT_TRUE(InsertDoublyLinkedList(q, 3, 30)); EXPECT_EQ(4, GetDoublyLinkedListLength(q)); EXPECT_EQ(30, SearchDoublyLinkedList(q, 3)-\u003edata); } TEST(TestDoublyLinkedList, DeleteDoublyLinkedList) { DoublyLinkedList p = CreateDoublyLinkedList(); InsertDoublyLinkedList(p, 1, 1); InsertDoublyLinkedList(p, 2, 2); InsertDoublyLinkedList(p, 3, 3); EXPECT_EQ(3, GetDoublyLinkedListLength(p)); EXPECT_TRUE(DeleteDoublyLinkedList(p, 3)); EXPECT_EQ(2, GetDoublyLinkedListLength(p)); EXPECT_TRUE(DeleteDoublyLinkedList(p, 2)); EXPECT_EQ(1, GetDoublyLinkedListLength(p)); EXPECT_TRUE(DeleteDoublyLinkedList(p, 1)); EXPECT_EQ(0, GetDoublyLinkedListLength(p)); EXPECT_FALSE(DeleteDoublyLinkedList(p, 4)); EXPECT_EQ(NULL, p-\u003enext); InsertDoublyLinkedList(p, 1, 11); InsertDoublyLinkedList(p, 2, 22); InsertDoublyLinkedList(p","date":"2022-05-04","objectID":"/posts/ds-linear-list/:3:3","tags":["Data Structure \u0026 Algorithm"],"title":"线性表","uri":"/posts/ds-linear-list/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"双向循环链表 #include \u003cgtest/gtest.h\u003e #include \u003cstdbool.h\u003e #include \u003cstdlib.h\u003e typedef struct node { int data; struct node *prev; struct node *next; } Node, *DCLinkedList; DCLinkedList CreateDCLinkedList(); bool InsertDCLinkedList(DCLinkedList head, int pos, int value); bool DeleteDCLinkedList(DCLinkedList head, int pos); bool UpdateDCLinkedList(DCLinkedList head, int pos, int value); Node *SearchDCLinkedList(DCLinkedList head, int pos); int LocateDCLinkedList(DCLinkedList head, int value); int GetDCLinkedListLength(DCLinkedList head); DCLinkedList CreateDCLinkedList() { DCLinkedList head = (DCLinkedList)malloc(sizeof(DCLinkedList)); if (head == NULL) { return NULL; } head-\u003eprev = head-\u003enext = NULL; return head; } bool InsertDCLinkedList(DCLinkedList head, int pos, int value) { Node *p, *q; p = (Node *)malloc(sizeof(Node)); if (p == NULL) { return false; } p-\u003edata = value; p-\u003eprev = p-\u003enext = p; q = pos == 1 ? head : SearchDCLinkedList(head, pos - 1); if (q == NULL) { return false; } p-\u003eprev = q; p-\u003enext = q-\u003enext; if (q-\u003enext != NULL) { q-\u003enext-\u003eprev = p; } q-\u003enext = p; return true; } bool DeleteDCLinkedList(DCLinkedList head, int pos) { if (head == NULL) { return false; } Node *p, *q; q = pos == 1 ? head : SearchDCLinkedList(head, pos - 1); if (q == NULL || q-\u003enext == NULL) { return false; } p = q-\u003enext; if (p-\u003eprev != NULL) { p-\u003eprev-\u003enext = p-\u003enext; // p 前驱结点的后继结点指向 p 的后继结点 } if (p-\u003enext != NULL) { p-\u003enext-\u003eprev = p-\u003eprev; // p 后继结点的前驱结点指向 p 的前驱结点 } free(p); return true; } bool UpdateDCLinkedList(DCLinkedList head, int pos, int value) { if (head == NULL) { return false; } Node *p; p = pos == 1 ? head : SearchDCLinkedList(head, pos - 1); if (p == NULL || p-\u003enext == NULL) { return false; } p-\u003enext-\u003edata = value; return true; } Node *SearchDCLinkedList(DCLinkedList head, int pos) { int i = 1; if (head == NULL || pos \u003c i) { return NULL; } Node *p = head-\u003enext; while (p != NULL \u0026\u0026 p != head \u0026\u0026 i \u003c pos) { p = p-\u003enext; i++; } return i == pos ? p : NULL; } int LocateDCLinkedList(DCLinkedList head, int value) { if (head == NULL) { return 0; } DCLinkedList p = head-\u003enext; int i = 0; while (p != NULL \u0026\u0026 p != head \u0026\u0026 p-\u003edata != value) { p = p-\u003enext; i++; } return i; } int GetDCLinkedListLength(DCLinkedList head) { if (head == NULL) { return 0; } int cnt = 0; DCLinkedList p = head-\u003enext; while (p != NULL \u0026\u0026 p != head) { p = p-\u003enext; cnt++; } return cnt; } TEST(TestDCLinkedList, CreateDCLiedList) { DCLinkedList head = CreateDCLinkedList(); EXPECT_EQ(NULL, head-\u003eprev); EXPECT_EQ(NULL, head-\u003enext); EXPECT_EQ(0, GetDCLinkedListLength(head)); } TEST(TestDCLinkedList, InsertDCLinkedList) { DCLinkedList head = CreateDCLinkedList(); EXPECT_TRUE(InsertDCLinkedList(head, 1, 1)); EXPECT_EQ(1, GetDCLinkedListLength(head)); EXPECT_TRUE(InsertDCLinkedList(head, 2, 2)); EXPECT_EQ(2, GetDCLinkedListLength(head)); EXPECT_TRUE(InsertDCLinkedList(head, 3, 3)); EXPECT_EQ(3, GetDCLinkedListLength(head)); } TEST(TestDCLinkedList, DeleteDCLinkedList) { DCLinkedList p = CreateDCLinkedList(); EXPECT_TRUE(InsertDCLinkedList(p, 1, 1)); EXPECT_TRUE(InsertDCLinkedList(p, 2, 2)); EXPECT_TRUE(InsertDCLinkedList(p, 3, 3)); EXPECT_EQ(3, GetDCLinkedListLength(p)); EXPECT_TRUE(DeleteDCLinkedList(p, 3)); EXPECT_EQ(2, GetDCLinkedListLength(p)); EXPECT_TRUE(DeleteDCLinkedList(p, 2)); EXPECT_EQ(1, GetDCLinkedListLength(p)); EXPECT_TRUE(DeleteDCLinkedList(p, 1)); EXPECT_EQ(0, GetDCLinkedListLength(p)); EXPECT_FALSE(DeleteDCLinkedList(p, 4)); EXPECT_EQ(NULL, p-\u003enext); InsertDCLinkedList(p, 1, 11); InsertDCLinkedList(p, 2, 22); InsertDCLinkedList(p, 3, 33); EXPECT_TRUE(DeleteDCLinkedList(p, 2)); EXPECT_EQ(2, GetDCLinkedListLength(p)); DCLinkedList q = NULL; EXPECT_EQ(NULL, DeleteDCLinkedList(q, 1)); } TEST(TestDCLinkedList, UpdateDCLinkedList) { DCLinkedList head = CreateDCLinkedList(); InsertDCLinkedList(head, 1, 1); InsertDCLinkedList(head, 2, 2); InsertDCLinkedList(head, 3, 3); EXPECT_TRUE(UpdateDCLinkedList(head, 1, 11)); EXPECT_EQ(11, SearchDCLinkedList(head, 1)-\u003edata); EXPECT_","date":"2022-05-04","objectID":"/posts/ds-linear-list/:3:4","tags":["Data Structure \u0026 Algorithm"],"title":"线性表","uri":"/posts/ds-linear-list/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"其它运算在单链表上的实现 ","date":"2022-05-04","objectID":"/posts/ds-linear-list/:4:0","tags":["Data Structure \u0026 Algorithm"],"title":"线性表","uri":"/posts/ds-linear-list/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"建表 通过已实现的插入算法 InsertLinkedList(LinkedList head, int i, int x) 来实现，依次增大插入位置 i，使新的结点链入到链表中： LinkedList CreateLinkedList1() { LinkedList head = CreateLinkedList(); int x; int i = 1; scanf(\"%d\", \u0026x); while (x != 0) { InsertLinkedList(head, i, x); i++; scanf(\"%d\", \u0026x); } return head; } int main() { LinkedList head = CreateLinkedList1(); LinkedList p = head-\u003enext; while (p != NULL) { printf(\"%d \", p-\u003edata); p = p-\u003enext; } return 0; } 此算法时间复杂度为 O(n2)。 用一个指针指向尾结点，这样就为下一个新结点指明了插入位置，可称为「尾插」操作，最终形成的链表的数据顺序与输入顺序正好相同： LinkedList CreateLinkedList2() { LinkedList head; Node *p, *q; int x; head = (LinkedList)malloc(sizeof(Node)); // 生成头结点 q = head; // 尾指针置初值 scanf(\"%d\", \u0026x); // 读入第一个元素 while (x != 0) { p = (LinkedList)malloc(sizeof(Node)); p-\u003edata = x; q-\u003enext = p; // 新结点 p 链入 q = p; // 修改尾指针 q，指向新的尾结点 scanf(\"%d\", \u0026x); // 读入下一个元素 } q-\u003enext = NULL; return head; } int main() { LinkedList head = CreateLinkedList2(); LinkedList p = head-\u003enext; while (p != NULL) { printf(\"%d \", p-\u003edata); p = p-\u003enext; } return 0; } 此算法时间复杂度为 O(n)。 将新增的结点插入到头结点之后，第一个数据结点之前，可称为「前插」操作，最终形成的链表的数据顺序与输入顺序正好相反： LinkedList CreateLinkedList3() { LinkedList head; Node *p; int x; head = (LinkedList)malloc(sizeof(Node)); head-\u003enext = NULL; scanf(\"%d\", \u0026x); while (x) { p = (LinkedList)malloc(sizeof(Node)); p-\u003edata = x; p-\u003enext = head-\u003enext; head-\u003enext = p; scanf(\"%d\", \u0026x); } return head; } int main() { LinkedList head = CreateLinkedList3(); LinkedList p = head-\u003enext; while (p != NULL) { printf(\"%d \", p-\u003edata); p = p-\u003enext; } return 0; } 此算法时间复杂度为 O(n)。 ","date":"2022-05-04","objectID":"/posts/ds-linear-list/:4:1","tags":["Data Structure \u0026 Algorithm"],"title":"线性表","uri":"/posts/ds-linear-list/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"删除重复结点 void RemoveDuplicateLinkedList(LinkedList head) { Node *p, *q, *t; q = head-\u003enext; while (q != NULL) { p = q; while (p-\u003enext != NULL) { if (p-\u003enext-\u003edata == q-\u003edata) { t = p-\u003enext; p-\u003enext = t-\u003enext; free(t); } else { p = p-\u003enext; } } q = q-\u003enext; } } ","date":"2022-05-04","objectID":"/posts/ds-linear-list/:4:2","tags":["Data Structure \u0026 Algorithm"],"title":"线性表","uri":"/posts/ds-linear-list/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"整理一下数据结构与算法方面的概念和代码。 数据结构与算法起步 线性表 栈和队列 ","date":"2022-05-04","objectID":"/posts/ds-get-started/:0:0","tags":["Data Structure \u0026 Algorithm"],"title":"数据结构与算法起步","uri":"/posts/ds-get-started/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"概念 研究对象：数据结构课程是研究非数值计算的程序设计问题中计算机处理对象及它们之间关系和操作的学科。简单地说，数据结构是计算机组织数据和存储数据的方式。更进一步地说，数据结构是指一组相互之间的存在一种或多种特定关系的的数据组织方式或它们在计算机内的存储方式，以及在该组数据上的一组操作。 ","date":"2022-05-04","objectID":"/posts/ds-get-started/:1:0","tags":["Data Structure \u0026 Algorithm"],"title":"数据结构与算法起步","uri":"/posts/ds-get-started/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"概念术语 数据（Data）：是信息的载体，它是能够被计算机识别、存储和处理的对象； 数据元素（Data Element）：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。数据元素是运算的基本单位，通常具有完整确定的意义。数据元素常常又简称元素。一个数据元素可由若干个数据项（Data Item）组成。在不同的条件下，数据元素又可称为元素、结点、顶点、记录等； 数据项（Data Item）：是指不可分割的、具有独立意义的最小数据单位，在数据库中数据项又称为字段（field）或域。数据项是数据的不可分割的最小标识单位； 数据结构（Data Structure）：是指互相之间存在着一种或多种关系的数据元素的集合。它包括数据的逻辑结构、数据的存储结构和数据的基本运算； 数据类型（Data Type）：一是限定了数据的取值范围（实际上与存储形式有关）；二是规定了数据能够进行的一组操作（运算）； 数据类型可分为两类：一类是非结构的原子类型，原子类型的值是不可再分解的（整型、实型等）；另一类是结构类型，它的成分可以由多个结构类型组成，并可以分解；结构类型的成分可以是非结构的，也可以是结构的（数组的值由若干分量组成，每个分量可以是整数等基本类型，也可以是数组等结构类型）； 抽象数据类型（Abstract Data Type）：指一个数学模型及定义在该模型上的一组操作；抽象数据类型的定义取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关； ","date":"2022-05-04","objectID":"/posts/ds-get-started/:1:1","tags":["Data Structure \u0026 Algorithm"],"title":"数据结构与算法起步","uri":"/posts/ds-get-started/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"数据的逻辑结构 数据的逻辑结构：指数据元素之间的逻辑关系，即数据元素之间的关系方式或「邻接关系」，分为线性结构（表、栈、队、串等）和非线性结构（树、图、网等）。 数据的逻辑结构的四种分类： 集合结构：数据元素之间的关系是「属于同一个集合」。数据元素之间除了同属一个集合外，不存在其他关系；任何两个结点之间都没有邻接关系，组织形式松散； 线性结构：数据元素除了同属于一个集合外，数据元素之间还存在着一对一的顺序关系；其中结点按逻辑关系依次排列形成一条「链」，结点之间一个一个依次相邻接； 树形结构：数据元素之间存在着一对多的层次关系；具有分支、层次特性，其形态像自然界中的树，上层的结点可以和下层的结点相邻接，但下层的结点只能和上层的一个结点相邻接； 图状结构：数据元素之间存在着多对多的任意关系，图状结构也称为网状结构；其中任何两个结点的都可以相邻接； ","date":"2022-05-04","objectID":"/posts/ds-get-started/:1:2","tags":["Data Structure \u0026 Algorithm"],"title":"数据结构与算法起步","uri":"/posts/ds-get-started/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"数据的存储结构 数据的存储结构：指数据的逻辑结构在计算机中的实现，也称数据的物理结构（或数据的存储结构）。 数据的存储结构的两个部分： 存储数据的元素； 数据元素之间的关联方式； 数据的存储结构的四种方式： 顺序存储：指所有存储结点存放在一个连续的存储区里；利用结点在存储器中的相对位置来表示数据元素之间的逻辑关系； 链式存储：批每个存储结点除了含有一个数据元素外，还包含指针，每个指针指向一个与本结点有逻辑关系的结点，用指针表示数据元素之间的逻辑关系； 索引存储：指通过建立存储结点信息，以及建立附加的索引表来标识结点的地址的存储方法； 散列存储：又称 Hash 存储，是一种力图将数据元素的存储位置与关键码之间建立确定对应关系的查找方式； ","date":"2022-05-04","objectID":"/posts/ds-get-started/:1:3","tags":["Data Structure \u0026 Algorithm"],"title":"数据结构与算法起步","uri":"/posts/ds-get-started/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"数据的逻辑结构与数据的存储结构的关系 数据的逻辑结构只是一种数据模型，体现了数据的组织方式，要在计算机中实现逻辑结构，还依赖它在计算机中的存储结构； 数据的逻辑结构在计算机中的实现称为数据的存储结构（或物理结构）。一般情况下，一个存储结构包括存储数据的元素和数据元素之间的关系方式； 一种逻辑结构可以采用一种或几种存储方式来表达数据元素之间的逻辑关系，相应的存储结构称为给定逻辑结构的存储实现或存储映像； ","date":"2022-05-04","objectID":"/posts/ds-get-started/:1:4","tags":["Data Structure \u0026 Algorithm"],"title":"数据结构与算法起步","uri":"/posts/ds-get-started/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"运算 运算：指在某种逻辑结构上施加的操作，即对逻辑结构的加工。这种加工以数据的逻辑结构为对象，运算的实现就是对该运算的算法。 数据结构上的基本操作： 创建：建立某种所需的数据结构； 插入：在指定位置上添加新的数据元素； 删除：删去指定位置上对应的数据元素； 更新：修改某个数据元素的值； 查找：寻找满足特定条件的数据元素所在的位置； 读取：读出指定位置上数据元素的内容； ","date":"2022-05-04","objectID":"/posts/ds-get-started/:1:5","tags":["Data Structure \u0026 Algorithm"],"title":"数据结构与算法起步","uri":"/posts/ds-get-started/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"算法 ","date":"2022-05-04","objectID":"/posts/ds-get-started/:2:0","tags":["Data Structure \u0026 Algorithm"],"title":"数据结构与算法起步","uri":"/posts/ds-get-started/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"算法特性 算法（Algorithm）：是对特定问题求解步骤的一种描述，是指令的有限序列。其中每一条指令表示一个或多个操作。 算法的特性： 有穷性：一个算法必须在有穷步之后结束，即必须在有限时间内完成； 确定性：算法的每一步必须有确切的定义，无二义性，且在任何条件下算法只有唯一一条执行路径，即对于相同的输入只能得出相同的输出； 可行性：算法中的每一步都可以通过已经实现的基本运算的有限次执行得以实现； 输入：一个算法具有零个或多个输入，这些输入取自特定的数据对象集合； 输出：一个算法具有一个或多个输出，这些输出同输入之间存在某种特定的关系； 算法好坏的因素： 正确性：能正确地实现预定的功能，满足具体问题的需要； 易读性：易于阅读、理解和交流，便于调试、修改和扩充； 健壮性：即使输入非法数据，算法也能适当地做出反应或进行处理，不会产生预料不到的运行结果； 时空性：算法的时间性能（或时间效率）尽可能快和空间性能（或空间效率）尽可能少，时间性能考量计算量，空间性能考量存储量； ","date":"2022-05-04","objectID":"/posts/ds-get-started/:2:1","tags":["Data Structure \u0026 Algorithm"],"title":"数据结构与算法起步","uri":"/posts/ds-get-started/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"算法的描述 自然语言算法描述：用人类自然语言（如中文、英文等）来描述算法，同时还可插入一些程序设计语言中的语句来描述，这种方法也称为非形式算法描述。其优点是不需要专门学习，任何人都可以直接阅读和理解，但直观性很差，复杂的算法难写难读； 框图算法描述：这是一种图示法，可以采用方框图、流程图、N-S 图等来描述算法，这种描述方法在算法研究的早期曾流行过。它的优点是直观、易懂，但用来描述比较复杂的算法就显得不够方便，也不够清晰简洁； 伪代码算法描述：如类 C 语言算法描述。这种算法描述很像程序，但它不能直接在计算机上编译、运行。这种方法很容易编写、阅读算法，而且格式统一，结构清晰，专业设计人员经常使用类 C 语言来描述算法； 高级程序设计语言编写的程序或函数：这是直接用高级语言来描述算法，它可在计算机上运行并获得结果，使给定问题能在有限时间内被求解，通常这种算法描述也称为程序； ","date":"2022-05-04","objectID":"/posts/ds-get-started/:2:2","tags":["Data Structure \u0026 Algorithm"],"title":"数据结构与算法起步","uri":"/posts/ds-get-started/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"算法分析 算法被转换成程序并在计算机上执行时，其运行所需要的时间一般取决于下列几个因素： 硬件的速度； 实现算法的程序设计语言； 编译程序所生成目标代码的质量； 算法所采用的策略； 问题的规模； ","date":"2022-05-04","objectID":"/posts/ds-get-started/:3:0","tags":["Data Structure \u0026 Algorithm"],"title":"数据结构与算法起步","uri":"/posts/ds-get-started/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"时间复杂度 Know Thy Complexities 时间复杂度（Time Complexity）：指该程序的运行时间与问题规模的对应关系。大 Ο 表示法也称为算法的渐进表示法，它不考虑具体的运行时间，只给出算法在问题规模 n 下执行时间的上界。T(n) = O(f(n)) 称为算法的渐进时间复杂度（Asymptotic Time Complexity），简称时间复杂度。 大 O 记号表示法定义：如果存在两个正常数 c 和 n0，使得对所有的 n(n\u003e=n0)，有 T(n) \u003c= c*f(n)，则：T(n)=O(f(n))。 最坏时间复杂度：指对于相同输入数据量的不同输入数据，算法时间用量的最大值。 平均时间复杂度：指对所有相同输入数据量的各种不同输入数据，算法时间用量的平均值。 常见的渐进时间复杂度（按时间效率从高到底）：O(1) \u003e O(log2n \u003e O(n) \u003e O(nlog2n) \u003e O(n2) \u003e O(n3) \u003e O(2n)。 ","date":"2022-05-04","objectID":"/posts/ds-get-started/:3:1","tags":["Data Structure \u0026 Algorithm"],"title":"数据结构与算法起步","uri":"/posts/ds-get-started/"},{"categories":["Data Structure \u0026 Algorithm"],"content":"空间复杂度 空间复杂度（Space Complexity）：指程序运行从开始到结束所需的存储量与问题规模的对应关系。记做：S(n)=O(g(n))。 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在执行期间所需要的存储空间量应包括以下三个部分： 程序代码所占用的空间； 输入数据所占用的空间； 辅助变量所占用的空间； ","date":"2022-05-04","objectID":"/posts/ds-get-started/:3:2","tags":["Data Structure \u0026 Algorithm"],"title":"数据结构与算法起步","uri":"/posts/ds-get-started/"},{"categories":["AWS"],"content":"AWS 在部署容器时提供了很多选项。但是知道哪种服务能做什么，即使是经验丰富的专业人士也会感到头痛。 ","date":"2022-01-17","objectID":"/posts/aws-get-started/:0:0","tags":["AWS"],"title":"AWS Get Started","uri":"/posts/aws-get-started/"},{"categories":["AWS"],"content":"了解每个服务的角色 本质上，每个服务都是编排层（管理容器）或宿主层（运行容器）的一部分： ECS、EK 和 Kuberneretes 是编排层的一部分； EC2 和 Fargate 是宿主层的一部分； ","date":"2022-01-17","objectID":"/posts/aws-get-started/:1:0","tags":["AWS"],"title":"AWS Get Started","uri":"/posts/aws-get-started/"},{"categories":["AWS"],"content":"EKS vs ECS vs Kuberneretes - 编排层 容器编排服务自动化管理容器的手动工作。编排的主要好处是： Simplifying Operations - 自动部署和创建新容器； Adding Resilience - 自动管理故障和容器生命周期； Adding Security - 消除由于用户错误而造成的违规行为，并自动化安全最佳实践； ","date":"2022-01-17","objectID":"/posts/aws-get-started/:2:0","tags":["AWS"],"title":"AWS Get Started","uri":"/posts/aws-get-started/"},{"categories":["AWS"],"content":"ECS - Elastic Container Service AWS 自己的容器服务。它在集群中管理容器，被称为 ECS 集群。 ","date":"2022-01-17","objectID":"/posts/aws-get-started/:2:1","tags":["AWS"],"title":"AWS Get Started","uri":"/posts/aws-get-started/"},{"categories":["AWS"],"content":"EKS - Elastic Kuberneretes Service EKS 是一种 AWS 容器服务，它与 ECS 的不同之处在于它用于管理 AWS 基础设施上的 Kubernetes 集群。还可以将现有的 Kubernetes 工作负载迁移到 EKS 上。 ","date":"2022-01-17","objectID":"/posts/aws-get-started/:2:2","tags":["AWS"],"title":"AWS Get Started","uri":"/posts/aws-get-started/"},{"categories":["AWS"],"content":"Kubernetes Kubernetes 是开源的容器编排服务，非常流行，但要在 AWS 上部署 Kubernetes，可以说必须使用 EKS 来实现。 ","date":"2022-01-17","objectID":"/posts/aws-get-started/:2:3","tags":["AWS"],"title":"AWS Get Started","uri":"/posts/aws-get-started/"},{"categories":["AWS"],"content":"ECS vs EKS ECS pros ECS 是 AWS 自己的容器服务，因此它与 AWS 生态系统，包括 CloudTrail，CloudWatch 和 Amazon ECR（弹性容器注册）进行了更好的集成，以实现对 Docker 映像的无缝管理； ECS 控制面板完全自由，而 EKS 需要充值； EKS pros 由于 EKS 使用 Kubernetes，所以它更加灵活，这意味着可以比 ECS 更轻松地将工作迁移到另一个平台，使其更适合复杂的多云工作负载； EKS 更适合复杂的应用； EKS 最终提供了比 ECS 更多的控制（对集群的管理和调度）； 结论 如果需要一个更简单的应用程序，并且希望合并许多 AWS 服务，ECS 可能是比较好的选择。如果有一个更复杂的项目，特别是如果想要使用多云方法，EKS 是正确的选择——显然，如果想要使用 Kubernetes 时。 ","date":"2022-01-17","objectID":"/posts/aws-get-started/:2:4","tags":["AWS"],"title":"AWS Get Started","uri":"/posts/aws-get-started/"},{"categories":["AWS"],"content":"Fargate vs EC2 – 宿主层 容器部署的宿主层表示容器将实际运行的虚拟机（或承载的虚拟机，因此得名）。 ","date":"2022-01-17","objectID":"/posts/aws-get-started/:3:0","tags":["AWS"],"title":"AWS Get Started","uri":"/posts/aws-get-started/"},{"categories":["AWS"],"content":"EC2 Deploy and manage your own cluster of EC2 instances for running the containers. EC2 是部署容器的传统方式。在 EC2 中，通过实际的 VM 进行运行。 ","date":"2022-01-17","objectID":"/posts/aws-get-started/:3:1","tags":["AWS"],"title":"AWS Get Started","uri":"/posts/aws-get-started/"},{"categories":["AWS"],"content":"Fargate Run containers directly, without any EC2 instances. Fargate 带来了一种无服务器的方式，Fargate 不是自己配置服务器，而是根据每个请求自动为容器配置基础设施。 ","date":"2022-01-17","objectID":"/posts/aws-get-started/:3:2","tags":["AWS"],"title":"AWS Get Started","uri":"/posts/aws-get-started/"},{"categories":["AWS"],"content":"EC2 vs Fargate EC2 pros EC2 意味着更多的手工工作，但是有更多的控制力和透明度（因为你自己需要配置基础设施）； 需要熟悉 EC2； Fargate pros Fargate 意味着更少的工作，通常成本更低（需要你为消耗的资源付费），对应的控制力和透明度更低； Fargate 是无服务器的，这种方式是以后的常态； 结论 如果有时间和预算，并且需要额外的监督和控制，EC2 是更好的选择。如果想要降低成本和减轻负担，Fargate 是个不错的选择。 ","date":"2022-01-17","objectID":"/posts/aws-get-started/:3:3","tags":["AWS"],"title":"AWS Get Started","uri":"/posts/aws-get-started/"},{"categories":["AWS"],"content":"Benefits of infrastructure as code 以下摘自 AWS 官网。 Visibility: An infrastructure as code template serves as a very clear reference of what resources are on your account, and what their settings are. You don’t have to navigate to the web console to check the parameters. Stability: If you accidentally change the wrong setting or delete the wrong resource in the web console you can break things. Infrastructure as code helps solve this, especially when it is combined with version control, such as Git. Scalability: With infrastructure as code you can write it once and then reuse it many times. This means that one well written template can be used as the basis for multiple services, in multiple regions around the world, making it much easier to horizontally scale. Security: Once again infrastructure as code gives you a unified template for how to deploy your architecture. If you create one well secured architecture you can reuse it multiple times, and know that each deployed version is following the same settings. Transactional: CloudFormation not only creates resources on your AWS account but also waits for them to stabilize while they start. It verifies that provisioning was successful, and if there is a failure it can gracefully roll the infrastructure back to a past known good state. ","date":"2022-01-17","objectID":"/posts/aws-get-started/:4:0","tags":["AWS"],"title":"AWS Get Started","uri":"/posts/aws-get-started/"},{"categories":["PHP"],"content":"通过 GDB 跟踪调试来了解一下 Zend String 和 Zend Array。 PHP 源码学习一 PHP 源码学习二 ","date":"2021-09-13","objectID":"/posts/php-src-learning2/:0:0","tags":["PHP"],"title":"PHP 源码学习二","uri":"/posts/php-src-learning2/"},{"categories":["PHP"],"content":"Zend String ","date":"2021-09-13","objectID":"/posts/php-src-learning2/:1:0","tags":["PHP"],"title":"PHP 源码学习二","uri":"/posts/php-src-learning2/"},{"categories":["PHP"],"content":"Zend String Struct struct _zend_string { zend_refcounted_h gc; zend_ulong h; /* hash value */ size_t len; char val[1]; }; typedef struct _zend_refcounted_h { uint32_t refcount; /* reference counter 32-bit */ union { uint32_t type_info; } u; } zend_refcounted_h; ","date":"2021-09-13","objectID":"/posts/php-src-learning2/:1:1","tags":["PHP"],"title":"PHP 源码学习二","uri":"/posts/php-src-learning2/"},{"categories":["PHP"],"content":"Copy-on-write \u003c?php $c = 'Hello World!'; echo $c; $a = time() . 'String'; echo $a; // Copy-on-write $b = $a; echo $a; echo $b; $b = 'Hello'; echo $a; echo $b; # gdb /home/vagrant/codes/php80/bin/php (gdb) b ZEND_ECHO_SPEC_CV_HANDLER Breakpoint 1 at 0x5c96a8: file /vagrant/php-8.0.10/Zend/zend_vm_execute.h, line 37184. (gdb) r copy-on-write.php Starting program: /home/vagrant/codes/php80/bin/php copy-on-write.php [Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\". Breakpoint 1, ZEND_ECHO_SPEC_CV_HANDLER () at /vagrant/php-8.0.10/Zend/zend_vm_execute.h:37184 37184 SAVE_OPLINE(); (gdb) n 37185 z = EX_VAR(opline-\u003eop1.var); (gdb) 37187 if (Z_TYPE_P(z) == IS_STRING) { (gdb) p z $1 = (zval *) 0x7ffff3814070 (gdb) p *z $2 = {value = {lval = 140737278651680, dval = 6.9533454470981759e-310, counted = 0x7ffff3802d20, str = 0x7ffff3802d20, arr = 0x7ffff3802d20, obj = 0x7ffff3802d20, res = 0x7ffff3802d20, ref = 0x7ffff3802d20, ast = 0x7ffff3802d20, zv = 0x7ffff3802d20, ptr = 0x7ffff3802d20, ce = 0x7ffff3802d20, func = 0x7ffff3802d20, ww = {w1 = 4085263648, w2 = 32767}}, u1 = {type_info = 6, v = {type = 6 '\\006', type_flags = 0 '\\000', u = {extra = 0}}}, u2 = {next = 0, cache_slot = 0, opline_num = 0, lineno = 0, num_args = 0, fe_pos = 0, fe_iter_idx = 0, access_flags = 0, property_guard = 0, constant_flags = 0, extra = 0}} (gdb) p $2.value.str $3 = (zend_string *) 0x7ffff3802d20 (gdb) p *$2.value.str $4 = {gc = {refcount = 1, u = {type_info = 86}}, h = 13594750393630990530, len = 12, val = \"H\"} (gdb) p *$2.value.str.val@12 $5 = \"Hello World!\" (gdb) c Continuing. Hello World! Breakpoint 1, ZEND_ECHO_SPEC_CV_HANDLER () at /vagrant/php-8.0.10/Zend/zend_vm_execute.h:37184 37184 SAVE_OPLINE(); (gdb) n 37185 z = EX_VAR(opline-\u003eop1.var); (gdb) 37187 if (Z_TYPE_P(z) == IS_STRING) { (gdb) p z $6 = (zval *) 0x7ffff3814080 (gdb) p *z $7 = {value = {lval = 140737278651760, dval = 6.9533454471021284e-310, counted = 0x7ffff3802d70, str = 0x7ffff3802d70, arr = 0x7ffff3802d70, obj = 0x7ffff3802d70, res = 0x7ffff3802d70, ref = 0x7ffff3802d70, ast = 0x7ffff3802d70, zv = 0x7ffff3802d70, ptr = 0x7ffff3802d70, ce = 0x7ffff3802d70, func = 0x7ffff3802d70, ww = {w1 = 4085263728, w2 = 32767}}, u1 = {type_info = 262, v = {type = 6 '\\006', type_flags = 1 '\\001', u = {extra = 0}}}, u2 = {next = 0, cache_slot = 0, opline_num = 0, lineno = 0, num_args = 0, fe_pos = 0, fe_iter_idx = 0, access_flags = 0, property_guard = 0, constant_flags = 0, extra = 0}} (gdb) p *z.value.str $8 = {gc = {refcount = 1, u = {type_info = 22}}, h = 0, len = 16, val = \"1\"} (gdb) p *z.value.str.val@16 $9 = \"1631431095String\" (gdb) c Continuing. 1631431095String Breakpoint 1, ZEND_ECHO_SPEC_CV_HANDLER () at /vagrant/php-8.0.10/Zend/zend_vm_execute.h:37184 37184 SAVE_OPLINE(); (gdb) n 37185 z = EX_VAR(opline-\u003eop1.var); (gdb) 37187 if (Z_TYPE_P(z) == IS_STRING) { (gdb) p z $10 = (zval *) 0x7ffff3814080 (gdb) p *z $11 = {value = {lval = 140737278651760, dval = 6.9533454471021284e-310, counted = 0x7ffff3802d70, str = 0x7ffff3802d70, arr = 0x7ffff3802d70, obj = 0x7ffff3802d70, res = 0x7ffff3802d70, ref = 0x7ffff3802d70, ast = 0x7ffff3802d70, zv = 0x7ffff3802d70, ptr = 0x7ffff3802d70, ce = 0x7ffff3802d70, func = 0x7ffff3802d70, ww = {w1 = 4085263728, w2 = 32767}}, u1 = {type_info = 262, v = { type = 6 '\\006', type_flags = 1 '\\001', u = {extra = 0}}}, u2 = {next = 0, cache_slot = 0, opline_num = 0, lineno = 0, num_args = 0, fe_pos = 0, fe_iter_idx = 0, access_flags = 0, property_guard = 0, constant_flags = 0, extra = 0}} (gdb) p *z.value.str $12 = {gc = {refcount = 2, u = {type_info = 22}}, h = 0, len = 16, val = \"1\"} (gdb) p *z.value.str.val@16 $13 = \"1631431095String\" (gdb) c Continuing. 1631431095String Breakpoint 1, ZEND_ECHO_SPEC_CV_HANDLER () at /vagrant/php-8.0.10/Zend/zend_vm_execute.h:37184 37184 SAVE_OPLINE(); (gdb) n 37185 z = EX_VAR(opline-\u003eop1.var); (gdb) 37187 if (Z_TYPE_P(z) == IS_STRING) { (gdb) p z $14 = (zval *) 0x7","date":"2021-09-13","objectID":"/posts/php-src-learning2/:1:2","tags":["PHP"],"title":"PHP 源码学习二","uri":"/posts/php-src-learning2/"},{"categories":["PHP"],"content":"引用类型 \u003c?php $a = 'String'; $b = \u0026$a; echo $a . \"\\n\"; echo $b . \"\\n\"; $b = 'Hello'; echo $a . \"\\n\"; echo $b . \"\\n\"; unset($b); echo $a . \"\\n\"; echo $b . \"\\n\"; # gdb /home/vagrant/codes/php80/bin/php (gdb) b ZEND_ECHO_SPEC_CV_HANDLER Breakpoint 1 at 0x5c96a8: file /vagrant/php-8.0.10/Zend/zend_vm_execute.h, line 37184. (gdb) r reference.php Starting program: /home/vagrant/codes/php80/bin/php reference.php [Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\". Breakpoint 1, ZEND_ECHO_SPEC_CV_HANDLER () at /vagrant/php-8.0.10/Zend/zend_vm_execute.h:37184 37184 SAVE_OPLINE(); (gdb) n 37185 z = EX_VAR(opline-\u003eop1.var); (gdb) 37187 if (Z_TYPE_P(z) == IS_STRING) { (gdb) p z $1 = (zval *) 0x7ffff3814070 (gdb) p *z $2 = {value = {lval = 140737278645952, dval = 6.9533454468151751e-310, counted = 0x7ffff38016c0, str = 0x7ffff38016c0, arr = 0x7ffff38016c0, obj = 0x7ffff38016c0, res = 0x7ffff38016c0, ref = 0x7ffff38016c0, ast = 0x7ffff38016c0, zv = 0x7ffff38016c0, ptr = 0x7ffff38016c0, ce = 0x7ffff38016c0, func = 0x7ffff38016c0, ww = {w1 = 4085257920, w2 = 32767}}, u1 = {type_info = 266, v = {type = 10 '\\n', type_flags = 1 '\\001', u = {extra = 0}}}, u2 = {next = 0, cache_slot = 0, opline_num = 0, lineno = 0, num_args = 0, fe_pos = 0, fe_iter_idx = 0, access_flags = 0, property_guard = 0, constant_flags = 0, extra = 0}} (gdb) c Continuing. String Breakpoint 1, ZEND_ECHO_SPEC_CV_HANDLER () at /vagrant/php-8.0.10/Zend/zend_vm_execute.h:37184 37184 SAVE_OPLINE(); (gdb) n 37185 z = EX_VAR(opline-\u003eop1.var); (gdb) 37187 if (Z_TYPE_P(z) == IS_STRING) { (gdb) p z $3 = (zval *) 0x7ffff3814080 (gdb) p *z $4 = {value = {lval = 140737278645952, dval = 6.9533454468151751e-310, counted = 0x7ffff38016c0, str = 0x7ffff38016c0, arr = 0x7ffff38016c0, obj = 0x7ffff38016c0, res = 0x7ffff38016c0, ref = 0x7ffff38016c0, ast = 0x7ffff38016c0, zv = 0x7ffff38016c0, ptr = 0x7ffff38016c0, ce = 0x7ffff38016c0, func = 0x7ffff38016c0, ww = {w1 = 4085257920, w2 = 32767}}, u1 = {type_info = 266, v = {type = 10 '\\n', type_flags = 1 '\\001', u = {extra = 0}}}, u2 = {next = 0, cache_slot = 0, opline_num = 0, lineno = 0, num_args = 0, fe_pos = 0, fe_iter_idx = 0, access_flags = 0, property_guard = 0, constant_flags = 0, extra = 0}} (gdb) p $4.value.ref $5 = (zend_reference *) 0x7ffff38016c0 (gdb) p *$4.value.ref $6 = {gc = {refcount = 2, u = {type_info = 26}}, val = {value = {lval = 140737278646080, dval = 6.9533454468214991e-310, counted = 0x7ffff3801740, str = 0x7ffff3801740, arr = 0x7ffff3801740, obj = 0x7ffff3801740, res = 0x7ffff3801740, ref = 0x7ffff3801740, ast = 0x7ffff3801740, zv = 0x7ffff3801740, ptr = 0x7ffff3801740, ce = 0x7ffff3801740, func = 0x7ffff3801740, ww = {w1 = 4085258048, w2 = 32767}}, u1 = {type_info = 6, v = {type = 6 '\\006', type_flags = 0 '\\000', u = {extra = 0}}}, u2 = {next = 0, cache_slot = 0, opline_num = 0, lineno = 0, num_args = 0, fe_pos = 0, fe_iter_idx = 0, access_flags = 0, property_guard = 0, constant_flags = 0, extra = 0}}, sources = {ptr = 0x0, list = 0}} (gdb) p *$4.value.ref.val.value.str $7 = {gc = {refcount = 1, u = {type_info = 86}}, h = 9223378989633936348, len = 6, val = \"S\"} (gdb) p *$4.value.ref.val.value.str.val@6 $8 = \"String\" (gdb) c Continuing. String Breakpoint 1, ZEND_ECHO_SPEC_CV_HANDLER () at /vagrant/php-8.0.10/Zend/zend_vm_execute.h:37184 37184 SAVE_OPLINE(); (gdb) n 37185 z = EX_VAR(opline-\u003eop1.var); (gdb) 37187 if (Z_TYPE_P(z) == IS_STRING) { (gdb) p z $9 = (zval *) 0x7ffff3814070 (gdb) p *z $10 = {value = {lval = 140737278645952, dval = 6.9533454468151751e-310, counted = 0x7ffff38016c0, str = 0x7ffff38016c0, arr = 0x7ffff38016c0, obj = 0x7ffff38016c0, res = 0x7ffff38016c0, ref = 0x7ffff38016c0, ast = 0x7ffff38016c0, zv = 0x7ffff38016c0, ptr = 0x7ffff38016c0, ce = 0x7ffff38016c0, func = 0x7ffff38016c0, ww = {w1 = 4085257920, w2 = 32767}}, u1 = {type_info = 266, v = { type = 10 '\\n', type_flags = 1 '\\001', u = {extra = 0}}}, u2 = {next = 0, cache_slot = 0, ","date":"2021-09-13","objectID":"/posts/php-src-learning2/:1:3","tags":["PHP"],"title":"PHP 源码学习二","uri":"/posts/php-src-learning2/"},{"categories":["PHP"],"content":"Zend Array ","date":"2021-09-13","objectID":"/posts/php-src-learning2/:2:0","tags":["PHP"],"title":"PHP 源码学习二","uri":"/posts/php-src-learning2/"},{"categories":["PHP"],"content":"Zend Array 结构体 typedef struct _zend_array HashTable; struct _zend_array { zend_refcounted_h gc; union { struct { ZEND_ENDIAN_LOHI_4( zend_uchar flags, zend_uchar _unused, zend_uchar nIteratorsCount, zend_uchar _unused2) } v; uint32_t flags; } u; uint32_t nTableMask; Bucket *arData; uint32_t nNumUsed; uint32_t nNumOfElements; uint32_t nTableSize; uint32_t nInternalPointer; zend_long nNextFreeElement; dtor_func_t pDestructor; }; /* * HashTable Data Layout * ===================== * * +=============================+ * | HT_HASH(ht, ht-\u003enTableMask) | * | ... | * | HT_HASH(ht, -1) | * +-----------------------------+ * ht-\u003earData ---\u003e | Bucket[0] | * | ... | * | Bucket[ht-\u003enTableSize-1] | * +=============================+ */ ","date":"2021-09-13","objectID":"/posts/php-src-learning2/:2:1","tags":["PHP"],"title":"PHP 源码学习二","uri":"/posts/php-src-learning2/"},{"categories":["PHP"],"content":"Zend Array 运行调试 # gdb /home/vagrant/codes/php80/bin/php (gdb) b zend_compile Breakpoint 1 at 0x4deed8: file /vagrant/php-8.0.10/Zend/zend_language_scanner.c, line 603. (gdb) r array.php Starting program: /home/vagrant/codes/php80/bin/php array.php [Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\". Breakpoint 1, zend_compile (type=2) at /vagrant/php-8.0.10/Zend/zend_language_scanner.c:603 603 { (gdb) s 604 zend_op_array *op_array = NULL; (gdb) b _zend_hash_init Breakpoint 2 at 0x555555aa768c: file /vagrant/php-8.0.10/Zend/zend_hash.c, line 266. (gdb) c Continuing. Breakpoint 2, _zend_hash_init (ht=0x555556773ab0 \u003ccompiler_globals+272\u003e, nSize=8, pDestructor=0x0, persistent=false) at /vagrant/php-8.0.10/Zend/zend_hash.c:266 266 _zend_hash_init_int(ht, nSize, pDestructor, persistent); (gdb) s _zend_hash_init_int (ht=0x555556773ab0 \u003ccompiler_globals+272\u003e, nSize=8, pDestructor=0x0, persistent=false) at /vagrant/php-8.0.10/Zend/zend_hash.c:251 251 GC_SET_REFCOUNT(ht, 1); (gdb) bt #0 _zend_hash_init_int (ht=0x555556773ab0 \u003ccompiler_globals+272\u003e, nSize=8, pDestructor=0x0, persistent=false) at /vagrant/php-8.0.10/Zend/zend_hash.c:251 #1 0x0000555555aa76a3 in _zend_hash_init (ht=0x555556773ab0 \u003ccompiler_globals+272\u003e, nSize=8, pDestructor=0x0, persistent=false) at /vagrant/php-8.0.10/Zend/zend_hash.c:266 #2 0x0000555555a5c950 in zend_file_context_begin (prev_context=0x7fffffffa940) at /vagrant/php-8.0.10/Zend/zend_compile.c:358 #3 0x0000555555a32fe4 in zend_compile (type=2) at /vagrant/php-8.0.10/Zend/zend_language_scanner.c:628 #4 0x0000555555a3316e in compile_file (file_handle=0x7fffffffd1d0, type=8) at /vagrant/php-8.0.10/Zend/zend_language_scanner.c:665 #5 0x000055555585b013 in phar_compile_file (file_handle=0x7fffffffd1d0, type=8) at /vagrant/php-8.0.10/ext/phar/phar.c:3364 #6 0x0000555555a94ae5 in zend_execute_scripts (type=8, retval=0x0, file_count=3) at /vagrant/php-8.0.10/Zend/zend.c:1674 #7 0x00005555559f740c in php_execute_script (primary_file=0x7fffffffd1d0) at /vagrant/php-8.0.10/main/main.c:2524 #8 0x0000555555b81550 in do_cli (argc=2, argv=0x55555678a980) at /vagrant/php-8.0.10/sapi/cli/php_cli.c:949 #9 0x0000555555b82596 in main (argc=2, argv=0x55555678a980) at /vagrant/php-8.0.10/sapi/cli/php_cli.c:1337 (gdb) n 252 GC_TYPE_INFO(ht) = GC_ARRAY | (persistent ? ((GC_PERSISTENT|GC_NOT_COLLECTABLE) \u003c\u003c GC_FLAGS_SHIFT) : 0); (gdb) p ht $1 = (HashTable *) 0x555556773ab0 \u003ccompiler_globals+272\u003e (gdb) p *ht $2 = {gc = {refcount = 1, u = {type_info = 0}}, u = {v = {flags = 0 '\\000', _unused = 0 '\\000', nIteratorsCount = 0 '\\000', _unused2 = 0 '\\000'}, flags = 0}, nTableMask = 0, arData = 0x0, nNumUsed = 0, nNumOfElements = 0, nTableSize = 0, nInternalPointer = 0, nNextFreeElement = 0, pDestructor = 0x0} (gdb) n 253 HT_FLAGS(ht) = HASH_FLAG_UNINITIALIZED; (gdb) p HASH_FLAG_UNINITIALIZED No symbol \"HASH_FLAG_UNINITIALIZED\" in current context. (gdb) p ht $3 = (HashTable *) 0x555556773ab0 \u003ccompiler_globals+272\u003e (gdb) p *ht $4 = {gc = {refcount = 1, u = {type_info = 7}}, u = {v = {flags = 0 '\\000', _unused = 0 '\\000', nIteratorsCount = 0 '\\000', _unused2 = 0 '\\000'}, flags = 0}, nTableMask = 0, arData = 0x0, nNumUsed = 0, nNumOfElements = 0, nTableSize = 0, nInternalPointer = 0, nNextFreeElement = 0, pDestructor = 0x0} (gdb) n 254 ht-\u003enTableMask = HT_MIN_MASK; (gdb) p HT_MIN_MASK No symbol \"HT_MIN_MASK\" in current context. (gdb) p ht-\u003enTableMask $5 = 0 (gdb) n 255 HT_SET_DATA_ADDR(ht, \u0026uninitialized_bucket); (gdb) p ht $6 = (HashTable *) 0x555556773ab0 \u003ccompiler_globals+272\u003e (gdb) p *ht $7 = {gc = {refcount = 1, u = {type_info = 7}}, u = {v = {flags = 8 '\\b', _unused = 0 '\\000', nIteratorsCount = 0 '\\000', _unused2 = 0 '\\000'}, flags = 8}, nTableMask = 4294967294, arData = 0x0, nNumUsed = 0, nNumOfElements = 0, nTableSize = 0, nInternalPointer = 0, nNextFreeElement = 0, pDestructor = 0x0} (gdb) p (int32_t)4294967294 $8 = -2 (gdb) n 256 ht-\u003enNumUsed = 0; (gdb) p ht $9 = ","date":"2021-09-13","objectID":"/posts/php-src-learning2/:2:2","tags":["PHP"],"title":"PHP 源码学习二","uri":"/posts/php-src-learning2/"},{"categories":["PHP"],"content":"看到慕课网有大佬讲解 PHP 源码，既然来了，那就看看吧，以下为整理的笔记。 PHP 源码学习一 PHP 源码学习二 ","date":"2021-09-12","objectID":"/posts/php-src-learning1/:0:0","tags":["PHP"],"title":"PHP 源码学习一","uri":"/posts/php-src-learning1/"},{"categories":["PHP"],"content":"环境准备 Boxes // 之所以使用 hashicorp/bionic64，是因为这个镜像是官方的，坑少而已 $ vagrant init hashicorp/bionic64 // 这是我本地已经安装的一些镜像，有了镜像就可以在几分钟之内登录到一台全新的 Linux 系统中 $ vagrant box list centos/7 (virtualbox, 2004.01) hashicorp/bionic64 (virtualbox, 1.0.282) laravel/homestead (virtualbox, 9.7.2) ubuntu/xenial64 (virtualbox, 20210804.0.0) // 需要漫长的等待，有可能还需要翻墙，或者你可以下载镜像后选择导入 $ vagrant up ","date":"2021-09-12","objectID":"/posts/php-src-learning1/:1:0","tags":["PHP"],"title":"PHP 源码学习一","uri":"/posts/php-src-learning1/"},{"categories":["PHP"],"content":"编译安装 如果从 官网 下载，不需要进行 autoconf；如果从 Github 下载，需要在解压目录中执行 autoconf，经过本人安装折腾，认为从官网下载的包安装比较顺利。 $ sudo -s # apt-get update \u0026\u0026 apt-get upgrade # apt-get install autoconf bison re2c pkg-config libxml2-dev libsqlite3-dev gdb -y # cd ~ \u0026\u0026 mkdir codes # cd ~/vagrant // 安装 php80 # tar -zxvf php-src-php-8.0.1.tar.gz # cd php-src-php-8.0.1 # autoconf # ./configure --prefix=/home/vagrant/codes/php80 --enable-fpm --enable-debug # make \u0026\u0026 make install Installing shared extensions: /home/vagrant/codes/php80/lib/php/extensions/debug-non-zts-20200930/ Installing PHP CLI binary: /home/vagrant/codes/php80/bin/ Installing PHP CLI man page: /home/vagrant/codes/php80/php/man/man1/ Installing PHP FPM binary: /home/vagrant/codes/php80/sbin/ Installing PHP FPM defconfig: /home/vagrant/codes/php80/etc/ Installing PHP FPM man page: /home/vagrant/codes/php80/php/man/man8/ Installing PHP FPM status page: /home/vagrant/codes/php80/php/php/fpm/ Installing phpdbg binary: /home/vagrant/codes/php80/bin/ Installing phpdbg man page: /home/vagrant/codes/php80/php/man/man1/ Installing PHP CGI binary: /home/vagrant/codes/php80/bin/ Installing PHP CGI man page: /home/vagrant/codes/php80/php/man/man1/ Installing build environment: /home/vagrant/codes/php80/lib/php/build/ Installing header files: /home/vagrant/codes/php80/include/php/ Installing helper programs: /home/vagrant/codes/php80/bin/ program: phpize program: php-config Installing man pages: /home/vagrant/codes/php80/php/man/man1/ page: phpize.1 page: php-config.1 /vagrant/php-8.0.10/build/shtool install -c ext/phar/phar.phar /home/vagrant/codes/php80/bin/phar.phar ln -s -f phar.phar /home/vagrant/codes/php80/bin/phar Installing PDO headers: /home/vagrant/codes/php80/include/php/ext/pdo/ // 安装 php74 # tar -zxvf php-src-php-7.4.23.tar.gz # cd php-src-php-7.4.23 # autoconf # ./configure --prefix=/home/vagrant/codes/php74 --enable-fpm --enable-debug # make \u0026\u0026 make install Installing shared extensions: /home/vagrant/codes/php74/lib/php/extensions/debug-non-zts-20190902/ Installing PHP CLI binary: /home/vagrant/codes/php74/bin/ Installing PHP CLI man page: /home/vagrant/codes/php74/php/man/man1/ Installing PHP FPM binary: /home/vagrant/codes/php74/sbin/ Installing PHP FPM defconfig: /home/vagrant/codes/php74/etc/ Installing PHP FPM man page: /home/vagrant/codes/php74/php/man/man8/ Installing PHP FPM status page: /home/vagrant/codes/php74/php/php/fpm/ Installing phpdbg binary: /home/vagrant/codes/php74/bin/ Installing phpdbg man page: /home/vagrant/codes/php74/php/man/man1/ Installing PHP CGI binary: /home/vagrant/codes/php74/bin/ Installing PHP CGI man page: /home/vagrant/codes/php74/php/man/man1/ Installing build environment: /home/vagrant/codes/php74/lib/php/build/ Installing header files: /home/vagrant/codes/php74/include/php/ Installing helper programs: /home/vagrant/codes/php74/bin/ program: phpize program: php-config Installing man pages: /home/vagrant/codes/php74/php/man/man1/ page: phpize.1 page: php-config.1 /vagrant/php-7.4.23/build/shtool install -c ext/phar/phar.phar /home/vagrant/codes/php74/bin/phar.phar ln -s -f phar.phar /home/vagrant/codes/php74/bin/phar Installing PDO headers: /home/vagrant/codes/php74/include/php/ext/pdo/ // 安装 php73 # tar -zxvf php-src-php-7.3.30.tar.gz # cd php-src-php-7.3.30 # autoconf # ./configure --prefix=/home/vagrant/codes/php73 --enable-fpm --enable-debug Installing shared extensions: /home/vagrant/codes/php73/lib/php/extensions/debug-non-zts-20180731/ Installing PHP CLI binary: /home/vagrant/codes/php73/bin/ Installing PHP CLI man page: /home/vagrant/codes/php73/php/man/man1/ Installing PHP FPM binary: /home/vagrant/codes/php73/sbin/ Installing PHP FPM defconfig: /home/vagrant/codes/php73/etc/ Installing PHP FPM man page: /home/vagrant/codes/php73/php/man/man8/ Installing PHP FPM status page: /home/vagrant/codes/php73/php/php/fpm/ Installing phpdbg binary: /home/vagrant/codes/php73/bin/ Installing phpdbg man page: /home/vagrant/codes/php73/php/man/man1/ Installing PHP CGI ","date":"2021-09-12","objectID":"/posts/php-src-learning1/:2:0","tags":["PHP"],"title":"PHP 源码学习一","uri":"/posts/php-src-learning1/"},{"categories":["PHP"],"content":"基准测试 $ sudo -s // php80 基准测试 # /home/vagrant/codes/php80/bin/php /vagrant/php-8.0.10/Zend/bench.php simple 0.042 simplecall 0.018 simpleucall 0.076 simpleudcall 0.090 mandel 0.401 mandel2 0.356 ackermann(7) 0.100 ary(50000) 0.019 ary2(50000) 0.021 ary3(2000) 0.213 fibo(30) 0.312 hash1(50000) 0.051 hash2(500) 0.054 heapsort(20000) 0.109 matrix(20) 0.119 nestedloop(12) 0.085 sieve(30) 0.080 strcat(200000) 0.029 ------------------------ Total 2.174 # /home/vagrant/codes/php80/bin/php /vagrant/php-8.0.10/Zend/micro_bench.php empty_loop 0.076 func() 0.284 0.208 undef_func() 0.350 0.274 int_func() 0.113 0.037 $x = self::$x 0.344 0.268 self::$x = 0 0.270 0.194 isset(self::$x) 0.354 0.278 empty(self::$x) 0.363 0.287 $x = Foo::$x 0.279 0.203 Foo::$x = 0 0.198 0.122 isset(Foo::$x) 0.263 0.186 empty(Foo::$x) 0.282 0.206 self::f() 0.383 0.307 Foo::f() 0.345 0.269 $x = $this-\u003ex 0.488 0.412 $this-\u003ex = 0 0.223 0.147 $this-\u003ex += 2 0.511 0.435 ++$this-\u003ex 0.340 0.264 --$this-\u003ex 0.350 0.274 $this-\u003ex++ 0.369 0.293 $this-\u003ex-- 0.333 0.256 isset($this-\u003ex) 0.732 0.656 empty($this-\u003ex) 0.347 0.270 $this-\u003ef() 0.325 0.249 $x = Foo::TEST 0.411 0.335 new Foo() 1.083 1.007 $x = TEST 0.208 0.132 $x = $_GET 0.390 0.314 $x = $GLOBALS['v'] 0.624 0.548 $x = $hash['v'] 0.475 0.399 $x = $str[0] 0.294 0.218 $x = $a ?: null 0.491 0.415 $x = $f ?: tmp 0.437 0.361 $x = $f ? $f : $a 0.351 0.275 $x = $f ? $f : tmp 0.312 0.236 ------------------------ Total 12.997 // php74 基准测试 # /home/vagrant/codes/php74/bin/php /vagrant/php-7.4.23/Zend/bench.php simple 0.068 simplecall 0.032 simpleucall 0.073 simpleudcall 0.087 mandel 0.429 mandel2 0.374 ackermann(7) 0.098 ary(50000) 0.019 ary2(50000) 0.021 ary3(2000) 0.211 fibo(30) 0.326 hash1(50000) 0.051 hash2(500) 0.057 heapsort(20000) 0.109 matrix(20) 0.134 nestedloop(12) 0.122 sieve(30) 0.070 strcat(200000) 0.021 ------------------------ Total 2.303 # /home/vagrant/codes/php74/bin/php /vagrant/php-7.4.23/Zend/micro_bench.php empty_loop 0.081 func() 0.346 0.265 undef_func() 0.478 0.397 int_func() 0.174 0.093 $x = self::$x 0.406 0.325 self::$x = 0 0.314 0.234 isset(self::$x) 0.411 0.330 empty(self::$x) 0.420 0.339 $x = Foo::$x 0.305 0.224 Foo::$x = 0 0.229 0.148 isset(Foo::$x) 0.304 0.223 empty(Foo::$x) 0.318 0.237 self::f() 0.461 0.381 Foo::f() 0.436 0.355 $x = $this-\u003ex 0.277 0.196 $this-\u003ex = 0 0.220 0.139 $this-\u003ex += 2 0.413 0.333 ++$this-\u003ex 0.327 0.247 --$this-\u003ex 0.335 0.255 $this-\u003ex++ 0.351 0.270 $this-\u003ex-- 0.350 0.269 isset($this-\u003ex) 0.407 0.326 empty($this-\u003ex) 0.438 0.358 $this-\u003ef() 0.429 0.349 $x = Foo::TEST 0.428 0.347 new Foo() 1.193 1.113 $x = TEST 0.252 0.171 $x = $_GET 0.509 0.429 $x = $GLOBALS['v'] 0.876 0.795 $x = $hash['v'] 0.539 0.459 $x = $str[0] 0.361 0.280 $x = $a ?: null 0.435 0.354 $x = $f ?: tmp 0.392 0.312 $x = $f ? $f : $a 0.384 0.303 $x = $f ? $f : tmp 0.360 0.280 ------------------------ Total 13.961 // php73 基准测试 # /home/vagrant/codes/php73/bin/php /vagrant/php-7.3.30/Zend/bench.php simple 0.075 simplecall 0.025 simpleucall 0.118 simpleudcall 0.099 mandel 0.512 mandel2 0.540 ackermann(7) 0.135 ary(50000) 0.022 ary2(50000) 0.032 ary3(2000) 0.310 fibo(30) 0.460 hash1(50000) 0.068 hash2(500) 0.068 heapsort(20000) 0.160 matrix(20) 0.187 nestedloop(12) 0.147 sieve(30) 0.083 strcat(200000) 0.034 ------------------------ Total 3.077 # /home/vagrant/codes/php73/bin/php /vagrant/php-7.3.30/Zend/micro_bench.php empty_loop 0.084 func() 0.319 0.235 undef_func() 0.572 0.488 int_func() 0.151 0.067 $x = self::$x 0.319 0.235 self::$x = 0 0.306 0.222 isset(self::$x) 0.285 0.201 empty(self::$x) 0.300 0.216 $x = Foo::$x 0.243 0.159 Foo::$x = 0 0.246 0.162 isset(Foo::$x) 0.244 0.160 empty(Foo::$x) 0.254 0.170 self::f() 0.390 0.307 Foo::f() 0.353 0.269 $x = $this-\u003ex 0.262 0.178 $this-\u003ex = 0 0.206 0.122 $this-\u003ex += 2 0.365 0.281 ++$this-\u003ex 0.265 0.181 --$this-\u003ex 0.267 0.183 $this-\u003ex++ 0.290 0.206 $this-\u003ex-- 0.296 0.212 isset($this-\u003ex) 0.379 0.295 empty($this-\u003ex) 0.375 0.291 $this-\u003ef() 0.399 0.315 $x = Foo::TEST 0.406 0.322 new","date":"2021-09-12","objectID":"/posts/php-src-learning1/:3:0","tags":["PHP"],"title":"PHP 源码学习一","uri":"/posts/php-src-learning1/"},{"categories":["PHP"],"content":"新的特性 PHP 8 ","date":"2021-09-12","objectID":"/posts/php-src-learning1/:4:0","tags":["PHP"],"title":"PHP 源码学习一","uri":"/posts/php-src-learning1/"},{"categories":["PHP"],"content":"调试运行 ","date":"2021-09-12","objectID":"/posts/php-src-learning1/:5:0","tags":["PHP"],"title":"PHP 源码学习一","uri":"/posts/php-src-learning1/"},{"categories":["PHP"],"content":"常用的 GDB 命令 GDB Tutorial Command Description r Start running program until a breakpoint or end of program b fun Set a breakpoint at the begining of function fun b N Set a breakpoint at line number N of source file currently executing b file.c:N Set a breakpoint at line number N of file file.c d N Remove breakpoint number N info break List all breakpoints c Continues/Resumes running the program until the next breakpoint or end of program f Runs until the current function is finished s Runs the next line of the program s N Runs the next N lines of program n Like s, but it does not step into functions p var Prints the current value of the variable var set var=val Assign val value to the variable var bt Prints a stack trace q Quit from gdb ","date":"2021-09-12","objectID":"/posts/php-src-learning1/:5:1","tags":["PHP"],"title":"PHP 源码学习一","uri":"/posts/php-src-learning1/"},{"categories":["PHP"],"content":"源码中的定义 变量类型的定义： /* Regular data types: Must be in sync with zend_variables.c. */ #define IS_UNDEF 0 #define IS_NULL 1 #define IS_FALSE 2 #define IS_TRUE 3 #define IS_LONG 4 #define IS_DOUBLE 5 #define IS_STRING 6 #define IS_ARRAY 7 #define IS_OBJECT 8 #define IS_RESOURCE 9 #define IS_REFERENCE 10 #define IS_CONSTANT_AST 11 /* Constant expressions */ /* Fake types used only for type hinting. * These are allowed to overlap with the types below. */ #define IS_CALLABLE 12 #define IS_ITERABLE 13 #define IS_VOID 14 #define IS_STATIC 15 #define IS_MIXED 16 /* internal types */ #define IS_INDIRECT 12 #define IS_PTR 13 #define IS_ALIAS_PTR 14 #define _IS_ERROR 15 /* used for casts */ #define _IS_BOOL 17 #define _IS_NUMBER 18 _zend_value \u0026 _zend_sruct： typedef union _zend_value { zend_long lval; /* long value */ double dval; /* double value */ zend_refcounted *counted; zend_string *str; zend_array *arr; zend_object *obj; zend_resource *res; zend_reference *ref; zend_ast_ref *ast; zval *zv; void *ptr; zend_class_entry *ce; zend_function *func; struct { uint32_t w1; uint32_t w2; } ww; } zend_value; struct _zval_struct { zend_value value; /* value */ union { uint32_t type_info; struct { ZEND_ENDIAN_LOHI_3( zend_uchar type, /* active type */ zend_uchar type_flags, union { uint16_t extra; /* not further specified */ } u) } v; } u1; union { uint32_t next; /* hash collision chain */ uint32_t cache_slot; /* cache slot (for RECV_INIT) */ uint32_t opline_num; /* opline number (for FAST_CALL) */ uint32_t lineno; /* line number (for ast nodes) */ uint32_t num_args; /* arguments number for EX(This) */ uint32_t fe_pos; /* foreach position */ uint32_t fe_iter_idx; /* foreach iterator index */ uint32_t access_flags; /* class constant access flags */ uint32_t property_guard; /* single property guard */ uint32_t constant_flags; /* constant flags */ uint32_t extra; /* not further specified */ } u2; }; ","date":"2021-09-12","objectID":"/posts/php-src-learning1/:5:2","tags":["PHP"],"title":"PHP 源码学习一","uri":"/posts/php-src-learning1/"},{"categories":["PHP"],"content":"测试程序 \u003c?php $a = 1; echo $a; $b = 3.14; echo $b; $c = null; echo $c; $d = true; echo $d; $e = false; echo $e; $f = 'string'; echo $f; $g = [1, 2, 3]; echo $g; $h = new \\stdClass(); echo $h; # gdb /home/vagrant/codes/php80/bin/php (gdb) b ZEND_ECHO_SPEC_CV_HANDLER Breakpoint 1 at 0x5c96a8: file /vagrant/php-8.0.10/Zend/zend_vm_execute.h, line 37184. (gdb) r variables.php Starting program: /home/vagrant/codes/php80/bin/php variables.php [Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\". Breakpoint 1, ZEND_ECHO_SPEC_CV_HANDLER () at /vagrant/php-8.0.10/Zend/zend_vm_execute.h:37184 37184 SAVE_OPLINE(); 整型： (gdb) n 37185 z = EX_VAR(opline-\u003eop1.var); (gdb) n 37187 if (Z_TYPE_P(z) == IS_STRING) { (gdb) p z $1 = (zval *) 0x7ffff3814070 (gdb) p *z $2 = {value = {lval = 1, dval = 4.9406564584124654e-324, counted = 0x1, str = 0x1, arr = 0x1, obj = 0x1, res = 0x1, ref = 0x1, ast = 0x1, zv = 0x1, ptr = 0x1, ce = 0x1, func = 0x1, ww = {w1 = 1, w2 = 0}}, u1 = {type_info = 4, v = {type = 4 '\\004', type_flags = 0 '\\000', u = {extra = 0}}}, u2 = {next = 0, cache_slot = 0, opline_num = 0, lineno = 0, num_args = 0, fe_pos = 0, fe_iter_idx = 0, access_flags = 0, property_guard = 0, constant_flags = 0, extra = 0}} (gdb) 浮点型： (gdb) c Continuing. 1 Breakpoint 1, ZEND_ECHO_SPEC_CV_HANDLER () at /vagrant/php-8.0.10/Zend/zend_vm_execute.h:37184 37184 SAVE_OPLINE(); (gdb) n 37185 z = EX_VAR(opline-\u003eop1.var); (gdb) n 37187 if (Z_TYPE_P(z) == IS_STRING) { (gdb) p z $3 = (zval *) 0x7ffff3814080 (gdb) p *z $4 = {value = {lval = 4614253070214989087, dval = 3.1400000000000001, counted = 0x40091eb851eb851f, str = 0x40091eb851eb851f, arr = 0x40091eb851eb851f, obj = 0x40091eb851eb851f, res = 0x40091eb851eb851f, ref = 0x40091eb851eb851f, ast = 0x40091eb851eb851f, zv = 0x40091eb851eb851f, ptr = 0x40091eb851eb851f, ce = 0x40091eb851eb851f, func = 0x40091eb851eb851f, ww = {w1 = 1374389535, w2 = 1074339512}}, u1 = {type_info = 5, v = {type = 5 '\\005', type_flags = 0 '\\000', u = {extra = 0}}}, u2 = {next = 0, cache_slot = 0, opline_num = 0, lineno = 0, num_args = 0, fe_pos = 0, fe_iter_idx = 0, access_flags = 0, property_guard = 0, constant_flags = 0, extra = 0}} (gdb) NULL 型： (gdb) c Continuing. 3.14 Breakpoint 1, ZEND_ECHO_SPEC_CV_HANDLER () at /vagrant/php-8.0.10/Zend/zend_vm_execute.h:37184 37184 SAVE_OPLINE(); (gdb) n 37185 z = EX_VAR(opline-\u003eop1.var); (gdb) n 37187 if (Z_TYPE_P(z) == IS_STRING) { (gdb) p z $5 = (zval *) 0x7ffff3814090 (gdb) p *z $6 = {value = {lval = 2, dval = 9.8813129168249309e-324, counted = 0x2, str = 0x2, arr = 0x2, obj = 0x2, res = 0x2, ref = 0x2, ast = 0x2, zv = 0x2, ptr = 0x2, ce = 0x2, func = 0x2, ww = {w1 = 2, w2 = 0}}, u1 = {type_info = 1, v = {type = 1 '\\001', type_flags = 0 '\\000', u = {extra = 0}}}, u2 = {next = 0, cache_slot = 0, opline_num = 0, lineno = 0, num_args = 0, fe_pos = 0, fe_iter_idx = 0, access_flags = 0, property_guard = 0, constant_flags = 0, extra = 0}} (gdb) 布尔 TRUE 型： (gdb) c Continuing. Breakpoint 1, ZEND_ECHO_SPEC_CV_HANDLER () at /vagrant/php-8.0.10/Zend/zend_vm_execute.h:37184 37184 SAVE_OPLINE(); (gdb) n 37185 z = EX_VAR(opline-\u003eop1.var); (gdb) n 37187 if (Z_TYPE_P(z) == IS_STRING) { (gdb) p z $7 = (zval *) 0x7ffff38140a0 (gdb) p *z $8 = {value = {lval = 2, dval = 9.8813129168249309e-324, counted = 0x2, str = 0x2, arr = 0x2, obj = 0x2, res = 0x2, ref = 0x2, ast = 0x2, zv = 0x2, ptr = 0x2, ce = 0x2, func = 0x2, ww = {w1 = 2, w2 = 0}}, u1 = {type_info = 3, v = {type = 3 '\\003', type_flags = 0 '\\000', u = {extra = 0}}}, u2 = {next = 0, cache_slot = 0, opline_num = 0, lineno = 0, num_args = 0, fe_pos = 0, fe_iter_idx = 0, access_flags = 0, property_guard = 0, constant_flags = 0, extra = 0}} (gdb) 布尔 FALSE 型： (gdb) c Continuing. 1 Breakpoint 1, ZEND_ECHO_SPEC_CV_HANDLER () at /vagrant/php-8.0.10/Zend/zend_vm_execute.h:37184 37184 SAVE_OPLINE(); (gdb) n 37185 z = EX_VAR(opline-\u003eop1.var); (gdb) n 37187 if (Z_TYPE_P(z) == IS_STRING) { (gdb) p z $9 = ","date":"2021-09-12","objectID":"/posts/php-src-learning1/:5:3","tags":["PHP"],"title":"PHP 源码学习一","uri":"/posts/php-src-learning1/"},{"categories":["Go"],"content":"Go 中连接字符串的方法有很多种，其实掌握一两种较为高效的方法就足够了，其它权当看热闹。 Go 起步 Go 数据类型 Go 日期时间 Go 随机数 Go 单元测试 Go 基准测试 Go 其它测试 Go 正确姿势 Go 连接字符串 ","date":"2021-07-25","objectID":"/posts/go-concat-string/:0:0","tags":["Go"],"title":"Go 连接字符串","uri":"/posts/go-concat-string/"},{"categories":["Go"],"content":"几种连接方式 ","date":"2021-07-25","objectID":"/posts/go-concat-string/:1:0","tags":["Go"],"title":"Go 连接字符串","uri":"/posts/go-concat-string/"},{"categories":["Go"],"content":"Concat package hello import \"testing\" /* === RUN TestStringConcat /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:20: Hello World! --- PASS: TestStringConcat (0.00s) PASS ok example.com/hello 0.014s */ func TestStringConcat(t *testing.T) { s := \"Hello \" s += \"World!\" t.Log(s) } ","date":"2021-07-25","objectID":"/posts/go-concat-string/:1:1","tags":["Go"],"title":"Go 连接字符串","uri":"/posts/go-concat-string/"},{"categories":["Go"],"content":"Sprintf package hello import ( \"fmt\" \"testing\" ) /* === RUN TestStringSprintf /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:18: Hello World! --- PASS: TestStringSprintf (0.00s) PASS ok example.com/hello 0.010s */ func TestStringSprintf(t *testing.T) { s := \"Hello \" s = fmt.Sprintf(\"%s%s\", s, \"World!\") t.Log(s) } ","date":"2021-07-25","objectID":"/posts/go-concat-string/:1:2","tags":["Go"],"title":"Go 连接字符串","uri":"/posts/go-concat-string/"},{"categories":["Go"],"content":"Join package hello import ( \"strings\" \"testing\" ) /* === RUN TestStringJoin /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:18: Hello World! --- PASS: TestStringJoin (0.00s) PASS ok example.com/hello 0.008s */ func TestStringJoin(t *testing.T) { s := \"Hello \" s = strings.Join([]string{s, \"World!\"}, \"\") t.Log(s) } ","date":"2021-07-25","objectID":"/posts/go-concat-string/:1:3","tags":["Go"],"title":"Go 连接字符串","uri":"/posts/go-concat-string/"},{"categories":["Go"],"content":"Buffer Write package hello import ( \"bytes\" \"testing\" ) /* === RUN TestBufferWrite /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:20: Hello World! --- PASS: TestBufferWrite (0.00s) PASS ok example.com/hello 0.010s */ func TestBufferWrite(t *testing.T) { buf := new(bytes.Buffer) buf.WriteString(\"Hello \") buf.WriteString(\"World!\") s := buf.String() t.Log(s) } ","date":"2021-07-25","objectID":"/posts/go-concat-string/:1:4","tags":["Go"],"title":"Go 连接字符串","uri":"/posts/go-concat-string/"},{"categories":["Go"],"content":"Bytes Append package hello import \"testing\" /* === RUN TestBytesAppend /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:18: Hello --- PASS: TestBytesAppend (0.00s) PASS ok example.com/hello */ func TestBytesAppend(t *testing.T) { var b []byte s := \"Hello \" b = append(b, \"World!\"...) t.Log(string(s)) } ","date":"2021-07-25","objectID":"/posts/go-concat-string/:1:5","tags":["Go"],"title":"Go 连接字符串","uri":"/posts/go-concat-string/"},{"categories":["Go"],"content":"Copy package hello import \"testing\" /* === RUN TestStringCopy /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:18: Hello World! --- PASS: TestStringCopy (0.00s) PASS ok example.com/hello (cached) */ func TestStringCopy(t *testing.T) { b := make([]byte, 0) b = mycopy(b, \"Hello \") b = mycopy(b, \"World!\") t.Log(string(b)) } func mycopy(b []byte, s string) []byte { n := len(b) if n+len(s) \u003e cap(b) { t := make([]byte, 2*cap(b)+len(s)) copy(t, b) b = t } b = b[0 : n+len(s)] copy(b[n:], s) return b } ","date":"2021-07-25","objectID":"/posts/go-concat-string/:1:6","tags":["Go"],"title":"Go 连接字符串","uri":"/posts/go-concat-string/"},{"categories":["Go"],"content":"String Builder package hello import ( \"strings\" \"testing\" ) /* === RUN TestStringBuilder /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:20: Hello World! --- PASS: TestStringBuilder (0.00s) PASS ok example.com/hello 0.013s */ func TestStringBuilder(t *testing.T) { var builder strings.Builder builder.WriteString(\"Hello \") builder.WriteString(\"World!\") s := builder.String() t.Log(s) } ","date":"2021-07-25","objectID":"/posts/go-concat-string/:1:7","tags":["Go"],"title":"Go 连接字符串","uri":"/posts/go-concat-string/"},{"categories":["Go"],"content":"性能测试 package hello import ( \"bytes\" \"fmt\" \"strings\" \"testing\" ) const ( src = \"Hello World!\" cnt = 10000 ) var expected = strings.Repeat(src, cnt) func mycopy(b []byte, s string) []byte { n := len(b) if n+len(s) \u003e cap(b) { t := make([]byte, 2*cap(b)+len(s)) copy(t, b) b = t } b = b[0 : n+len(s)] copy(b[n:], s) return b } func BenchmarkStringConcat(b *testing.B) { var res string for n := 0; n \u003c b.N; n++ { var str string for i := 0; i \u003c cnt; i++ { str += src } res = str } b.StopTimer() if res != expected { b.Errorf(\"got=%s, want=%s\", string(res), expected) } } func BenchmarkStringSprintf(b *testing.B) { var res string for n := 0; n \u003c b.N; n++ { var str string for i := 0; i \u003c cnt; i++ { str = fmt.Sprintf(\"%s%s\", str, src) } res = str } b.StopTimer() if res != expected { b.Errorf(\"got=%s, want=%s\", string(res), expected) } } func BenchmarkStringJoin(b *testing.B) { var res string for n := 0; n \u003c b.N; n++ { var str string for i := 0; i \u003c cnt; i++ { str = strings.Join([]string{str, src}, \"\") } res = str } b.StopTimer() if res != expected { b.Errorf(\"got=%s, want=%s\", res, expected) } } func BenchmarkBufferWrite(b *testing.B) { var res string for n := 0; n \u003c b.N; n++ { buf := new(bytes.Buffer) for i := 0; i \u003c cnt; i++ { buf.WriteString(src) } res = buf.String() } b.StopTimer() if res != expected { b.Errorf(\"got=%s, want=%s\", string(res), expected) } } func BenchmarkBytesAppend(b *testing.B) { var res string for n := 0; n \u003c b.N; n++ { var bytes []byte for i := 0; i \u003c cnt; i++ { bytes = append(bytes, src...) } res = string(bytes) } b.StopTimer() if res != expected { b.Errorf(\"got=%s, want=%s\", string(res), expected) } } func BenchmarkStringCopy(b *testing.B) { var res string for n := 0; n \u003c b.N; n++ { data := make([]byte, 0, 64) // same size as bootstrap array of bytes.Buffer for i := 0; i \u003c cnt; i++ { data = mycopy(data, src) } res = string(data) } b.StopTimer() if res != expected { b.Errorf(\"got=%s, want=%s\", string(res), expected) } } func BenchmarkStringCopy2(b *testing.B) { var res string for n := 0; n \u003c b.N; n++ { b := make([]byte, 0, 64) // same size as bootstrap array of bytes.Buffer for i := 0; i \u003c cnt; i++ { l := len(b) if l+len(src) \u003e cap(b) { t := make([]byte, 2*cap(b)+len(src)) copy(t, b) b = t } b = b[0 : l+len(src)] copy(b[l:], src) } res = string(b) } b.StopTimer() if res != expected { b.Errorf(\"got=%s, want=%s\", string(res), expected) } } func BenchmarkStringBuilder(b *testing.B) { var res string for n := 0; n \u003c b.N; n++ { var builder strings.Builder for i := 0; i \u003c cnt; i++ { builder.WriteString(src) } res = builder.String() } b.StopTimer() if res != expected { b.Errorf(\"got=%s, want=%s\", string(res), expected) } } 在我本机的测试结果如下，对于这个测试结果我表示也没想到，但是我已经知道以后该怎么做了： $ go test -v -benchmem -run=^$ -bench '^(BenchmarkStringConcat|BenchmarkStringSprintf|BenchmarkStringJoin|BenchmarkBufferWrite|BenchmarkBytesAppend|BenchmarkStringCopy|BenchmarkStringCopy2|BenchmarkStringBuilder)$' example.com/hello goos: darwin goarch: amd64 pkg: example.com/hello cpu: Intel(R) Core(TM) i5-5257U CPU @ 2.70GHz BenchmarkStringConcat BenchmarkStringConcat-4 8 131090517 ns/op 632845121 B/op 10004 allocs/op BenchmarkStringSprintf BenchmarkStringSprintf-4 4 295268326 ns/op 1075561174 B/op 29686 allocs/op BenchmarkStringJoin BenchmarkStringJoin-4 6 287073860 ns/op 632845282 B/op 10008 allocs/op BenchmarkBufferWrite BenchmarkBufferWrite-4 5631 210591 ns/op 441616 B/op 13 allocs/op BenchmarkBytesAppend BenchmarkBytesAppend-4 7819 152409 ns/op 628720 B/op 25 allocs/op BenchmarkStringCopy BenchmarkStringCopy-4 8820 118761 ns/op 441552 B/op 12 allocs/op BenchmarkStringCopy2 BenchmarkStringCopy2-4 9598 135427 ns/op 441552 B/op 12 allocs/op BenchmarkStringBuilder BenchmarkStringBuilder-4 7729 156815 ns/op 505840 B/op 24 allocs/op PASS ok example.com/hello 17.512s ","date":"2021-07-25","objectID":"/posts/go-concat-string/:2:0","tags":["Go"],"title":"Go 连接字符串","uri":"/posts/go-concat-string/"},{"categories":["Go"],"content":"在编写 Go 代码之时，我跟很多新手一样踩了不少坑，感觉非常有必要将那些踩过的坑记录下来以避免下次犯错。很多人说 Go 简单易学，上手容易，可惜我不是那些很多人中的一个，天资愚钝如此，我只能反复学习了。 Go 起步 Go 数据类型 Go 日期时间 Go 随机数 Go 单元测试 Go 基准测试 Go 其它测试 Go 正确姿势 Go 连接字符串 ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:0:0","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"常见错误与纠正 ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:1:0","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"assignment to entry in nil map package hello import ( \"testing\" ) /* === RUN TestWrongUsage --- FAIL: TestWrongUsage (0.00s) panic: assignment to entry in nil map [recovered] panic: assignment to entry in nil map */ func TestWrongUsage(t *testing.T) { var m map[string]float64 m[\"pi\"] = 3.1416 t.Log(m) } /* === RUN TestRightUsage /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:39: map[pi:3.1416] --- PASS: TestRightUsage (0.00s) PASS ok example.com/hello 0.012s */ func TestRightUsage(t *testing.T) { m := make(map[string]float64) m[\"pi\"] = 3.1416 t.Log(m) } ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:1:1","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"invalid memory address or nil pointer dereference package hello import ( \"math\" \"testing\" ) type Point struct { X, Y float64 } func (p *Point) Abs() float64 { return math.Sqrt(p.X*p.X + p.Y*p.Y) } /* === RUN TestWrongUsage --- FAIL: TestWrongUsage (0.00s) panic: runtime error: invalid memory address or nil pointer dereference [recovered] panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x110a643] */ func TestWrongUsage(t *testing.T) { var p *Point t.Log(p.Abs()) } /* === RUN TestRightUsage /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:26: \u0026{0 0} /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:29: 0 --- PASS: TestRightUsage (0.00s) PASS ok example.com/hello 0.009s */ func TestRightUsage(t *testing.T) { var p *Point = new(Point) t.Log(p) var q Point // has zero value Point{X:0, Y:0} t.Log(q.Abs()) } ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:1:2","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"array won’t change package hello import ( \"testing\" ) func Foo(a [2]int) { a[0] = 8 } func Bar(a []int) { if len(a) \u003e 0 { a[0] = 8 } } /* === RUN TestWrongUsage /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:20: [1 2] --- PASS: TestWrongUsage (0.00s) PASS ok example.com/hello 0.008s */ func TestWrongUsage(t *testing.T) { a := [2]int{1, 2} Foo(a) t.Log(a) } /* === RUN TestRightUsage /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:40: [8 2] --- PASS: TestRightUsage (0.00s) PASS ok example.com/hello 0.013s */ func TestRightUsage(t *testing.T) { a := []int{1, 2} Bar(a) t.Log(a) } ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:1:3","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"shadowed variables package hello import ( \"testing\" ) /* === RUN TestWrongUsage /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:20: 0 --- PASS: TestWrongUsage (0.00s) PASS ok example.com/hello 0.007s */ func TestWrongUsage(t *testing.T) { n := 0 if true { n := 1 n++ } t.Log(n) } /* === RUN TestRightUsage /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:36: 2 --- PASS: TestRightUsage (0.00s) PASS ok example.com/hello (cached) */ func TestRightUsage(t *testing.T) { n := 0 if true { n = 1 n++ } t.Log(n) } 安装 Go Tools： $ go get -u golang.org/x/tools/... 检测隐藏变量： $ go vet -vettool=$(which shadow) -strict # example.com/hello ./hello_test.go:17:3: declaration of \"n\" shadows declaration at line 15 ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:1:4","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"immutable strings package hello import ( \"testing\" ) /* # example.com/hello [example.com/hello.test] /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:16:7: cannot assign to s[0] (strings are immutable) FAIL example.com/hello [build failed] */ func TestWrongUsage(t *testing.T) { s := \"hello\" s[0] = 'H' // IDE 会提示：cannot assign to s[0] (value of type byte)compilerUnassignableOperand t.Log(s) } /* === RUN TestRightUsage /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:29: Hello --- PASS: TestRightUsage (0.00s) PASS ok example.com/hello 0.007s */ func TestRightUsage(t *testing.T) { buf := []rune(\"hello\") buf[0] = 'H' s := string(buf) t.Log(s) } ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:1:5","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"characters add package hello import ( \"fmt\" \"strconv\" \"testing\" ) /* === RUN TestWrongUsage /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:13: Ta /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:14: 181 --- PASS: TestWrongUsage (0.00s) PASS ok example.com/hello 0.014s */ func TestWrongUsage(t *testing.T) { t.Log(\"T\" + \"a\") t.Log('T' + 'a') } /* === RUN TestRightUsage /Users/xxx/Codes/go/src/github.com/imajinyun/hello/hello_test.go:30: 84a /Users/xxx/Codes/go/src/github.com/imajinyun/hello/hello_test.go:31: Ta --- PASS: TestRightUsage (0.00s) PASS ok example.com/hello 0.012s PASS ok example.com/hello 0.012s */ func TestRightUsage(t *testing.T) { t.Log(strconv.Itoa(84) + string('a')) t.Log(fmt.Sprintf(\"%c%c\", 84, 'a')) } ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:1:6","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"trim string package hello import ( \"strings\" \"testing\" ) /* === RUN TestWrongUsage /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:17: true /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:18: true --- PASS: TestWrongUsage (0.00s) PASS ok example.com/hello 0.009s */ func TestWrongUsage(t *testing.T) { t.Log(\" hello world \" == strings.TrimRight(\" hello world \", \"hello\")) t.Log(\"hello world\" == strings.TrimLeft(\"hello world\", \"world\")) } /* === RUN TestRightUsage /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:33: true /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:34: true /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:35: true /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:36: true --- PASS: TestRightUsage (0.00s) PASS ok example.com/hello 0.008s */ func TestRightUsage(t *testing.T) { t.Log(\"hello\" == strings.TrimSpace(\" hello \")) t.Log(\"hello \\t world\" == strings.TrimSpace(\" \\t hello \\t world \\t \")) t.Log(\" world\" == strings.TrimPrefix(\"hello world\", \"hello\")) t.Log(\"hello \" == strings.TrimSuffix(\"hello world\", \"world\")) } ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:1:7","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"elements copy package hello import ( \"testing\" ) /* === RUN TestWrongUsage /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:18: dst: [] --- PASS: TestWrongUsage (0.00s) PASS ok example.com/hello (cached) */ func TestWrongUsage(t *testing.T) { var src, dst []int src = []int{1, 2, 3} copy(dst, src) // Copy elements to dst from src. t.Log(\"dst:\", dst) } /* === RUN TestRightUsage /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:36: dst: [1 2 3] (copied 3 numbers) --- PASS: TestRightUsage (0.00s) PASS ok example.com/hello 0.008s */ func TestRightUsage(t *testing.T) { var src, dst []int src = []int{1, 2, 3} dst = make([]int, len(src)) n := copy(dst, src) t.Log(\"dst:\", dst, \"(copied\", n, \"numbers)\") } /* === RUN TestRight2Usage /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:40: dst: [1 2 3] --- PASS: TestRight2Usage (0.00s) PASS ok example.com/hello 0.016s */ func TestRight2Usage(t *testing.T) { var src, dst []int src = []int{1, 2, 3} dst = append(dst, src...) t.Log(\"dst:\", dst) } ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:1:8","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"can’t change entries in range loop package hello import \"testing\" /* === RUN TestWrongUsage /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:21: [1 1 1] --- PASS: TestWrongUsage (0.00s) PASS ok example.com/hello 0.011s */ func TestWrongUsage(t *testing.T) { s := []int{1, 1, 1} for _, n := range s { n += 1 } t.Log(s) } /* === RUN TestRightUsage /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:36: [2 2 2] --- PASS: TestRightUsage (0.00s) PASS ok example.com/hello 0.013s */ func TestRightUsage(t *testing.T) { s := []int{1, 1, 1} for i := range s { s[i] += 1 } t.Log(s) } ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:1:9","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"iteration variable doesn’t see change in range loop package hello import ( \"fmt\" \"testing\" ) /* === RUN TestWrongUsage x = 0 x = 0 /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:21: [0 8] --- PASS: TestWrongUsage (0.00s) PASS ok example.com/hello 0.013s */ func TestWrongUsage(t *testing.T) { var a [2]int for _, x := range a { fmt.Println(\"x =\", x) a[1] = 8 } t.Log(a) } /* === RUN TestRightUsage x = 0 x = 8 /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:39: [0 8] --- PASS: TestRightUsage (0.00s) PASS ok example.com/hello 0.009s */ func TestRightUsage(t *testing.T) { var a [2]int for _, x := range a[:] { fmt.Println(\"x =\", x) a[1] = 8 } t.Log(a) } ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:1:10","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"iteration variables and closures package hello import ( \"sync\" \"testing\" ) /* === RUN TestWrongUsage /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:23: 5 /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:23: 5 /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:23: 5 /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:23: 5 /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:23: 5 --- PASS: TestWrongUsage (0.00s) PASS ok example.com/hello 0.013s */ func TestWrongUsage(t *testing.T) { var wg sync.WaitGroup var n int = 5 wg.Add(n) for i := 0; i \u003c n; i++ { go func() { t.Log(i) wg.Done() }() } wg.Wait() } /* === RUN TestRightUsage /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:47: 4 /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:47: 1 /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:47: 0 /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:47: 3 /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:47: 2 --- PASS: TestRightUsage (0.00s) PASS ok example.com/hello 0.009s */ func TestRightUsage(t *testing.T) { var wg sync.WaitGroup var n int = 5 wg.Add(n) for i := 0; i \u003c n; i++ { x := i // Create a unique variable for each closure. go func() { t.Log(x) wg.Done() }() } wg.Wait() } ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:1:11","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"常用的一些写法 ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:2:0","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"检查字典中是否存在指定键 package hello import \"testing\" /* === RUN TestIfKeyExistInMap /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:12: value: 100 --- PASS: TestIfKeyExistInMap (0.00s) PASS ok example.com/hello 0.009s */ func TestIfKeyExistInMap(t *testing.T) { dict := map[string]int{\"foo\": 100, \"bar\": 200} value, ok := dict[\"foo\"] if ok { t.Log(\"value:\", value) } else { t.Log(\"Key not found\") } } ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:2:1","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"连接两个切片 package hello import \"testing\" /* === RUN TestCombineTwoSlice /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:17: [1 2 3 4] --- PASS: TestCombineTwoSlice (0.00s) PASS ok example.com/hello 0.007s */ func TestCombineTwoSlice(t *testing.T) { slice := append([]int{1, 2}, []int{3, 4}...) t.Log(slice) } ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:2:2","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"将 byte 转换为 string 标准转换： package hello import \"testing\" /* === RUN TestByteToStr /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:16: [72 101 108 108 111 32 87 111 114 108 100] Hello World --- PASS: TestByteToStr (0.00s) PASS ok example.com/hello 0.007s */ func TestByteToStr(t *testing.T) { b := []byte(\"Hello World\") t.Logf(\"\\n%v\\n%v\", b, string(b)) } 强制转换： package hello import ( \"reflect\" \"testing\" \"unsafe\" ) /* === RUN TestByteToString /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:19: [72 101 108 108 111 32 87 111 114 108 100] \"Hello World\" Hello World --- PASS: TestByteToString (0.00s) PASS ok example.com/hello 0.008s */ func TestByteToString(t *testing.T) { b := []byte{72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100} s := byteToString(b) t.Logf(\"\\n%v\\n%#v\\n%v\", b, s, s) } func byteToString(b []byte) (s string) { data := make([]byte, len(b)) for i, c := range b { data[i] = c } hdr := (*reflect.StringHeader)(unsafe.Pointer(\u0026s)) hdr.Data = uintptr(unsafe.Pointer(\u0026data[0])) hdr.Len = len(b) return s } ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:2:3","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"将 string 转换为 byte 标准转换： package hello import \"testing\" /* === RUN TestStringToByte /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:18: Hello World [72 101 108 108 111 32 87 111 114 108 100] --- PASS: TestStringToByte (0.00s) PASS ok example.com/hello 0.008s */ func TestStringToByte(t *testing.T) { s := \"Hello World\" t.Logf(\"\\n%v\\n%v\", s, []byte(s)) } 强制转换： package hello import \"testing\" /* === RUN TestStringToByte /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:19: Hello World [72 101 108 108 111 32 87 111 114 108 100] --- PASS: TestStringToByte (0.00s) PASS ok example.com/hello 0.012s */ func TestStringToByte(t *testing.T) { s := \"Hello World\" b := stringToByte(s) t.Logf(\"\\n%v\\n%v\\n\", s, b) } func stringToByte(s string) []byte { b := make([]byte, len(s)) for i := 0; i \u003c len(s); i++ { c := s[i] b[i] = c } return b } ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:2:4","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"将 rune 转换为 string package hello import \"testing\" /* === RUN TestRuneToString /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:8: r = [72 101 108 108 111 32 87 111 114 108 100 33] r = [U+0048 U+0065 U+006C U+006C U+006F U+0020 U+0057 U+006F U+0072 U+006C U+0064 U+0021] s = Hello World! --- PASS: TestRuneToString (0.00s) PASS ok example.com/hello */ func TestRuneToString(t *testing.T) { r := []rune{72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33} s := string(r) t.Logf(\"\\nr = %v\\nr = %U\\ns = %v\", r, r, s) } ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:2:5","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"将 string 转换为 rune package hello import \"testing\" /* === RUN TestStringToRune /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:14: s = Hello World! r = [72 101 108 108 111 32 87 111 114 108 100 33] r = [U+0048 U+0065 U+006C U+006C U+006F U+0020 U+0057 U+006F U+0072 U+006C U+0064 U+0021] --- PASS: TestStringToRune (0.00s) PASS ok example.com/hello 0.016s */ func TestStringToRune(t *testing.T) { s := \"Hello World!\" r := []rune(s) t.Logf(\"\\ns = %v\\nr = %v\\nr = %U\", s, r, r) } ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:2:6","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"结构体比较 package hello import ( \"reflect\" \"testing\" ) type Devloper struct { Name string Lang string Age int } /* === RUN TestCompareStruct /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:18: false /Users/xxx/Codes/go/src/github.com/xxx/hello/hello_test.go:19: true --- PASS: TestCompareStruct (0.00s) PASS ok example.com/hello */ func TestCompareStruct(t *testing.T) { d1 := Devloper{\"Foo\", \"Java\", 26} d2 := Devloper{\"Bar\", \"Go\", 28} d3 := Devloper{\"Bar\", \"Go\", 28} t.Log(reflect.DeepEqual(d1, d2)) t.Log(reflect.DeepEqual(d2, d3)) } ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:2:7","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"How to Properly Hash and Salt Passwords in Golang Using Bcrypt Download the golang bcrypt library using go get golang.org/x/crypto/bcrypt. 功能代码： package example import ( \"golang.org/x/crypto/bcrypt\" ) // Hash password using the bcrypt hashing algorithm. func genHashPassword(password string) (string, error) { // Convert password string to byte slice. var passwordBytes = []byte(password) // Hash password with bcrypt's min cost. hashedPasswordBytes, err := bcrypt.GenerateFromPassword(passwordBytes, bcrypt.DefaultCost) return string(hashedPasswordBytes), err } // Check if two passwords match using Bcrypt's CompareHashAndPassword // which return nil on success and an error on failure. func cmpHashPassword(hashedPassword, currPassword string) bool { err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(currPassword)) return err == nil } 测试代码： package example import ( \"testing\" ) func TestHashPassword(t *testing.T) { var hashPassword, err = genHashPassword(\"mypassword\") if err != nil { t.Error(\"Failed to hash password\") return } t.Logf(\"Get hashed password: %v\", hashPassword) } func TestCmpHashPassword(t *testing.T) { var currPassword = \"mypassword\" var hashPassword, err = genHashPassword(currPassword) if err != nil { t.Error(\"Failed to hash password\") return } t.Logf(\"Get hashed password: %v\", hashPassword) t.Logf(\"Cmp hashed password: %v\", cmpHashPassword(hashPassword, currPassword)) } /* Running tool: /opt/homebrew/bin/go test -timeout 30s -coverprofile=/var/folders/nk/dtkbhx993b57y5kt49l4qsb40000gn/T/vscode-goOPwBHl/go-code-cover example -v === RUN TestHashPassword /Users/xxx/Codes/github.com/xxx/inotes/vendor/acme_test.go:14: Get hashed password: $2a$10$L/tY5of7u9FOw94y7PrKR.3irKHtBattazT/JzypTcg5e25Kzu3vG --- PASS: TestHashPassword (0.07s) === RUN TestCmpHashPassword /Users/xxx/Codes/github.com/xxx/inotes/vendor/acme_test.go:24: Get hashed password: $2a$10$b2fKxBL0FQm0/EOE6nLFe.h6X/Xc367jrqwLyTGonS5Ot78AG6V62 /Users/xxx/Codes/github.com/xxx/inotes/vendor/acme_test.go:25: Cmp hashed password: true --- PASS: TestCmpHashPassword (0.14s) PASS coverage: 100.0% of statements ok example 0.531s coverage: 100.0% of statements */ ","date":"2021-07-24","objectID":"/posts/go-correct-posture/:2:8","tags":["Go"],"title":"Go 正确姿势","uri":"/posts/go-correct-posture/"},{"categories":["Go"],"content":"Go 的 testing 包除了测试，还提供了运行并验证示例的功能。一方面是文档的效果，是关于某个功能的使用例子；另一方面，可以被当做测试运行。 Go 起步 Go 数据类型 Go 日期时间 Go 随机数 Go 单元测试 Go 基准测试 Go 其它测试 Go 正确姿势 Go 连接字符串 ","date":"2021-07-22","objectID":"/posts/go-other-test/:0:0","tags":["Go"],"title":"Go 其它测试","uri":"/posts/go-other-test/"},{"categories":["Go"],"content":"示例测试 ","date":"2021-07-22","objectID":"/posts/go-other-test/:1:0","tags":["Go"],"title":"Go 其它测试","uri":"/posts/go-other-test/"},{"categories":["Go"],"content":"示例测试函数格式 Go 语言通过大量的命名约定来简化工具的复杂度，规范代码的风格。对示例函数的命名有如下约定： 包级别的示例函数，直接命名为：func Example() { ... }； 函数 F 的示例，命名为：func ExampleF() { ... }； 类型 T 的示例，命名为：func ExampleT() { ... }； 类型 T 上的方法 M 的示例，命名为：func ExampleT_M() { ... }； 有时，我们想要给 包/类型/函数/方法 提供多个示例，可以通过在示例函数名称后附加一个不同的后缀来实现，但这种后缀必须以小写字母开头，如： func Example_suffix() { ... } func ExampleF_suffix() { ... } func ExampleT_suffix() { ... } func ExampleT_M_suffix() { ... } ","date":"2021-07-22","objectID":"/posts/go-other-test/:1:1","tags":["Go"],"title":"Go 其它测试","uri":"/posts/go-other-test/"},{"categories":["Go"],"content":"示例测试实例 示例一 package hello import ( \"fmt\" \"strings\" ) func ExampleToUpper() { fmt.Println(strings.ToUpper(\"foo\")) // Output: FOO } func ExampleToUpperFail() { fmt.Println(strings.ToUpper(\"bar\")) // Output: Bar } $ go test -v -timeout 30s -run '^(ExampleToUpper|ExampleToUpperFail)$' example.com/hello === RUN ExampleToUpper --- PASS: ExampleToUpper (0.00s) === RUN ExampleToUpperFail --- FAIL: ExampleToUpperFail (0.00s) got: BAR want: Bar FAIL FAIL example.com/hello 0.008s 示例二 package hello import ( \"fmt\" \"sort\" ) type Person struct { Name string Age int } func (p Person) String() string { return fmt.Sprintf(\"%s: %d\", p.Name, p.Age) } // ByAge implements sort.Interface for []Person based on the Age field. type SortByAge []Person func (a SortByAge) Len() int { return len(a) } func (a SortByAge) Swap(i, j int) { a[i], a[j] = a[j], a[i] } func (a SortByAge) Less(i, j int) bool { return a[i].Age \u003c a[j].Age } func Example() { people := []Person{ {\"Jack\", 31}, {\"John\", 42}, {\"Acme\", 17}, {\"Pony\", 26}, {\"Wise\", 33}, } fmt.Println(people) sort.Sort(SortByAge(people)) fmt.Println(people) // Output: // [Jack: 31 John: 42 Acme: 17 Pony: 26 Wise: 33] // [Acme: 17 Pony: 26 Jack: 31 Wise: 33 John: 42] } $ go test -v -timeout 30s example.com/hello === RUN Example --- PASS: Example (0.00s) PASS ok example.com/hello 0.007s ","date":"2021-07-22","objectID":"/posts/go-other-test/:1:2","tags":["Go"],"title":"Go 其它测试","uri":"/posts/go-other-test/"},{"categories":["Go"],"content":"实例三 package hello import ( \"go/ast\" \"go/parser\" \"log\" ) func ExampleAST() { expr, err := parser.ParseExpr(\"9 / (2 + 1)\") if err != nil { log.Fatal(err) } ast.Print(nil, expr) // Output: 0 *ast.BinaryExpr { // 1 . X: *ast.BasicLit { // 2 . . ValuePos: 1 // 3 . . Kind: INT // 4 . . Value: \"9\" // 5 . } // 6 . OpPos: 3 // 7 . Op: / // 8 . Y: *ast.ParenExpr { // 9 . . Lparen: 5 // 10 . . X: *ast.BinaryExpr { // 11 . . . X: *ast.BasicLit { // 12 . . . . ValuePos: 6 // 13 . . . . Kind: INT // 14 . . . . Value: \"2\" // 15 . . . } // 16 . . . OpPos: 8 // 17 . . . Op: + // 18 . . . Y: *ast.BasicLit { // 19 . . . . ValuePos: 10 // 20 . . . . Kind: INT // 21 . . . . Value: \"1\" // 22 . . . } // 23 . . } // 24 . . Rparen: 11 // 25 . } // 26 } } $ go test -v -timeout 30s -run '^ExampleAST$' example.com/hello === RUN ExampleAST --- PASS: ExampleAST (0.00s) PASS ok example.com/hello (cached) ","date":"2021-07-22","objectID":"/posts/go-other-test/:1:3","tags":["Go"],"title":"Go 其它测试","uri":"/posts/go-other-test/"},{"categories":["Go"],"content":"主函数测试 警告 注意：在 TestMain 函数的最后，应该使用 m.Run 的返回值作为参数去调用 os.Exit。 在写测试时，有时需要在测试之前或之后进行额外的设置（setup）或拆卸（teardown）；有时，测试还需要控制在主线程上运行的代码。为了支持这些需求，testing 包提供了 TestMain 函数（附上 官方 TestMain 使用姿势）： func TestMain(m *testing.M) package hello import ( \"log\" \"os\" \"testing\" ) func TestMain(m *testing.M) { log.Println(\"Do stuff BEFORE the tests!\") exit := m.Run() log.Println(\"Do stuff AFTER the tests!\") os.Exit(exit) } func TestA(t *testing.T) { log.Println(\"TestA running\") } func TestB(t *testing.T) { log.Println(\"TestB running\") } $ go test -v -timeout 30s -run '^(TestMain|TestA|TestB)$' example.com/hello 2021/07/22 20:07:25 Do stuff BEFORE the tests! === RUN TestA 2021/07/22 20:07:25 TestA running --- PASS: TestA (0.00s) === RUN TestB 2021/07/22 20:07:25 TestB running --- PASS: TestB (0.00s) PASS 2021/07/22 20:07:25 Do stuff AFTER the tests! ok example.com/hello (cached) ","date":"2021-07-22","objectID":"/posts/go-other-test/:2:0","tags":["Go"],"title":"Go 其它测试","uri":"/posts/go-other-test/"},{"categories":["Go"],"content":"Go 语言标准库内置的 testing 测试框架提供了基准测试（benchmark）的能力，能让我们很容易地对某一段代码进行性能测试。基准测试主要是通过测试 CPU 和 Memory 的效率问题，来评估被测试代码的性能，进而找到更好的解决方案。 Go 起步 Go 数据类型 Go 日期时间 Go 随机数 Go 单元测试 Go 基准测试 Go 其它测试 Go 正确姿势 Go 连接字符串 ","date":"2021-07-17","objectID":"/posts/go-benchmark-test/:0:0","tags":["Go"],"title":"Go 基准测试","uri":"/posts/go-benchmark-test/"},{"categories":["Go"],"content":"基准测试命令 ","date":"2021-07-17","objectID":"/posts/go-benchmark-test/:1:0","tags":["Go"],"title":"Go 基准测试","uri":"/posts/go-benchmark-test/"},{"categories":["Go"],"content":"基准测试命令实例 $ go test -v -bench=. $ go test -v -bench='Fib$' -benchtime=5s . $ go test -v -bench='Fib$' -benchtime=1000x . $ go test -v -bench='Fib$' -benchtime=1000x -count=5 . $ go test -v -bench='Fib$' -cpu=2,4,8,16,32,64,128,256,512,1024,2048,4096 . $ go test -v -benchmem -run=^$ -bench '^(BenchmarkFib)$' example.com/hello . ","date":"2021-07-17","objectID":"/posts/go-benchmark-test/:1:1","tags":["Go"],"title":"Go 基准测试","uri":"/posts/go-benchmark-test/"},{"categories":["Go"],"content":"基准测试函数 ","date":"2021-07-17","objectID":"/posts/go-benchmark-test/:2:0","tags":["Go"],"title":"Go 基准测试","uri":"/posts/go-benchmark-test/"},{"categories":["Go"],"content":"基准测试函数格式 警告 BenchmarkXxx 中 Xxx 可以是任何字母数字字符串，但是第一个字母不能是小写字母。 func BenchmarkXxx(t *testing.T) // 以下命名是合法的 func Benchmark123(t *testing.T) func Benchmark中国(t *testing.T) func BenchmarkMac(t *testing.T) 基准测试用例函数需要以 Benchmark 为前缀： 前缀用例文件不会参与正常源码编译，不会被包含到可执行文件中； 基准测试用例使用 go test -bench=. 指令来执行，没有也不需要 main() 作为函数入口。所有以 _test 结尾的源码内以 Benchmark 开头的函数会被自动执行； 基准测试函数的参数 b *test.B 必须传入，否则会报函数签名错误，即：wrong signature for BenchmarkXxx, must be: func BenchmarkXxx(b \\*testing.B)； 要编写一个新的基准测试，需要创建一个名称以 _test.go 结尾的文件，该文件包含 BenchmarkXxx 函数。 ","date":"2021-07-17","objectID":"/posts/go-benchmark-test/:2:1","tags":["Go"],"title":"Go 基准测试","uri":"/posts/go-benchmark-test/"},{"categories":["Go"],"content":"基准测试用例 ","date":"2021-07-17","objectID":"/posts/go-benchmark-test/:3:0","tags":["Go"],"title":"Go 基准测试","uri":"/posts/go-benchmark-test/"},{"categories":["Go"],"content":"简单基准测试 待测代码： package hello func Fib(n int) int { switch n { case 0: return 0 case 1: return 1 default: return Fib(n-1) + Fib(n-2) } } 测试代码： package hello import ( \"testing\" ) func BenchmarkFib(b *testing.B) { for n := 0; n \u003c b.N; n++ { Fib(15) } } $ go test -v -benchmem -run=^$ -bench '^(BenchmarkFib)$' example.com/hello goos: darwin goarch: amd64 pkg: example.com/hello cpu: Intel(R) Core(TM) i5-5257U CPU @ 2.70GHz BenchmarkFib BenchmarkFib-4 238396 4793 ns/op 0 B/op 0 allocs/op PASS ok example.com/hello 2.190s 基准函数会运行目标代码 b.N 次。在基准执行期间，程序会自动调整 b.N 直到基准测试函数持续足够长的时间。b.N 对于每个用例都是不一样的。b.N 从 1 开始，如果该用例能够在 1s 内完成，b.N 的值便会增加，再次执行。b.N 的值大概以 1, 2, 3, 5, 10, 20, 30, 50, 100 这样的序列递增，越到后面，增加得越快。 ","date":"2021-07-17","objectID":"/posts/go-benchmark-test/:3:1","tags":["Go"],"title":"Go 基准测试","uri":"/posts/go-benchmark-test/"},{"categories":["Go"],"content":"提升准确度 Benchmark 的默认时间是 1s，那么我们可以使用 -benchtime 指定为 5s： // 沿用实例一的代码做基准测试 $ go test -v -benchtime=5s -benchmem -run=^$ -bench '^(BenchmarkFib)$' example.com/hello goos: darwin goarch: amd64 pkg: example.com/hello cpu: Intel(R) Core(TM) i5-5257U CPU @ 2.70GHz BenchmarkFib BenchmarkFib-4 1290742 4529 ns/op 0 B/op 0 allocs/op PASS ok example.com/hello 10.375s 实际执行的时间是 10.375s，比 benchtime 的 5s 要长，测试用例编译、执行、销毁等是需要时间的。 Benchmark 的 -benchtime 的值除了是时间外，还可以是具体的次数： // 沿用实例一的代码做基准测试 $ go test -v -benchtime=50x -benchmem -run=^$ -bench '^(BenchmarkFib)$' example.com/hello goos: darwin goarch: amd64 pkg: example.com/hello cpu: Intel(R) Core(TM) i5-5257U CPU @ 2.70GHz BenchmarkFib BenchmarkFib-4 50 4556 ns/op 0 B/op 0 allocs/op PASS ok example.com/hello 0.010s Benchmark 的 -count 参数可以用来设置轮数： // 沿用实例一的代码做基准测试 $ go test -v -count=3 -benchmem -run=^$ -bench '^(BenchmarkFib)$' example.com/hello goos: darwin goarch: amd64 pkg: example.com/hello cpu: Intel(R) Core(TM) i5-5257U CPU @ 2.70GHz BenchmarkFib BenchmarkFib-4 226737 4483 ns/op 0 B/op 0 allocs/op BenchmarkFib-4 226686 5645 ns/op 0 B/op 0 allocs/op BenchmarkFib-4 226284 4485 ns/op 0 B/op 0 allocs/op PASS ok example.com/hello 3.489s ","date":"2021-07-17","objectID":"/posts/go-benchmark-test/:3:2","tags":["Go"],"title":"Go 基准测试","uri":"/posts/go-benchmark-test/"},{"categories":["Go"],"content":"内存分配情况 package hello import ( \"math/rand\" \"testing\" \"time\" ) func genWithCap(n int) []int { rand.Seed(time.Now().UnixNano()) nums := make([]int, 0, n) for i := 0; i \u003c n; i++ { nums = append(nums, rand.Int()) } return nums } func genWithoutCap(n int) []int { rand.Seed(time.Now().UnixNano()) nums := make([]int, 0) for i := 0; i \u003c n; i++ { nums = append(nums, rand.Int()) } return nums } func BenchmarkGenWithCap(b *testing.B) { for n := 0; n \u003c b.N; n++ { genWithCap(1000000) } } func BenchmarkGenWithoutCap(b *testing.B) { for n := 0; n \u003c b.N; n++ { genWithoutCap(1000000) } } $ go test -v -benchmem -run=^$ -bench '^BenchmarkGen' example.com/hello goos: darwin goarch: amd64 pkg: example.com/hello cpu: Intel(R) Core(TM) i5-5257U CPU @ 2.70GHz BenchmarkGenWithCap BenchmarkGenWithCap-4 40 28733419 ns/op 8003585 B/op 1 allocs/op BenchmarkGenWithoutCap BenchmarkGenWithoutCap-4 26 38608707 ns/op 45188404 B/op 40 allocs/op PASS ok example.com/hello 3.167s 可以看到 genWithoutCap 分配的内存空间是 genWithCap 的 45188404/8003585 ≈ 5.6 倍，设置了切片容量，内存只分配一次，而不设置切片容量，内存分配了 40 次。 ","date":"2021-07-17","objectID":"/posts/go-benchmark-test/:3:3","tags":["Go"],"title":"Go 基准测试","uri":"/posts/go-benchmark-test/"},{"categories":["Go"],"content":"测试输入规模 package hello import ( \"math/rand\" \"testing\" \"time\" ) func gen(n int) []int { rand.Seed(time.Now().UnixNano()) nums := make([]int, 0) for i := 0; i \u003c n; i++ { nums = append(nums, rand.Int()) } return nums } func helper(i int, b *testing.B) { for n := 0; n \u003c b.N; n++ { gen(i) } } func BenchmarkGen10(b *testing.B) { helper(10, b) } func BenchmarkGen100(b *testing.B) { helper(100, b) } func BenchmarkGen1000(b *testing.B) { helper(1000, b) } func BenchmarkGen10000(b *testing.B) { helper(10000, b) } func BenchmarkGen100000(b *testing.B) { helper(100000, b) } func BenchmarkGen1000000(b *testing.B) { helper(1000000, b) } $ go test -v -benchmem -run=^$ -bench '^(BenchmarkGen10|BenchmarkGen100|BenchmarkGen1000|BenchmarkGen10000|BenchmarkGen100000|BenchmarkGen1000000)$' example.com/hello goos: darwin goarch: amd64 pkg: example.com/hello cpu: Intel(R) Core(TM) i5-5257U CPU @ 2.70GHz BenchmarkGen10 BenchmarkGen10-4 85984 12604 ns/op 248 B/op 5 allocs/op BenchmarkGen100 BenchmarkGen100-4 89773 14911 ns/op 2040 B/op 8 allocs/op BenchmarkGen1000 BenchmarkGen1000-4 28988 38968 ns/op 16376 B/op 11 allocs/op BenchmarkGen10000 BenchmarkGen10000-4 3843 326670 ns/op 386296 B/op 20 allocs/op BenchmarkGen100000 BenchmarkGen100000-4 357 3429826 ns/op 4654346 B/op 30 allocs/op BenchmarkGen1000000 BenchmarkGen1000000-4 37 35700196 ns/op 45188381 B/op 40 allocs/op PASS ok example.com/hello 9.278s 通过测试结果可以发现，输入变为原来的 10 倍，函数每次调用的时长也差不多是原来的 10 倍，这说明复杂度是线性的。 ","date":"2021-07-17","objectID":"/posts/go-benchmark-test/:3:4","tags":["Go"],"title":"Go 基准测试","uri":"/posts/go-benchmark-test/"},{"categories":["Go"],"content":"B 类型 ","date":"2021-07-17","objectID":"/posts/go-benchmark-test/:4:0","tags":["Go"],"title":"Go 基准测试","uri":"/posts/go-benchmark-test/"},{"categories":["Go"],"content":"报告方法 基准测试中，传递给基准测试函数的参数是 *testing.B 类型。B 是传递给基准测试函数的一种类型，它用于管理基准测试的计时行为，并指示应该迭代地运行测试多少次。 跟单元测试一样，基准测试会在执行的过程中积累日志，并在测试完毕时将日志转储到标准错误。但跟单元测试不一样的是，为了避免基准测试的结果受到日志打印操作的影响，基准测试总是会把日志打印出来。 B 类型中的报告方法使用方式和 T 类型是一样的，一般来说，基准测试中也不需要使用，毕竟主要是测性能。 ","date":"2021-07-17","objectID":"/posts/go-benchmark-test/:4:1","tags":["Go"],"title":"Go 基准测试","uri":"/posts/go-benchmark-test/"},{"categories":["Go"],"content":"计时方法 StartTimer：开始对测试进行计时。该方法会在基准测试开始时自动被调用，我们也可以在调用 StopTimer 之后恢复计时； StopTimer：停止对测试进行计时。当你需要执行一些复杂的初始化操作，并且你不想对这些操作进行测量时，就可以使用这个方法来暂时地停止计时； ResetTimer：对已经逝去的基准测试时间以及内存分配计数器进行清零。对于正在运行中的计时器，这个方法不会产生任何效果； package hello import ( \"testing\" \"time\" ) func fib(n int) int { if n == 0 || n == 1 { return n } return fib(n-2) + fib(n-1) } func BenchmarkFib(b *testing.B) { time.Sleep(time.Second * 3) // b.ResetTimer() for n := 0; n \u003c b.N; n++ { fib(30) } } // 注释 b.ResetTimer() $ go test -v -benchtime=50x -benchmem -run=^$ -bench '^(BenchmarkFib)$' example.com/hello goos: darwin goarch: amd64 pkg: example.com/hello cpu: Intel(R) Core(TM) i5-5257U CPU @ 2.70GHz BenchmarkFib BenchmarkFib-4 50 66575387 ns/op 1 B/op 0 allocs/op PASS ok example.com/hello 6.358s // 打开 b.ResetTimer() $ go test -v -benchtime=50x -benchmem -run=^$ -bench '^(BenchmarkFib)$' example.com/hello goos: darwin goarch: amd64 pkg: example.com/hello cpu: Intel(R) Core(TM) i5-5257U CPU @ 2.70GHz BenchmarkFib BenchmarkFib-4 50 6419112 ns/op 0 B/op 0 allocs/op PASS ok example.com/hello 6.344s 可以看到，当注释 b.ResetTimer() 后，每次执行需要 66575387/1000000000=0.06657539≈0.067 秒；当打开 b.ResetTimer() 后，每次执行需要 6419112/1000000000=0.00641911≈0.006 秒。所以使用 b.ResetTimer() 重置定时器后快了 0.067/0.006=11.16666667≈11 倍。 在某些情况下，每次调用函数前后需要一些准备工作和清理工作，可以使用 StopTimer 暂停计时以及使用 StartTimer 开始计时： package hello import ( \"math/rand\" \"testing\" \"time\" ) func genWithCap(n int) []int { rand.Seed(time.Now().UnixNano()) nums := make([]int, 0, n) for i := 0; i \u003c n; i++ { nums = append(nums, rand.Int()) } return nums } func bubbleSort(nums []int) { for i := 0; i \u003c len(nums); i++ { for j := 1; j \u003c len(nums)-i; j++ { if nums[j] \u003c nums[j-1] { nums[j], nums[j-1] = nums[j-1], nums[j] } } } } func BenchmarkBubbleSort(b *testing.B) { for n := 0; n \u003c b.N; n++ { b.StopTimer() nums := genWithCap(10000) b.StartTimer() bubbleSort(nums) } } $ go test -v -benchtime=50x -benchmem -run=^$ -bench '^(BenchmarkBubbleSort)$' example.com/hello goos: darwin goarch: amd64 pkg: example.com/hello cpu: Intel(R) Core(TM) i5-5257U CPU @ 2.70GHz BenchmarkBubbleSort BenchmarkBubbleSort-4 50 124283402 ns/op 0 B/op 0 allocs/op PASS ok example.com/hello 6.380s ","date":"2021-07-17","objectID":"/posts/go-benchmark-test/:4:2","tags":["Go"],"title":"Go 基准测试","uri":"/posts/go-benchmark-test/"},{"categories":["Go"],"content":"并行执行 通过 RunParallel 方法能够并行地执行给定的基准测试。RunParallel 会创建出多个 goroutine，并将 b.N 分配给这些 goroutine 执行，其中 goroutine 数量的默认值为 GOMAXPROCS。用户如果想要增加非 CPU 受限（non-CPU-bound）基准测试的并行性，那么可以在 RunParallel 之前调用 SetParallelism（如：SetParallelism(2)，则 goroutine 数量为 2*GOMAXPROCS）。RunParallel 通常会与 -cpu 标志一同使用。 package hello import ( \"bytes\" \"testing\" \"text/template\" ) func BenchmarkTemplateParallel(b *testing.B) { tpl := template.Must(template.New(\"test\").Parse(\"Hello, {{.}}!\")) // RunParallel will create GOMAXPROCS goroutines and distribute work among them. b.RunParallel(func(pb *testing.PB) { // Each goroutine has its own bytes.Buffer. var buf bytes.Buffer for pb.Next() { // The loop body is executed b.N times total across all goroutines. buf.Reset() tpl.Execute(\u0026buf, \"World\") } }) } $ go test -v -benchmem -run=^$ -bench '^(BenchmarkTemplateParallel)$' example.com/hello goos: darwin goarch: amd64 pkg: example.com/hello cpu: Intel(R) Core(TM) i5-5257U CPU @ 2.70GHz BenchmarkTemplateParallel BenchmarkTemplateParallel-4 7044910 198.2 ns/op 48 B/op 1 allocs/op PASS ok example.com/hello 1.581s package hello import ( \"testing\" ) func BenchmarkSelectNonblock(b *testing.B) { ch1 := make(chan int) ch2 := make(chan int) ch3 := make(chan int, 1) ch4 := make(chan int, 1) b.RunParallel(func(pb *testing.PB) { for pb.Next() { select { case \u003c-ch1: default: } select { case ch2 \u003c- 0: default: } select { case \u003c-ch3: default: } select { case ch4 \u003c- 0: default: } } }) } $ go test -v -benchmem -run=^$ -bench '^(BenchmarkSelectNonblock)$' example.com/hello goos: darwin goarch: amd64 pkg: example.com/hello cpu: Intel(R) Core(TM) i5-5257U CPU @ 2.70GHz BenchmarkSelectNonblock BenchmarkSelectNonblock-4 96872894 13.02 ns/op 0 B/op 0 allocs/op PASS ok example.com/hello 1.286s ","date":"2021-07-17","objectID":"/posts/go-benchmark-test/:4:3","tags":["Go"],"title":"Go 基准测试","uri":"/posts/go-benchmark-test/"},{"categories":["Go"],"content":"内存统计 ReportAllocs 方法用于打开当前基准测试的内存统计功能， 与 go test 使用 -benchmem 标志类似，但 ReportAllocs 只影响那些调用了该函数的基准测试。 package hello import ( \"bytes\" \"html/template\" \"testing\" ) func BenchmarkTmplExucte(b *testing.B) { b.ReportAllocs() tpl := template.Must(template.New(\"test\").Parse(\"Hello, {{.}}!\")) b.RunParallel(func(pb *testing.PB) { // Each goroutine has its own bytes.Buffer. var buf bytes.Buffer for pb.Next() { // The loop body is executed b.N times total across all goroutines. buf.Reset() tpl.Execute(\u0026buf, \"World\") } }) } $ go test -v -benchmem -run=^$ -bench '^(BenchmarkTplExucte)$' example.com/hello goos: darwin goarch: amd64 pkg: example.com/hello cpu: Intel(R) Core(TM) i5-5257U CPU @ 2.70GHz BenchmarkTmplExucte BenchmarkTmplExucte-4 1525129 875.6 ns/op 240 B/op 8 allocs/op PASS ok example.com/hello 2.152s ","date":"2021-07-17","objectID":"/posts/go-benchmark-test/:4:4","tags":["Go"],"title":"Go 基准测试","uri":"/posts/go-benchmark-test/"},{"categories":["Go"],"content":"基准测试结果 // 循环执行了 238396 次，每次循环花费 4793 ns BenchmarkFib-4 238396 4793 ns/op 0 B/op 0 allocs/op BenchmarkFib-4：BenchmarkFib-8 中的 -8 即 GOMAXPROCS，默认等于 CPU 核数。可以通过 -cpu 参数改变 GOMAXPROCS，-cpu 支持传入一个列表作为参数（比如：-cpu=2,4,8,...）； 238396：基准测试的迭代总次数 b.N； 4793 ns/op：平均每次迭代所消耗的纳秒数； 0 B/op：平均每次迭代内存所分配的字节数； 0 allocs/op：平均每次迭代的内存分配次数； 在 testing 包中的 BenchmarkResult 类型保存了基准测试的结果，定义如下： // BenchmarkResult contains the results of a benchmark run. type BenchmarkResult struct { N int // The number of iterations. T time.Duration // The total time taken. Bytes int64 // Bytes processed in one iteration. MemAllocs uint64 // The total number of memory allocations. MemBytes uint64 // The total number of bytes allocated. // Extra records additional metrics reported by ReportMetric. Extra map[string]float64 } package main import ( \"bytes\" \"fmt\" \"testing\" \"text/template\" ) func main() { res := testing.Benchmark(func(b *testing.B) { tpl := template.Must(template.New(\"test\").Parse(\"Hello, {{.}}!\")) b.RunParallel(func(pb *testing.PB) { var buf bytes.Buffer for pb.Next() { buf.Reset() tpl.Execute(\u0026buf, \"World\") } }) }) fmt.Printf(\"%8d\\t%10d ns/op\\t%10d B/op\\t%10d allocs/op\\n\", res.N, res.NsPerOp(), res.AllocedBytesPerOp(), res.AllocsPerOp(), ) } $ go run main.go 5220064 196 ns/op 48 B/op 1 allocs/op ","date":"2021-07-17","objectID":"/posts/go-benchmark-test/:4:5","tags":["Go"],"title":"Go 基准测试","uri":"/posts/go-benchmark-test/"},{"categories":["Go"],"content":"Go 语言从开发初期就注意了测试用例的编写。特别是静态语言，由于调试没有动态语言那么方便，所以能最快最方便地编写一个测试用例就显得非常重要了。 Go 起步 Go 数据类型 Go 日期时间 Go 随机数 Go 单元测试 Go 基准测试 Go 其它测试 Go 正确姿势 Go 连接字符串 ","date":"2021-07-16","objectID":"/posts/go-unit-test/:0:0","tags":["Go"],"title":"Go 单元测试","uri":"/posts/go-unit-test/"},{"categories":["Go"],"content":"单元测试命令 ","date":"2021-07-16","objectID":"/posts/go-unit-test/:1:0","tags":["Go"],"title":"Go 单元测试","uri":"/posts/go-unit-test/"},{"categories":["Go"],"content":"单元测试命令实例 $ go test -v hello.go hello_test.go $ go test -v . $ go test -v -run TestFib . $ go test -v -timeout 30s -run '^TestFib$' example.com/hello . ","date":"2021-07-16","objectID":"/posts/go-unit-test/:1:1","tags":["Go"],"title":"Go 单元测试","uri":"/posts/go-unit-test/"},{"categories":["Go"],"content":"一些测试选项 -bench regexp：执行相应的 benchmarks，例如：-bench=.； -cover：开户测试覆盖率； -run regexp：只运行 regexp 匹配的函数，例如：-run=Array 仅执行包含有 Array 开头的函数； -v：显示测试的详细命令； $ go test -v -timeout 10s -run '^TestFib$' example.com/hello . === RUN TestFib --- PASS: TestFib (0.00s) PASS ok example.com/hello 0.006s ","date":"2021-07-16","objectID":"/posts/go-unit-test/:1:2","tags":["Go"],"title":"Go 单元测试","uri":"/posts/go-unit-test/"},{"categories":["Go"],"content":"单元测试函数 ","date":"2021-07-16","objectID":"/posts/go-unit-test/:2:0","tags":["Go"],"title":"Go 单元测试","uri":"/posts/go-unit-test/"},{"categories":["Go"],"content":"单元测试函数格式 警告 TestXxx 中 Xxx 可以是任何字母数字字符串，但是第一个字母不能是小写字母。 单元测试源码文件可以由多个测试用例组成，每个测试用例函数需要以 Test 为前缀： 前缀用例文件不会参与正常源码编译，不会被包含到可执行文件中； 单元测试用例使用 go test 指令来执行，没有也不需要 main() 作为函数入口。所有以 _test 结尾的源码内以 Test 开头的函数会被自动执行； 单元测试函数的参数 t *test.T 必须传入，否则会报函数签名错误，即：wrong signature for TestXxx, must be: func TestXxx(t *testing.T)； func TestXxx(t *testing.T) // 以下命名是合法的 func Test123(t *testing.T) func Test中国(t *testing.T) func TestMac(t *testing.T) 要编写一个新的测试套件，需要创建一个名称以 _test.go 结尾的文件，该文件包含 TestXxx 函数。 ","date":"2021-07-16","objectID":"/posts/go-unit-test/:2:1","tags":["Go"],"title":"Go 单元测试","uri":"/posts/go-unit-test/"},{"categories":["Go"],"content":"各种不同测试用例 TestSomething(t *testing.T)：基本测试用例； BenchmarkSomething(b *testing.B)：基准测试用例； ExampleSomething()：控制台测试用例； TestMain(m *testing.M)：主函数测试用例； ","date":"2021-07-16","objectID":"/posts/go-unit-test/:2:2","tags":["Go"],"title":"Go 单元测试","uri":"/posts/go-unit-test/"},{"categories":["Go"],"content":"单元测试用例 ","date":"2021-07-16","objectID":"/posts/go-unit-test/:3:0","tags":["Go"],"title":"Go 单元测试","uri":"/posts/go-unit-test/"},{"categories":["Go"],"content":"基本测试实例 待测代码： func Fib(n int) int { if n \u003c 2 { return n } return Fib(n-1) + Fib(n-2) } 测试代码： func TestFib(t *testing.T) { var ( in = 7 expect = 13 ) actual := Fib(in) if actual != expect { t.Errorf(\"Fib(%d) = %d; want %d\", in, actual, expect) } } $ go test -v -timeout 30s -run '^TestFib$' example.com/hello === RUN TestFib --- PASS: TestFib (0.00s) PASS ok example.com/hello 0.007s ","date":"2021-07-16","objectID":"/posts/go-unit-test/:3:1","tags":["Go"],"title":"Go 单元测试","uri":"/posts/go-unit-test/"},{"categories":["Go"],"content":"表驱动测试实例 Table-Driven 的测试方式在 Go 的源码中司空见惯，比如：time_test.go。 func TestFib(t *testing.T) { var fibTests = []struct { in int expect int }{ {1, 1}, {2, 1}, {3, 2}, {4, 3}, {5, 5}, {6, 8}, {7, 13}, {8, 21}, {9, 34}, } for i, tt := range fibTests { actual := Fib(tt.in) if actual != tt.expect { t.Errorf(\"#%d: Fib(%d) = %d; want %d\", i, tt.in, actual, tt.expect) } } } $ go test -v -timeout 30s -run '^TestFib$' example.com/hello === RUN TestFib --- PASS: TestFib (0.00s) PASS ok example.com/hello (cached) ","date":"2021-07-16","objectID":"/posts/go-unit-test/:3:2","tags":["Go"],"title":"Go 单元测试","uri":"/posts/go-unit-test/"},{"categories":["Go"],"content":"子测试实例 待测代码： package hello func Add(x, y int) int { return x + y } 测试代码： package hello import ( \"testing\" ) func TestAll(t *testing.T) { var positiveNumberTests = []struct { name string x, y, expected int }{ {\"positive number\", 1, 1, 2}, {\"negative number\", 0, 9, 9}, {\"zero number\", 0, 0, 0}, } for _, tt := range positiveNumberTests { t.Run(tt.name, func(t *testing.T) { if actual := Add(tt.x, tt.y); actual != tt.expected { t.Errorf(\"Add(%d, %d) = %d, want %d\", tt.x, tt.y, actual, tt.expected) } }) } } $ go test -v -timeout 30s -run '^TestAll$' example.com/hello === RUN TestAll === RUN TestAll/positive_number === RUN TestAll/negative_number === RUN TestAll/zero_number --- PASS: TestAll (0.00s) --- PASS: TestAll/positive_number (0.00s) --- PASS: TestAll/negative_number (0.00s) --- PASS: TestAll/zero_number (0.00s) PASS ok example.com/hello 0.013s ","date":"2021-07-16","objectID":"/posts/go-unit-test/:3:3","tags":["Go"],"title":"Go 单元测试","uri":"/posts/go-unit-test/"},{"categories":["Go"],"content":"模仿测试实例 待测代码： package hello import \"context\" type API interface { FetchPostByID(ctx context.Context, id int) (*APIPost, error) } type APIPost struct { ID int `json:\"id\"` UserID int `json:\"user_id\"` Title string `json:\"title\"` Body string `json:\"body\"` } 测试代码： package hello import ( \"context\" \"encoding/json\" \"fmt\" \"io\" \"net/http\" \"reflect\" \"strings\" \"testing\" \"time\" ) type APIMock struct{} func (a *APIMock) FetchPostByID(ctx context.Context, id int) (*APIPost, error) { return nil, fmt.Errorf(http.StatusText(http.StatusNotFound)) } type HTTPClient interface { Do(*http.Request) (*http.Response, error) } type HTTPClientMock struct { DoFunc func(*http.Request) (*http.Response, error) } func (h HTTPClientMock) Do(r *http.Request) (*http.Response, error) { return h.DoFunc(r) } func New(client HTTPClient, baseURL string, timeout time.Duration) API { return \u0026v1{ c: client, baseURL: baseURL, timeout: timeout, } } type v1 struct { c HTTPClient baseURL string timeout time.Duration } func (v v1) FetchPostByID(ctx context.Context, id int) (*APIPost, error) { u := fmt.Sprintf(\"%s/posts/%d\", v.baseURL, id) ctx, cancel := context.WithTimeout(ctx, v.timeout) defer cancel() req, err := http.NewRequestWithContext(ctx, http.MethodGet, u, nil) if err != nil { return nil, err } res, err := v.c.Do(req) if err != nil { return nil, err } defer res.Body.Close() if res.StatusCode != http.StatusOK { return nil, fmt.Errorf(http.StatusText(res.StatusCode)) } var result *APIPost return result, json.NewDecoder(res.Body).Decode(\u0026result) } var ( client = \u0026HTTPClientMock{} api = New(client, \"\", 0) ) func TestV1FetchPostByID(t *testing.T) { postTests := []struct { Body string StatusCode int Result *APIPost Error error }{ { Body: `{\"id\":1,\"user_id\":1001,\"title\":\"title 1\",\"body\":\"body 1\"}`, StatusCode: 200, Result: \u0026APIPost{1, 1001, \"title 1\", \"body 1\"}, Error: nil, }, { Body: `{\"id\":2,\"user_id\":1002,\"title\":\"title 2\",\"body\":\"body 2\"}`, StatusCode: 200, Result: \u0026APIPost{2, 1002, \"title 2\", \"body 2\"}, Error: nil, }, { Body: ``, StatusCode: http.StatusBadRequest, Result: nil, Error: fmt.Errorf(http.StatusText(http.StatusBadRequest)), }, { Body: ``, StatusCode: http.StatusBadRequest, Result: nil, Error: fmt.Errorf(http.StatusText(http.StatusBadRequest)), }, } for _, tt := range postTests { client.DoFunc = func(r *http.Request) (*http.Response, error) { return \u0026http.Response{ Body: io.NopCloser(strings.NewReader(tt.Body)), StatusCode: tt.StatusCode, }, nil } post, err := api.FetchPostByID(context.Background(), 0) if err != nil \u0026\u0026 err.Error() != tt.Error.Error() { t.Fatalf(\"want %v, got %v\", tt.Error, err) } if !reflect.DeepEqual(post, tt.Result) { t.Fatalf(\"want %v, got %v\", tt.Result, post) } } } $ go test -v -timeout 30s -run '^TestV1FetchPostByID$' example.com/hello === RUN TestV1FetchPostByID --- PASS: TestV1FetchPostByID (0.00s) PASS ok example.com/hello (cached) ","date":"2021-07-16","objectID":"/posts/go-unit-test/:3:4","tags":["Go"],"title":"Go 单元测试","uri":"/posts/go-unit-test/"},{"categories":["Go"],"content":"T 类型 单元测试中，传递给测试函数的参数是 *testing.T 类型。它用于管理测试状态并支持格式化测试日志。测试日志会在执行测试的过程中不断累积，并在测试完成时转储至标准输出。 ","date":"2021-07-16","objectID":"/posts/go-unit-test/:4:0","tags":["Go"],"title":"Go 单元测试","uri":"/posts/go-unit-test/"},{"categories":["Go"],"content":"报告方法 错误方法 package hello import ( \"errors\" \"testing\" ) func TestErrorFunc(t *testing.T) { t.Error(\"this is a error\") t.Errorf(\"%s\", errors.New(\"this is a error\")) } $ go test -v -timeout 30s -run '^TestErrorFunc$' example.com/hello === RUN TestErrorFunc /Users/majinyun/Codes/go/src/github.com/imajinyun/hello/hello_test.go:9: this is a error /Users/majinyun/Codes/go/src/github.com/imajinyun/hello/hello_test.go:10: this is a error --- FAIL: TestErrorFunc (0.00s) FAIL FAIL example.com/hello 0.010s 失败方法 package hello import ( \"testing\" ) func TestFailFunc(t *testing.T) { t.Fail() t.Log(\"see if this line will output #1\") } func TestFailedFunc(t *testing.T) { t.Failed() t.Log(\"see if this line will output #2\") } func TestFailNowFunc(t *testing.T) { t.FailNow() t.Log(\"see if this line will output #3\") } $ go test -v -timeout 30s -run '^(TestFailFunc|TestFailedFunc|TestFailNowFunc)$' example.com/hello === RUN TestFailFunc /Users/majinyun/Codes/go/src/github.com/imajinyun/hello/hello_test.go:9: see if this line will output #1 --- FAIL: TestFailFunc (0.00s) === RUN TestFailedFunc /Users/majinyun/Codes/go/src/github.com/imajinyun/hello/hello_test.go:14: see if this line will output #2 --- PASS: TestFailedFunc (0.00s) === RUN TestFailNowFunc --- FAIL: TestFailNowFunc (0.00s) FAIL FAIL example.com/hello 0.008s 致命方法 package hello import ( \"errors\" \"testing\" ) func TestFatalFunc(t *testing.T) { t.Fatal(\"this is a fatal\") t.Log(\"see if this line will output #1\") } func TestFatalfFunc(t *testing.T) { t.Fatalf(\"%s\", errors.New(\"this is a fatal\")) t.Log(\"see if this line will output #2\") } $ go test -v -timeout 30s -run '^(TestFatalFunc|TestFatalfFunc)$' example.com/hello === RUN TestFatalFunc /Users/majinyun/Codes/go/src/github.com/imajinyun/hello/hello_test.go:9: this is a fatal --- FAIL: TestFatalFunc (0.00s) === RUN TestFatalfFunc /Users/majinyun/Codes/go/src/github.com/imajinyun/hello/hello_test.go:14: this is a fatal --- FAIL: TestFatalfFunc (0.00s) FAIL FAIL example.com/hello 0.012s 日志方法 package hello import ( \"errors\" \"testing\" ) func TestLogFunc(t *testing.T) { t.Log(\"this is a log\") } func TestLogfFunc(t *testing.T) { t.Logf(\"%s\", errors.New(\"this is a log\")) } $ go test -v -timeout 30s -run '^(TestLogFunc|TestLogfFunc)$' example.com/hello === RUN TestLogFunc /Users/majinyun/Codes/go/src/github.com/imajinyun/hello/hello_test.go:9: this is a log --- PASS: TestLogFunc (0.00s) === RUN TestLogfFunc /Users/majinyun/Codes/go/src/github.com/imajinyun/hello/hello_test.go:13: this is a log --- PASS: TestLogfFunc (0.00s) PASS ok example.com/hello 0.015s 跳过方法 package hello import ( \"errors\" \"testing\" ) func TestSkipFunc(t *testing.T) { t.Skip(\"this is a skip\") t.Log(\"see if this line will output #1\") } func TestSkipfFunc(t *testing.T) { t.Logf(\"%s\", errors.New(\"this is a skip\")) t.Log(\"see if this line will output #2\") } func TestSkipNowFunc(t *testing.T) { t.SkipNow() t.Log(\"see if this line will output #3\") } func TestSkippedFunc(t *testing.T) { if t.Skipped() { t.Log(\"see if this line will output #4\") } } $ go test -timeout 30s -run '^(TestSkipFunc|TestSkipfFunc|TestSkipNowFunc|TestSkippedFunc)$' example.com/hello -v === RUN TestSkipFunc /Users/majinyun/Codes/go/src/github.com/imajinyun/hello/hello_test.go:9: this is a skip --- SKIP: TestSkipFunc (0.00s) === RUN TestSkipfFunc /Users/majinyun/Codes/go/src/github.com/imajinyun/hello/hello_test.go:14: this is a skip /Users/majinyun/Codes/go/src/github.com/imajinyun/hello/hello_test.go:15: see if this line will output #2 --- PASS: TestSkipfFunc (0.00s) === RUN TestSkipNowFunc --- SKIP: TestSkipNowFunc (0.00s) === RUN TestSkippedFunc --- PASS: TestSkippedFunc (0.00s) PASS ok example.com/hello 0.011s ","date":"2021-07-16","objectID":"/posts/go-unit-test/:4:1","tags":["Go"],"title":"Go 单元测试","uri":"/posts/go-unit-test/"},{"categories":["Go"],"content":"并行测试 默认情况下，指定包的测试是按照顺序执行的，但也可以通过在测试的函数内部使用 t.Parallel() 来标志某些测试也可以被安全的并发执行（和默认的一样，假设参数名为 t）。在并行执行的情况下，只有当那些被标记为并行的测试才会被并行执行，所以只有一个测试函数时是没意义的。它应该在测试函数体中第一个被调用（在任何需要跳过的条件之后），因为它会重置测试时间： func TestParallel(t *testing.T) { t.Parallel() // actual test... } 在并发情况下，同时运行的测试的数量默认取决于 GOMAXPROCS。它可以通过 -parallel n 被指定（go test -parallel 4）。 另外一个可以实现并行的方法，尽管不是函数级粒度，但却是包级粒度，就是类似这样执行 go test p1 p2 p3（也就是说，同时调用多个测试包）。在这种情况下，包会被先编译，并同时被执行。当然，这对于总的时间来说是有好处的，但它也可能会导致错误变得具有不可预测性，比如一些资源被多个包同时使用时（例如，一些测试需要访问数据库，并删除一些行，而这些行又刚好被其他的测试包使用的话）。 为了保持可控性，-p 标志可以用来指定编译和测试的并发数。当仓库中有多个测试包，并且每个包在不同的子目录中，一个可以执行所有包的命令是 go test ./...，这包含当前目录和所有子目录。没有带 -p 标志执行时，总的运行时间应该接近于运行时间最长的包的时间（加上编译时间）。运行 go test -p 1 ./...，使编译和测试工具只能在一个包中执行时，总的时间应该接近于所有独立的包测试的时间加上编译的时间的总和。具体可以执行 go test -p 3 ./... 来看一下对运行时间的影响。 还有，另外一个可以并行化的地方是在包的代码里面。多亏了 Go 非常棒的并行原语，实际上，除非 GOMAXPROCS 通过环境变量或者在代码中显式设置为 GOMAXPROCS=1，否则，包中一个 goroutines 都没有用是不太常见的。想要使用 2 个 CPU，可以执行 GOMAXPROCS=2 go test，想要使用 4 个 CPU，可以执行 GOMAXPROCS=4 go test，但还有更好的方法：go test -cpu=1,2,4 将会执行 3 次，其中 GOMAXPROCS 值分别为 1,2,4。 待测代码： package hello import \"sync\" var ( data = make(map[string]string) locker sync.RWMutex ) func SetToMap(k, v string) { locker.Lock() defer locker.Unlock() data[k] = v } func GetToMap(k string) string { locker.Lock() defer locker.RUnlock() return data[k] } 测试代码： package hello import \"testing\" var mapTests = []struct { k, v string }{ {\"name\", \"🎉 Hello World\"}, {\"nickname\", \"Golang\"}, {\"email\", \"example@golang.com\"}, {\"phone\", \"12311118888\"}, {\"address\", \"Nanyang Technological University\"}, {\"compony\", \"Amazon\"}, } func TestSetToMap(t *testing.T) { t.Parallel() for _, tt := range mapTests { SetToMap(tt.k, tt.v) } } func TestGetToMap(t *testing.T) { t.Parallel() for _, tt := range mapTests { actual := GetToMap(tt.k) if actual != tt.v { t.Errorf(\"GetToMap(%s) = %v, want: %v\", tt.k, actual, tt.v) } } } $ go test -v -timeout 30s -run ^(TestSetToMap|TestGetToMap)$ example.com/hello === RUN TestSetToMap --- PASS: TestSetToMap (0.00s) === RUN TestGetToMap fatal error: sync: RUnlock of unlocked RWMutex ... 因此，如果代码能够进行并行测试，在写测试时，尽量加上 Parallel，这样可以测试出一些可能的问题。 ","date":"2021-07-16","objectID":"/posts/go-unit-test/:4:2","tags":["Go"],"title":"Go 单元测试","uri":"/posts/go-unit-test/"},{"categories":["Go"],"content":"在 Go 中的生成的随机数根本就不是随机的，叫伪随机数。它们是用固定的决定论算法计算的。 Go 起步 Go 数据类型 Go 日期时间 Go 随机数 Go 单元测试 Go 基准测试 Go 其它测试 Go 正确姿势 Go 连接字符串 ","date":"2021-07-14","objectID":"/posts/go-random-number/:0:0","tags":["Go"],"title":"Go 随机数","uri":"/posts/go-random-number/"},{"categories":["Go"],"content":"生成伪随机数 警告 如果初始化时没有调用 rand.Seed 方法，你每次运行程序都会得到相同的数字序列。 使用 math/rand 包中的 rand.Seed 和 rand.Int63 方法去生成 int64 类型的的非负伪随机数： rand.Seed(time.Now().UnixNano()) n := rand.Int63() // 4394549077322118751 使用 rand.Float64 生成一个浮点伪随机数 x，其中 0 \u003c= x \u003c= 1： rand.Seed(time.Now().UnixNano()) n := rand.Float64() // 0.41473976189141065 math/rand 包中的函数都使用单个随机源： generator := rand.New(rand.NewSource(time.Now().UnixNano())) x := generator.Int63() // 1449278222774694185 y := generator.Float64() // 0.947309190343705 ","date":"2021-07-14","objectID":"/posts/go-random-number/:1:0","tags":["Go"],"title":"Go 随机数","uri":"/posts/go-random-number/"},{"categories":["Go"],"content":"生成指定范围随机数 // a \u003c= n \u003c= b a, b := 0, 100 generator := rand.New(rand.NewSource(time.Now().UnixNano())) n := a + generator.Intn(b-a+1) // 0 \u003c= n \u003c= 100 ","date":"2021-07-14","objectID":"/posts/go-random-number/:2:0","tags":["Go"],"title":"Go 随机数","uri":"/posts/go-random-number/"},{"categories":["Go"],"content":"生成指定范围随机字符 // 'a' \u003c= n \u003c= 'z' var ( x = 'a' y = 'z' ) generator := rand.New(rand.NewSource(time.Now().UnixNano())) n := x + rune(generator.Intn(int(y)-int(x)+1)) // 97 \u003c= n \u003c= 122 m := 'a' + rune(generator.Intn('z'-'a'+1)) // 92 \u003c= m \u003c= 122 ","date":"2021-07-14","objectID":"/posts/go-random-number/:3:0","tags":["Go"],"title":"Go 随机数","uri":"/posts/go-random-number/"},{"categories":["Go"],"content":"生成随机字符串 package main import ( \"fmt\" \"math/rand\" \"time\" ) func init() { rand.Seed(time.Now().UnixNano()) } func main() { for i := 0; i \u003c 10; i++ { fmt.Println(randomString(10)) } } func randomString(size int) string { bytes := make([]byte, size) for i := 0; i \u003c size; i++ { bytes[i] = byte(randInt(97, 122)) } return string(bytes) } func randInt(min, max int) int { return min + rand.Intn(max-min+1) } /* tcjrkupnct twdvwjihfb lkemigoqne vqxyasbrqx iwdncpibxg ugtsutgmjt namoonwvyh mcxnbbjfgf ufradkxsjq blnweycudh */ ","date":"2021-07-14","objectID":"/posts/go-random-number/:4:0","tags":["Go"],"title":"Go 随机数","uri":"/posts/go-random-number/"},{"categories":["Go"],"content":"从切片中获取随机元素 实例一： package main import ( \"fmt\" \"math/rand\" \"time\" ) func init() { rand.Seed(time.Now().UnixNano()) } func main() { runes := []rune(\"A™B£C¢\") char := runes[rand.Intn(len(runes))] fmt.Println(string(char)) // £ } 实例二： package main import ( \"fmt\" \"math/rand\" \"time\" ) func init() { rand.Seed(time.Now().UnixNano()) } func main() { slices := make([]string, 0) slices = append(slices, \"Apple\", \"Google\", \"Microsoft\", \"Amazon\", \"Facebook\") element := slices[rand.Intn(len(slices))] // Get random element from slices: Amazon fmt.Println(fmt.Sprintf(\"Get random element from slices: %v\", element)) } ","date":"2021-07-14","objectID":"/posts/go-random-number/:5:0","tags":["Go"],"title":"Go 随机数","uri":"/posts/go-random-number/"},{"categories":["Go"],"content":"生成安全的随机数 randomCrypto, _ := rand.Prime(rand.Reader, 128) fmt.Println(randomCrypto) // 332362372159551722027736589221875117617 ","date":"2021-07-14","objectID":"/posts/go-random-number/:6:0","tags":["Go"],"title":"Go 随机数","uri":"/posts/go-random-number/"},{"categories":["Go"],"content":"Go 中的日期时间使用布局来格式化，通过布局来完成日期时间的格式化和解析。 Go 起步 Go 数据类型 Go 日期时间 Go 随机数 Go 单元测试 Go 基准测试 Go 其它测试 Go 正确姿势 Go 连接字符串 当前日期时间 ","date":"2021-07-11","objectID":"/posts/go-date-time/:0:0","tags":["Go"],"title":"Go 日期时间","uri":"/posts/go-date-time/"},{"categories":["Go"],"content":"标准日期时间格式 布局格式： Layout Note January 2, 2006 Date 01/02/06 Date Jan-02-06 Date 15:04:05 Time 3:04:05 PM Time Jan _2 15:04:05 Timestamp Jan _2 15:04:05.000000 With microseconds 2006-01-02T15:04:05-0700 ISO 8601(RFC 3339) 2006-01-02 ISO 8601(RFC 3339) 15:04:05 ISO 8601(RFC 3339) 02 Jan 06 15:04 MST RFC 822 02 Jan 06 15:04 -0700 With numeric zone Mon, 02 Jan 2006 15:04:05 MST RFC 1123 Mon, 02 Jan 2006 15:04:05 -0700 With numeric zone 布局选项： Type Options Year 06 2006 Month 01 1 Jan January Day 02 2 _2(width two, right justified) Weekday Mon Monday Hours 03 3 15 Minutes 04 4 Seconds 05 5 ms us ns .000 .000000 .000000000 ms us ns .999 .999999 .999999999(trailing zeros removed) am/pm AM am PM pm Timezone MST Offset -0700 -07 -07:00 Z0700 Z07:00 以下是 Go 源码中预定义日期和时间格式常量： // These are predefined layouts for use in Time.Format and time.Parse. // The reference time used in the layouts is the specific time: // Mon Jan 2 15:04:05 MST 2006 // which is Unix time 1136239445. Since MST is GMT-0700, // the reference time can be thought of as // 01/02 03:04:05PM '06 -0700 // To define your own format, write down what the reference time would look // like formatted your way; see the values of constants like ANSIC, // StampMicro or Kitchen for examples. The model is to demonstrate what the // reference time looks like so that the Format and Parse methods can apply // the same transformation to a general time value. // // Some valid layouts are invalid time values for time.Parse, due to formats // such as _ for space padding and Z for zone information. // // Within the format string, an underscore _ represents a space that may be // replaced by a digit if the following number (a day) has two digits; for // compatibility with fixed-width Unix time formats. // // A decimal point followed by one or more zeros represents a fractional // second, printed to the given number of decimal places. A decimal point // followed by one or more nines represents a fractional second, printed to // the given number of decimal places, with trailing zeros removed. // When parsing (only), the input may contain a fractional second // field immediately after the seconds field, even if the layout does not // signify its presence. In that case a decimal point followed by a maximal // series of digits is parsed as a fractional second. // // Numeric time zone offsets format as follows: // -0700 ±hhmm // -07:00 ±hh:mm // -07 ±hh // Replacing the sign in the format with a Z triggers // the ISO 8601 behavior of printing Z instead of an // offset for the UTC zone. Thus: // Z0700 Z or ±hhmm // Z07:00 Z or ±hh:mm // Z07 Z or ±hh // // The recognized day of week formats are \"Mon\" and \"Monday\". // The recognized month formats are \"Jan\" and \"January\". // // The formats 2, _2, and 02 are unpadded, space-padded, and zero-padded // day of month. The formats __2 and 002 are space-padded and zero-padded // three-character day of year; there is no unpadded day of year format. // // Text in the format string that is not recognized as part of the reference // time is echoed verbatim during Format and expected to appear verbatim // in the input to Parse. // // The executable example for Time.Format demonstrates the working // of the layout string in detail and is a good reference. // // Note that the RFC822, RFC850, and RFC1123 formats should be applied // only to local times. Applying them to UTC times will use \"UTC\" as the // time zone abbreviation, while strictly speaking those RFCs require the // use of \"GMT\" in that case. // In general RFC1123Z should be used instead of RFC1123 for servers // that insist on that format, and RFC3339 should be preferred for new protocols. // RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; // when used with time.Parse they do not accept all the time formats // permitted by the RFCs and they do accept time formats not formally defined. // The RFC3339Nano format removes trailing zeros from the seconds field // and thus may not sort correc","date":"2021-07-11","objectID":"/posts/go-date-time/:1:0","tags":["Go"],"title":"Go 日期时间","uri":"/posts/go-date-time/"},{"categories":["Go"],"content":"获取当前日期时间 package main import ( \"fmt\" \"time\" ) func main() { now := time.Now() fmt.Printf(\"当前日期时间：%v\\n\", now) fmt.Printf(\"年：%v\\n\", now.Year()) fmt.Printf(\"月：%v\\n\", now.Month()) fmt.Printf(\"日：%v\\n\", now.Day()) fmt.Printf(\"时：%v\\n\", now.Hour()) fmt.Printf(\"分：%v\\n\", now.Minute()) fmt.Printf(\"秒：%v\\n\", now.Second()) fmt.Printf(\"纳秒：%v\\n\", now.Nanosecond()) fmt.Printf(\"\\n\") } /* 当前日期时间：2021-07-11 11:12:59.787921 +0800 CST m=+0.000104353 年：2021 月：July 日：11 时：11 分：12 秒：59 纳秒：787921000 /* ","date":"2021-07-11","objectID":"/posts/go-date-time/:2:0","tags":["Go"],"title":"Go 日期时间","uri":"/posts/go-date-time/"},{"categories":["Go"],"content":"获取当前时间戳 package main import ( \"fmt\" \"time\" ) func main() { now := time.Now() fmt.Printf(\"当前时间戳（单位为秒）：%v\\n\", now.Unix()) fmt.Printf(\"当前时间戳（单位为纳秒）：%v\\n\", now.UnixNano()) } /* 当前时间戳（单位为秒）：1625973361 当前时间戳（单位为纳秒）：1625973361766745000 */ ","date":"2021-07-11","objectID":"/posts/go-date-time/:3:0","tags":["Go"],"title":"Go 日期时间","uri":"/posts/go-date-time/"},{"categories":["Go"],"content":"获取当前时间的字符串格式 package main import ( \"fmt\" \"time\" ) func main() { now := time.Now() fmt.Printf(\"当前日期时间：%v\\n\", now.Format(time.RFC3339)) fmt.Printf(\"当前日期时间：%v\\n\", now.Format(\"2006-01-02 15:04:05\")) } /* 当前日期时间：2021-07-11T11:42:19+08:00 当前日期时间：2021-07-11 11:42:19 */ 指定时区获取日期时间 ","date":"2021-07-11","objectID":"/posts/go-date-time/:4:0","tags":["Go"],"title":"Go 日期时间","uri":"/posts/go-date-time/"},{"categories":["Go"],"content":"使用 FixedZone 指定 package main import ( \"testing\" \"time\" ) const TheCSTLayout = \"2006-01-02T15:04:05\" var theCSTZone *time.Location func init() { theCSTZone = time.FixedZone(\"CST\", 8*3600) } func TestNowDateTime(t *testing.T) { dateTime := time.Now().In(theCSTZone).Format(TheCSTLayout) t.Logf(\"The date time: %v\", dateTime) now, _ := time.ParseInLocation(TheCSTLayout, dateTime, theCSTZone) t.Logf(\"Now date time: %v\", now) } /* $ go test -v -timeout 30s -run ^TestNowDateTime$ example.org/hello/v2 === RUN TestNowDateTime main_test.go:18: The date time: 2021-09-25T09:02:03 main_test.go:20: Now date time: 2021-09-25 09:02:03 +0800 CST --- PASS: TestNowDateTime (0.00s) PASS ok example.org/hello/v2 0.234s */ ","date":"2021-07-11","objectID":"/posts/go-date-time/:5:0","tags":["Go"],"title":"Go 日期时间","uri":"/posts/go-date-time/"},{"categories":["Go"],"content":"使用 LoadLocation 指定 package main import ( \"log\" \"testing\" \"time\" ) const TheCSTLayout = \"2006-01-02T15:04:05\" var theCSTLocation *time.Location func init() { var err error theCSTLocation, err = time.LoadLocation(\"Asia/Shanghai\") if err != nil { log.Fatalf(\"Load location failed, %v\", err) } } func TestNowDateTime(t *testing.T) { dateTime := time.Now().In(theCSTLocation).Format(TheCSTLayout) t.Logf(\"The date time: %v\", dateTime) now, _ := time.ParseInLocation(TheCSTLayout, dateTime, theCSTLocation) t.Logf(\"Now date time: %v\", now) } /* $ go test -v -timeout 30s -run ^TestNowDateTime$ example.org/hello/v2 === RUN TestNowDateTime main_test.go:23: The date time: 2021-09-25T09:39:02 main_test.go:25: Now date time: 2021-09-25 09:39:02 +0800 CST --- PASS: TestNowDateTime (0.00s) PASS ok example.org/hello/v2 1.777s */ 常用日期时间转换 ","date":"2021-07-11","objectID":"/posts/go-date-time/:6:0","tags":["Go"],"title":"Go 日期时间","uri":"/posts/go-date-time/"},{"categories":["Go"],"content":"时间戳转日期时间字符串 package main import ( \"fmt\" \"strconv\" \"time\" ) func main() { layout := \"2006-01-02 15:04:05\" now := time.Now().Unix() fmt.Printf(\"转换后的日期时间：%v\\n\", time.Unix(now, 0).Format(layout)) a, b := 1626005415, \"1626005415\" c, _ := strconv.ParseInt(b, 10, 64) fmt.Printf(\"转换后的日期时间：%v\\n\", time.Unix(int64(a), 0).Format(layout)) fmt.Printf(\"转换后的日期时间：%v\\n\", time.Unix(c, 0).Format(layout)) } /* 转换后的日期时间：2021-07-11 20:35:31 转换后的日期时间：2021-07-11 20:10:15 转换后的日期时间：2021-07-11 20:10:15 */ ","date":"2021-07-11","objectID":"/posts/go-date-time/:7:0","tags":["Go"],"title":"Go 日期时间","uri":"/posts/go-date-time/"},{"categories":["Go"],"content":"日期时间字符串转时间戳 package main import ( \"fmt\" \"time\" ) const ( ChinaFormat = \"2006-01-02 15:04:05\" ) func main() { a, b := \"2021-07-11 20:27:33\", \"Sun, 11 Jul 2021 15:04:05 UTC\" at1, _ := time.Parse(ChinaFormat, a) at2, _ := time.Parse(time.RFC1123, b) fmt.Printf(\"转换后的时间戳：%v\\n\", at1.Unix()) fmt.Printf(\"转换后的时间戳：%v\\n\", at2.Unix()) } /* 转换后的时间戳：1626035253 转换后的时间戳：1626015845 */ ","date":"2021-07-11","objectID":"/posts/go-date-time/:8:0","tags":["Go"],"title":"Go 日期时间","uri":"/posts/go-date-time/"},{"categories":["Go"],"content":"日期时间字符串转时间对象 package main import ( \"fmt\" \"time\" ) func main() { str := \"2008-08-08 08:08:08\" // Parse the date string into Go's time object at, _ := time.Parse(\"2006-01-02 15:04:05\", str) fmt.Printf(\"转换后的日期时间：%v\\n\", at) fmt.Println(at.Date()) } /* 转换后的日期时间：2008-08-08 08:08:08 +0000 UTC 2008 August 8 */ 常用日期时间计算 ","date":"2021-07-11","objectID":"/posts/go-date-time/:9:0","tags":["Go"],"title":"Go 日期时间","uri":"/posts/go-date-time/"},{"categories":["Go"],"content":"计算两个给定日期之前相差的天数 package main import ( \"fmt\" \"time\" ) func main() { t1, t2 := Date(2020, 1, 1), Date(2021, 1, 1) days := t2.Sub(t1).Hours() / 24 fmt.Printf(\"两个给定日期之前相差的天数为：%v\\n\", days) } func Date(year, month, day int) time.Time { return time.Date(year, time.Month(month), day, 0, 0, 0, 0, time.UTC) } /* 两个给定日期之前相差的天数为：366 */ ","date":"2021-07-11","objectID":"/posts/go-date-time/:10:0","tags":["Go"],"title":"Go 日期时间","uri":"/posts/go-date-time/"},{"categories":["Go"],"content":"统计代码运行时间 package main import ( \"fmt\" \"time\" ) func main() { fn := TimeSpent(execSlowFunc) fmt.Printf(\"Exec result: %v\\n\", fn(9999)) } func execSlowFunc(x int) int { time.Sleep(3 * time.Second) return x + 1 } func TimeSpent(fn func(x int) int) func(n int) int { return func(x int) int { start := time.Now() ret := fn(x) fmt.Println(\"Time spent:\", time.Since(start).Seconds()) return ret } } /* Time spent: 3.004356442 Exec result: 10000 */ package main import ( \"log\" \"time\" ) func main() { defer TimeSpent(execSlowFunc(\"Hello World!\")) } func execSlowFunc(s string) (string, time.Time) { time.Sleep(1 * time.Second) return s + \" 🌏🌈💫🔥🎉🚀🙏\", time.Now() } func TimeSpent(s string, start time.Time) { log.Printf(\"%v: %v\\n\", s, time.Since(start)) } /* 2021/07/14 08:22:38 Hello World! 🌏🌈💫🔥🎉🚀🙏: 4.582µs */ ","date":"2021-07-11","objectID":"/posts/go-date-time/:11:0","tags":["Go"],"title":"Go 日期时间","uri":"/posts/go-date-time/"},{"categories":["Go"],"content":"日期时间比较 package test import ( \"testing\" \"time\" ) func TestCompareTime(t *testing.T) { at := time.Now() t1, t2 := \"2023-01-31\", \"2099-01-31\" v1, _ := time.ParseInLocation(\"2006-01-02\", t1, time.Local) v2, _ := time.ParseInLocation(\"2006-01-02\", t2, time.Local) if at.Before(v1) \u0026\u0026 at.After(v2) { t.Errorf(\"%s is between %s and %s\", at, v1, v2) } t3, t4 := \"2099-01-01 12:00:00\", \"2099-01-31 12:00:00\" v3, _ := time.ParseInLocation(\"2006-01-02 15:04:05\", t3, time.Local) v4, _ := time.ParseInLocation(\"2006-01-02 15:04:05\", t4, time.Local) if at.Before(v4) \u0026\u0026 at.After(v3) { t.Errorf(\"%s is between %s and %s\", at, v3, v4) } t5, t6 := \"2099-01-01 12:00:00\", \"2099-01-01 12:00:00\" v5, _ := time.ParseInLocation(\"2006-01-02 15:04:05\", t5, time.Local) v6, _ := time.ParseInLocation(\"2006-01-02 15:04:05\", t6, time.Local) if !v5.Equal(v6) { t.Errorf(\"%s is equal to %s\", v5, v6) } } ❯ go test -timeout 30s -run '^TestCompareTime$' example.com/m/test -v === RUN TestCompareTime --- PASS: TestCompareTime (0.00s) PASS ok example.com/m/test 0.010s ","date":"2021-07-11","objectID":"/posts/go-date-time/:12:0","tags":["Go"],"title":"Go 日期时间","uri":"/posts/go-date-time/"},{"categories":["Go"],"content":"Go 是静态类型的编程语言，这意味着每个变量都有一种类型。从大的方面来说 Go 有两种类型，即基本类型和组合类型。数据类型指定有效的 Go 变量可以保持的数据类型。 Go 起步 Go 数据类型 Go 日期时间 Go 随机数 Go 单元测试 Go 基准测试 Go 其它测试 Go 正确姿势 Go 连接字符串 ","date":"2021-07-02","objectID":"/posts/go-data-type/:0:0","tags":["Go"],"title":"Go 数据类型","uri":"/posts/go-data-type/"},{"categories":["Go"],"content":"按基本数据类型分类 ","date":"2021-07-02","objectID":"/posts/go-data-type/:1:0","tags":["Go"],"title":"Go 数据类型","uri":"/posts/go-data-type/"},{"categories":["Go"],"content":"基本类型 布尔型 信息 bool 的零值为 false。 仅赋值为 true 和 false 来表示真假。Go 没有定义布尔类型的字面量形式，可以将 true 和 false 这两个预声明的有名常量当作布尔类型的字面量形式。 package main import ( \"fmt\" \"reflect\" \"unsafe\" ) var b1 bool func main() { b2 := true fmt.Printf(\"b1: %s type, %d bytes\\n\", reflect.TypeOf(b1), unsafe.Sizeof(b1)) fmt.Printf(\"b2: %s type, %d bytes\\n\\n\", reflect.TypeOf(b2), unsafe.Sizeof(b2)) } /* b1: bool type, 1 bytes b2: bool type, 1 bytes */ 数值类型 信息 numeric 的零值为 0（但是不同类型的零值在内存中占用的空间可能不同）。 整数型 包括有符号（Signed）和无符号（Unsigned）类型。 Type Size Range Description int8 1 -128~127 or -2^7~2^7-1 有符号 8 位整形 uint8 1 0~255 or 2^8 无符号 8 位整形 int16 2 -32768~32767 or -2^15~2^15-1 有符号 16 位整形 uint16 2 0~65535 or 2^16 无符号 16 位整形 int32 4 -2147483648~2147483647 or -2^31~2^31-1 有符号 32 位整形 uint32 4 0~4294967295 or 2^31 无符号 32 位整形 int64 8 -9223372036854775808~9223372036854775807 or -2^63~2^63-1 有符号 64 位整形 uint64 8 0~18446744073709551615 or 0~2^64 无符号 64 位整形 int 4 or 8 Platform dependent 有符号 32 或 64 位整形 uint 4 or 8 Platform dependent 无符号 32 或 64 位整形 uintptr 4 or 8 Platform dependent 用于存放一个指针 信息 uintptr 特性： 可以被转换为 unsafe.Pointer，反之亦然； 可以在其上执行算术运算； 即使包含指针地址，也只是一个值，也不引用任何对象。所以： 如果相应对象移动，则不会更新其值。例如：当 Goroutine 堆栈发生变化时； 相应的对象可以是被收集的垃圾； uintptr 场景： 其上的是与 unsafe.Pointer 一起主要用于不安全的内存访问； 当你想要保存指针地址值以进行打印或存储它。由于地址刚刚存储并且不引用任何内容，因此相应的对象可以是垃圾收集的； package main import ( \"fmt\" \"math/bits\" \"reflect\" \"unsafe\" ) var ( i8 int8 u8 uint8 i16 int16 u16 uint16 i32 int32 u32 uint32 i64 int64 u64 uint64 i int u uint ) type student struct { name string age int } func main() { fmt.Printf(\"i8: %d bits, %s type, %d bytes\\n\", bits.UintSize, reflect.TypeOf(i8), unsafe.Sizeof(i8)) fmt.Printf(\"u8: %d bits, %s type, %d bytes\\n\\n\", bits.UintSize, reflect.TypeOf(u8), unsafe.Sizeof(u8)) fmt.Printf(\"i16: %d bits, %s type, %d bytes\\n\", bits.UintSize, reflect.TypeOf(i16), unsafe.Sizeof(i16)) fmt.Printf(\"u16: %d bits, %s type, %d bytes\\n\\n\", bits.UintSize, reflect.TypeOf(u16), unsafe.Sizeof(u16)) fmt.Printf(\"i32: %d bits, %s type, %d bytes\\n\", bits.UintSize, reflect.TypeOf(i32), unsafe.Sizeof(i32)) fmt.Printf(\"u32: %d bits, %s type, %d bytes\\n\\n\", bits.UintSize, reflect.TypeOf(u32), unsafe.Sizeof(u32)) fmt.Printf(\"i64: %d bits, %s type, %d bytes\\n\", bits.UintSize, reflect.TypeOf(i64), unsafe.Sizeof(i64)) fmt.Printf(\"u64: %d bits, %s type, %d bytes\\n\\n\", bits.UintSize, reflect.TypeOf(u64), unsafe.Sizeof(u64)) fmt.Printf(\"i: %d bits, %s type, %d bytes\\n\", bits.UintSize, reflect.TypeOf(i), unsafe.Sizeof(i)) fmt.Printf(\"u: %d bits, %s type, %d bytes\\n\\n\", bits.UintSize, reflect.TypeOf(u), unsafe.Sizeof(u)) s := \u0026student{name: \"tony\", age: 18} // Get the address of field name in struct s p := unsafe.Pointer(uintptr(unsafe.Pointer(s)) + unsafe.Offsetof(s.name)) // Typecast it to a string pointer and print the value of it fmt.Printf(\"p: %s\", *(*string)(p)) } /* i8: 64 bits, int8 type, 1 bytes u8: 64 bits, uint8 type, 1 bytes i16: 64 bits, int16 type, 2 bytes u16: 64 bits, uint16 type, 2 bytes i32: 64 bits, int32 type, 4 bytes u32: 64 bits, uint32 type, 4 bytes i64: 64 bits, int64 type, 8 bytes u64: 64 bits, uint64 type, 8 bytes i: 64 bits, int type, 8 bytes u: 64 bits, uint type, 8 bytes p: tony */ 信息 byte 为 uint8 的别名。因此它是一个整数值，此整数值为 8 位，它表示 0~255 之间的一个字节。单个字节可以代表 ASCII 字符。Go 没有任何 char 数据类型，因此字节用于表示 ASCII 字符。 package main import ( \"fmt\" \"reflect\" \"unsafe\" ) func main() { var char byte = 'a' fmt.Printf(\"Type: %s, Size: %d\\n\", reflect.TypeOf(char), unsafe.Sizeof(char)) fmt.Printf(\"Character: %c\\n\", char) s := \"abc\" fmt.Println([]byte(s)) } /* Type: uint8, Size: 1 Character: a [97 98 99] */ 信息 rune 为 int32 的别名。因此它是一个整数值，此整数值旨在表示 Unicode Code Point。关于 Unicode 和字符集请戳 The Absolute Minimum Every Software Developer Absolutely, Positively. Must Know About Unicode and Character Sets(No Excuses!)。 package main import ( \"fmt\" \"reflect\" \"unsafe\" ) func main() { char := 'a' fmt.Printf(\"Type: %s, Size: %d\\n\", reflect.TypeOf(char), unsafe.Sizeof(char)) fmt.Printf(\"Character: %c\\n\", char) fmt.Printf(\"Unicode Code Point: %U\\n\", char) s := \"0b™\" // This will pri","date":"2021-07-02","objectID":"/posts/go-data-type/:1:1","tags":["Go"],"title":"Go 数据类型","uri":"/posts/go-data-type/"},{"categories":["Go"],"content":"组合类型 非引用类型 数组 package main import ( \"fmt\" ) func main() { var arr1 [2]string arr1[0] = \"a\" arr1[1] = \"b\" dump(\"arr1\", arr1) arr2 := [2]string{\"Hello\", \"World\"} dump(\"arr2\", arr2) } func dump(name string, array [2]string) { fmt.Printf(\"%s: %v\\n\", name, array) } /* arr1: [a b] arr2: [Hello World] */ 结构体 package main import ( \"fmt\" ) type employee struct { name string age int salary float64 } func main() { e1 := employee{\"John\", 28, 12000.00} fmt.Printf(\"e1: %v\\n\", e1) e2 := employee{name: \"Jack\", age: 26, salary: 8000.00} fmt.Printf(\"e2: %v\\n\", e2) e3 := employee{name: \"Pony\", age: 27} fmt.Printf(\"e3: %v\\n\", e3) } /* e1: {John 28 12000} e2: {Jack 26 8000} e3: {Pony 27 0} */ 引用类型 切片 切片是动态大小的，数组是固定大小的，因此切片提供更灵活的接口。切片是引用类型，因为它在内部引用数组。它的内部表示通过三个字段： 底层数组的地址； 切片的长度； 切片的容量； package main import ( \"fmt\" \"reflect\" ) func main() { s := make([]string, 2, 3) fmt.Printf(\"Slice: %v, Type: %s, Len: %d, Cap: %d\\n\", s, reflect.TypeOf(s), len(s), cap(s)) p := []string{\"a\", \"b\", \"c\"} fmt.Printf(\"Slice: %v, Type: %s, Len: %d, Cap: %d\\n\", p, reflect.TypeOf(p), len(p), cap(s)) p = append(p, \"d\") fmt.Printf(\"Slice: %v, Type: %s, Len: %d, Cap: %d\\n\", p, reflect.TypeOf(p), len(p), cap(s)) for _, v := range p { fmt.Println(v) } } /* Slice: [ ], Type: []string, Len: 2, Cap: 3 Slice: [a b c], Type: []string, Len: 3, Cap: 3 Slice: [a b c d], Type: []string, Len: 4, Cap: 3 a b c d */ 映射 信息 map 的零值是 nil。 package main import ( \"fmt\" \"reflect\" ) func main() { var student map[string]interface{} fmt.Printf(\"Type: %s, Value: %v\\n\", reflect.TypeOf(student), student) stu1 := make(map[string]int) fmt.Printf(\"Type: %s, Value: %v\\n\", reflect.TypeOf(stu1), stu1) stu2 := map[string]int{\"John\": 18, \"Jack\": 20} stu2[\"Carl\"] = 28 fmt.Printf(\"John age is %d\\n\", stu2[\"John\"]) delete(stu2, \"Carl\") fmt.Printf(\"\\nPrint stu2 map:\") fmt.Println(stu2) } /* Type: map[string]interface {}, Value: map[] Type: map[string]int, Value: map[] John age is 18 Print stu2 map:map[Jack:20 John:18] */ 通道 信息 通道提供 Goroutine 之间的同步和通信。你可以将其视为管道，Goroutine 可以发送值和接收值。操作 \u003c- 用于发送或接收，并指定数据流动方向的箭头方向。 两种类型的通道： 无缓冲通道（Unbuffered Channel）：它没有任何容纳能力和值： 除非有另一个 Goroutine 接收，否则发送在频道上是阻塞的； 接收是阻塞的，直到另一个 Goroutine 在一边去发送； 带缓冲通道（Buffered Channel）：可以在此处指定缓冲区的大小： 如果缓冲区已满，则仅发送阻塞的缓冲通道； 接收唯一的阻塞是通道的缓冲区是空的； package main import ( \"fmt\" ) func main() { // Creating a buffered channel of length 4 bufChan := make(chan string, 4) bufChan \u003c- \"🚀 Hello \" bufChan \u003c- \"World, \" bufChan \u003c- \"Hello \" bufChan \u003c- \"Go!\\n\" close(bufChan) for ch := range bufChan { fmt.Print(ch) } // Creating a unbuffered channel unbufChan := make(chan string) go sendChan(unbufChan) for ch := range unbufChan { fmt.Print(ch) } } func sendChan(ch chan\u003c- string) { ch \u003c- \"🚀 Hello \" ch \u003c- \"World, \" ch \u003c- \"Hello \" ch \u003c- \"Go!\" close(ch) } /* 🚀 Hello World, Hello Go! 🚀 Hello World, Hello Go! */ 函数 package main import \"fmt\" func main() { add := func(x, y int) int { return x + y } fmt.Println(doExecute(add, 10, 20)) } func doExecute(fn func(int, int) int, x, y int) int { return fn(x, y) } /* 30 */ 指针 package main import \"fmt\" func main() { var b *int a := 88 b = \u0026a fmt.Printf(\"b: %v, *b: %v\\n\", b, *b) b = new(int) *b = 99 fmt.Printf(\"b: %v, *b: %v\\n\", b, *b) } /* b: 0xc0000ac008, *b: 88 b: 0xc0000ac018, *b: 99 */ Interface 信息 interface 的零值是 nil。 package main import \"fmt\" type shape interface { area() float64 } type square struct { side float64 } type triangle struct { bottom float64 height float64 } func (s *square) area() float64 { return s.side * s.side } func (t *triangle) area() float64 { return (t.bottom * t.height) / 2 } func main() { var s shape s = \u0026square{side: 4} fmt.Printf(\"Square area is %v\\n\", s.area()) t := \u0026triangle{bottom: 10, height: 12} fmt.Printf(\"Triangle area is %v\\n\", t.area()) } /* Square area is 16 Triangle area is 60 */ 空接口的特殊情况： package main import \"fmt\" func main() { var a = [2]string{\"go\", \"js\"} var m = map[int]string{1: \"hello\", 2: \"world\"} dump(\"🚀 Hello World, Hello Go!\") dump(123456780) dump(true) dump(a) dump(m) } func dump(v interface{}) { f","date":"2021-07-02","objectID":"/posts/go-data-type/:1:2","tags":["Go"],"title":"Go 数据类型","uri":"/posts/go-data-type/"},{"categories":["Go"],"content":"数值类型运算符 算术运算符：+、-、*、/、% 比较运算符：==、!=、\u003e、\u003e=、\u003c=、\u003c 逻辑运算符：\u0026\u0026、||、! 增减运算符：++、-- 按位运算符：\u0026、|、^、\u003c\u003c、\u003e\u003e、\u0026^ 赋值运算符：+=、-=、*=、/=、%=、\u003c\u003c=、\u003e\u003e=、\u0026=、|=、^= ","date":"2021-07-02","objectID":"/posts/go-data-type/:2:0","tags":["Go"],"title":"Go 数据类型","uri":"/posts/go-data-type/"},{"categories":["Go"],"content":"运算符优化级 Priority Category Operator Associativity 1 Postfix () [] -\u003e . ++ -- Left to right 2 Unary + - ! ~ ++ -- (type)* \u0026 sizeof Right to left 3 Multiplicative * / % Left to right 4 Additive + - Left to right 5 Shift \u003c\u003c \u003e\u003e Left to right 6 Relational \u003c \u003c= \u003e= \u003e Left to right 7 Equality == != Left to right 8 Bitwise AND \u0026 Left to right 9 Bitwise XOR ^ Left to right 10 Bitwise OR ⎮ Left to right 11 Logical AND \u0026\u0026 Left to right 12 Logical OR ⎮⎮ Left to right 13 Assignment = += -= *= /= %= = \u003e\u003e= \u003c\u003c= \u0026= ^= ⎮= Right to right 14 Comma , Left to right ","date":"2021-07-02","objectID":"/posts/go-data-type/:3:0","tags":["Go"],"title":"Go 数据类型","uri":"/posts/go-data-type/"},{"categories":["PHP"],"content":"在 PHP 中有很多针对数组的排序函数，非常方便。这些函数对一维数组进行关键字排序、按值排序、逆排序等。但对于多维数组的按需排序需要自己编写特定的函数去现实。 ","date":"2021-07-02","objectID":"/posts/php-array-sort/:0:0","tags":["PHP"],"title":"PHP 数组排序","uri":"/posts/php-array-sort/"},{"categories":["PHP"],"content":"数组值排序 函数名称 数组索引键保持 顺序 相关函数 array_multisort() 键值关联的保持，数字类型的不保持 第一个数组或者由选项指定 array_walk() asort() 是 由低到高 arsort() arsort() 是 由高到低 asort() natcasesort() 是 自然排序，大小写不敏感 natsort() natsort() 是 自然排序 natcasesort() rsort() 否 由高到低 sort() sort() 否 由低到高 rsort() shuffle() 否 随机 array_rand() uasort() 是 由用户定义 uksort() usort() 否 由用户定义 uasort() \u003c?php $array = [ 'c' =\u003e ['id' =\u003e 4000, 'name' =\u003e 'Jack'], 'e' =\u003e ['id' =\u003e 2000, 'name' =\u003e 'Dane'], 'd' =\u003e ['id' =\u003e 1000, 'name' =\u003e 'Mark'], 'a' =\u003e ['id' =\u003e 5000, 'name' =\u003e 'Alan'], 'b' =\u003e ['id' =\u003e 3000, 'name' =\u003e 'Toby'], ]; function sort_by_id($left, $right) { return $left['id'] \u003c=\u003e $right['id']; } function sort_by_name($left, $right) { return strcasecmp($left['name'], $right['name']); } ","date":"2021-07-02","objectID":"/posts/php-array-sort/:1:0","tags":["PHP"],"title":"PHP 数组排序","uri":"/posts/php-array-sort/"},{"categories":["PHP"],"content":"uasort 使用用户自定义的比较函数对数组中的值进行排序并保持索引关联 按 id 值由小到大排序 \u003c?php uasort($array, 'sort_by_id'); print_r($array); // 结果 Array ( [d] =\u003e Array ( [id] =\u003e 1000 [name] =\u003e Mark ) [e] =\u003e Array ( [id] =\u003e 2000 [name] =\u003e Dane ) [b] =\u003e Array ( [id] =\u003e 3000 [name] =\u003e Toby ) [c] =\u003e Array ( [id] =\u003e 4000 [name] =\u003e Jack ) [a] =\u003e Array ( [id] =\u003e 5000 [name] =\u003e Alan ) ) 按 name 值依字母表顺序排序 strcasecmp() - 二进制安全比较字符串（不区分大小写） strcmp() - 二进制安全比较字符串（区分大小写） \u003c?php uasort($array, 'sort_by_name'); print_r($array); // 结果 Array ( [d] =\u003e Array ( [id] =\u003e 1000 [name] =\u003e Mark ) [e] =\u003e Array ( [id] =\u003e 2000 [name] =\u003e Dane ) [b] =\u003e Array ( [id] =\u003e 3000 [name] =\u003e Toby ) [c] =\u003e Array ( [id] =\u003e 4000 [name] =\u003e Jack ) [a] =\u003e Array ( [id] =\u003e 5000 [name] =\u003e Alan ) ) Array ( [a] =\u003e Array ( [id] =\u003e 5000 [name] =\u003e Alan ) [e] =\u003e Array ( [id] =\u003e 2000 [name] =\u003e Dane ) [c] =\u003e Array ( [id] =\u003e 4000 [name] =\u003e Jack ) [d] =\u003e Array ( [id] =\u003e 1000 [name] =\u003e Mark ) [b] =\u003e Array ( [id] =\u003e 3000 [name] =\u003e Toby ) ) ","date":"2021-07-02","objectID":"/posts/php-array-sort/:1:1","tags":["PHP"],"title":"PHP 数组排序","uri":"/posts/php-array-sort/"},{"categories":["PHP"],"content":"usort 使用用户自定义的比较函数对数组中的值进行排序，此函数为 array 中的元素赋与新的键名。这将删除原有的键名，而不是仅仅将键名重新排序 按 id 值由小到大排序 \u003c?php usort($array, 'sort_by_id'); print_r($array); // 结果 Array ( [0] =\u003e Array ( [id] =\u003e 1000 [name] =\u003e Mark ) [1] =\u003e Array ( [id] =\u003e 2000 [name] =\u003e Dane ) [2] =\u003e Array ( [id] =\u003e 3000 [name] =\u003e Toby ) [3] =\u003e Array ( [id] =\u003e 4000 [name] =\u003e Jack ) [4] =\u003e Array ( [id] =\u003e 5000 [name] =\u003e Alan ) ) 按 name 值依字母表顺序排序 \u003c?php usort($array, 'sort_by_name'); print_r($array); // 结果 Array ( [0] =\u003e Array ( [id] =\u003e 5000 [name] =\u003e Alan ) [1] =\u003e Array ( [id] =\u003e 2000 [name] =\u003e Dane ) [2] =\u003e Array ( [id] =\u003e 4000 [name] =\u003e Jack ) [3] =\u003e Array ( [id] =\u003e 1000 [name] =\u003e Mark ) [4] =\u003e Array ( [id] =\u003e 3000 [name] =\u003e Toby ) ) ","date":"2021-07-02","objectID":"/posts/php-array-sort/:1:2","tags":["PHP"],"title":"PHP 数组排序","uri":"/posts/php-array-sort/"},{"categories":["PHP"],"content":"数组键排序 函数名称 数组索引键保持 顺序 相关函数 krsort() 是 由高到低 ksort() ksort() 是 由低到高 asort() uksort() 是 由用户定义 uasort() \u003c?php $array = [ 'b' =\u003e ['a' =\u003e 1, 'c' =\u003e 0.01, 'b' =\u003e null], 'a' =\u003e ['b' =\u003e 3, 'a' =\u003e 0.03, 'c' =\u003e null], 'c' =\u003e ['c' =\u003e 2, 'b' =\u003e 0.02, 'a' =\u003e null], ]; function sort_by_key($left, $right) { return strcasecmp($left, $right); } ","date":"2021-07-02","objectID":"/posts/php-array-sort/:2:0","tags":["PHP"],"title":"PHP 数组排序","uri":"/posts/php-array-sort/"},{"categories":["PHP"],"content":"uksort \u003c?php uksort($array, 'sort_by_key'); print_r($array); // 结果 Array ( [a] =\u003e Array ( [b] =\u003e 3 [a] =\u003e 0.03 [c] =\u003e ) [b] =\u003e Array ( [a] =\u003e 1 [c] =\u003e 0.01 [b] =\u003e ) [c] =\u003e Array ( [c] =\u003e 2 [b] =\u003e 0.02 [a] =\u003e ) ) 未完待续。。。 ","date":"2021-07-02","objectID":"/posts/php-array-sort/:2:1","tags":["PHP"],"title":"PHP 数组排序","uri":"/posts/php-array-sort/"},{"categories":["Go"],"content":"Go 是互联网时代的 C 语言，此言非虚，但凡看看市场的招聘需求，不得不让人跃跃欲试，与其说是主动出击，倒不如说是裹挟前进。好吧，我表示学不动了。 Go 起步 Go 数据类型 Go 日期时间 Go 随机数 Go 单元测试 Go 基准测试 Go 其它测试 Go 正确姿势 Go 连接字符串 Go is an open source programming language that makes it easy to build simple, reliable, and efficient software. Go 是有表现力的、简洁的、干净的和高效的。它的并发机制使编写程序更容易，以最大限度地利用多核和联网机器，而其新颖的类型系统使程序构造灵活和模块化。Go 可以快速编译成机器码，同时还具有垃圾收集的便利和运行时反射的强大功能。它是一种快速、静态类型的编译语言，感觉就像一种动态类型的解释语言。 Go 有很多特性，有一些是独特的，有一些是借鉴其它编程语言的： 内置并发编程支持： 使用协程（Goroutine）做为基本的计算单元。轻松地创建协和； 使用通道（Channel）来实现协程间的同步和通信； 内置了映射（Map）和切片（Slice）类型； 支持多态（Polymorphism）； 使用接口（Interface）来实现装盒（Value Boxing）和反射（Reflection）； 支持指针（Pointer）； 支持函数闭包（Closure）； 支持方法（Method）； 支持延迟函数调用（Defer）； 支持类型内嵌（Type Embeding）； 支持类型推断（Type Deduction or Type Inference）； 内存安全； 自动垃圾回收； 良好的代码跨平台； 比较简洁的语法； 比较齐全的标准库； 活跃和快速响应的社区，社区三方包和应用 还有一个统一的称号 gopher - ['ɡoʊfə]，即 地鼠，尽管其它语言也有类似的； ","date":"2021-06-26","objectID":"/posts/go-get-started/:0:0","tags":["Go"],"title":"Go 起步","uri":"/posts/go-get-started/"},{"categories":["Go"],"content":"安装 Go installer // 通过 brew 命令安装 Go \u003e brew install go // 验证已经安装的 Go 版本 \u003e go version go version go1.17.2 darwin/arm64 ","date":"2021-06-26","objectID":"/posts/go-get-started/:1:0","tags":["Go"],"title":"Go 起步","uri":"/posts/go-get-started/"},{"categories":["Go"],"content":"命令 Go 语言内置的所有命令： Go is a tool for managing Go source code. Usage: go \u003ccommand\u003e [arguments] The commands are: bug start a bug report build compile packages and dependencies clean remove object files and cached files doc show documentation for package or symbol env print Go environment information fix update packages to use new APIs fmt gofmt (reformat) package sources generate generate Go files by processing source get add dependencies to current module and install them install compile and install packages and dependencies list list packages or modules mod module maintenance run compile and run Go program test test packages tool run specified go tool version print Go version vet report likely mistakes in packages Use \"go help \u003ccommand\u003e\" for more information about a command. Additional help topics: buildconstraint build constraints buildmode build modes c calling between Go and C cache build and test caching environment environment variables filetype file types go.mod the go.mod file gopath GOPATH environment variable gopath-get legacy GOPATH go get goproxy module proxy protocol importpath import path syntax modules modules, module versions, and more module-get module-aware go get module-auth module authentication using go.sum packages package lists and patterns private configuration for downloading non-public code testflag testing flags testfunc testing functions vcs controlling version control with GOVCS Use \"go help \u003ctopic\u003e\" for more information about that topic. ","date":"2021-06-26","objectID":"/posts/go-get-started/:2:0","tags":["Go"],"title":"Go 起步","uri":"/posts/go-get-started/"},{"categories":["Go"],"content":"配置 配置 Go PATH 路径： // 打开 .zshrc 或者 .bashrc，之所以这样设置是因为本人不喜欢 go 目录直接设置到 $HOME 下，仅此而已 \u003e vim ~/.zshrc export GOPATH=\"$HOME/Codes/go\" 配置 Go ENV 环境变量： // 开启 GO111MODULE \u003e go env -w GO111MODULE=on // 配置代理，仅限大陆地区 \u003e go env -w GOPROXY=https://goproxy.cn,https://goproxy.io,direct // 查看环境变量 \u003e go evn GO111MODULE=\"on\" GOARCH=\"arm64\" GOBIN=\"\" GOCACHE=\"/Users/xxx/Library/Caches/go-build\" GOENV=\"/Users/xxx/Library/Application Support/go/env\" GOEXE=\"\" GOEXPERIMENT=\"\" GOFLAGS=\"\" GOHOSTARCH=\"arm64\" GOHOSTOS=\"darwin\" GOINSECURE=\"\" GOMODCACHE=\"/Users/xxx/Codes/go/pkg/mod\" GONOPROXY=\"\" GONOSUMDB=\"\" GOOS=\"darwin\" GOPATH=\"/Users/xxx/Codes/go\" GOPRIVATE=\"\" GOPROXY=\"https://proxy.golang.org,direct\" GOROOT=\"/opt/homebrew/Cellar/go/1.17.2/libexec\" GOSUMDB=\"sum.golang.org\" GOTMPDIR=\"\" GOTOOLDIR=\"/opt/homebrew/Cellar/go/1.17.2/libexec/pkg/tool/darwin_arm64\" GOVCS=\"\" GOVERSION=\"go1.17.2\" GCCGO=\"gccgo\" AR=\"ar\" CC=\"clang\" CXX=\"clang++\" CGO_ENABLED=\"1\" GOMOD=\"/dev/null\" CGO_CFLAGS=\"-g -O2\" CGO_CPPFLAGS=\"\" CGO_CXXFLAGS=\"-g -O2\" CGO_FFLAGS=\"-g -O2\" CGO_LDFLAGS=\"-g -O2\" PKG_CONFIG=\"pkg-config\" GOGCCFLAGS=\"-fPIC -arch arm64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/nk/dtkbhx993b57y5kt49l4qsb40000gn/T/go-build1748431349=/tmp/go-build -gno-record-gcc-switches -fno-common\" ","date":"2021-06-26","objectID":"/posts/go-get-started/:3:0","tags":["Go"],"title":"Go 起步","uri":"/posts/go-get-started/"},{"categories":["Go"],"content":"运行 切换到某个目录： cd /path/to 创建 Go 的源代码目录： \u003e mkdir hello \u003e cd hello 启用依赖管理： \u003e go mod init github.com/xxx/hello/ go: creating new go.mod: module github.com/xxx/hello 创建程序文件： \u003e touch main.go \u003e vim main.go 编写简单程序： package main import \"fmt\" func main() { fmt.Println(\"Hello World, Hello Go!\") } 编译并运行程序： \u003e go build -o main ./main.go \u003e go run . 或者 \u003e go run main.go Hello World, Hello Go! 至此，一个 Hello World 的 Go 程序已经跑起来了！ ","date":"2021-06-26","objectID":"/posts/go-get-started/:4:0","tags":["Go"],"title":"Go 起步","uri":"/posts/go-get-started/"},{"categories":["Go"],"content":"模块 在执行构建前自动分析源码中的依赖变化，识别新增依赖项并下载： \u003e go mod tidy 查询发布版本： \u003e go list -m -versions github.com/sirupsen/logrus github.com/sirupsen/logrus v0.1.0 v0.1.1 v0.2.0 v0.3.0 v0.4.0 v0.4.1 v0.5.0 v0.5.1 v0.6.0 v0.6.1 v0.6.2 v0.6.3 v0.6.4 v0.6.5 v0.6.6 v0.7.0 v0.7.1 v0.7.2 v0.7.3 v0.8.0 v0.8.1 v0.8.2 v0.8.3 v0.8.4 v0.8.5 v0.8.6 v0.8.7 v0.9.0 v0.10.0 v0.11.0 v0.11.1 v0.11.2 v0.11.3 v0.11.4 v0.11.5 v1.0.0 v1.0.1 v1.0.3 v1.0.4 v1.0.5 v1.0.6 v1.1.0 v1.1.1 v1.2.0 v1.3.0 v1.4.0 v1.4.1 v1.4.2 v1.5.0 v1.6.0 v1.7.0 v1.7.1 v1.8.0 v1.8.1 安装最新版本： \u003e go get github.com/sirupsen/logrus 安装指定版本： \u003e go get github.com/sirupsen/logrus@v1.7.0 使用 go mod edit 指定版本（假如要修改多个包版本）并用 go mod tidy 批量更新： \u003e go mod edit -require=github.com/sirupsen/logrus@v1.7.0 \u003e go mod tidy 查询当前项目的所有依赖： \u003e go list -m all 项目建立 vendor 依赖目录，如果基于 vendor 构建，需要在 go build 后面加上 -mod=vendor 参数： \u003e go mod vendor ","date":"2021-06-26","objectID":"/posts/go-get-started/:5:0","tags":["Go"],"title":"Go 起步","uri":"/posts/go-get-started/"},{"categories":["Linux"],"content":"Linux 的内核将所有外部设备都看做一个文件来操作（一切皆文件），对一个 File 的读写操作会调用内核提供的系统命令，返回一个 File Descriptor（FD 文件描述符）。而对一个 Socket 的读写也会有响应的描述符，称为 Socket File Descriptor（Socket 文件描述符），描述符就是一个数字，指向内核中的一个结构体（文件路径，数据区等一些属性）。 根据 UNIX 网络编程对 IO 模型的分类，UNIX 提供了 5 种 IO 模型。 ","date":"2021-01-21","objectID":"/posts/linux-network-io-model/:0:0","tags":["Linux"],"title":"Linux 网络 IO 模型","uri":"/posts/linux-network-io-model/"},{"categories":["Linux"],"content":"设备处理速度 内存读数据：纳秒级别； 千兆网卡读数据：微妙级别，1 微秒等于 1000 纳秒，网卡比内存慢了千倍； 磁盘读数据：毫秒级别。1 毫秒等于 10 万纳秒 ，硬盘比内存慢了 10 万倍； CPU 一个时钟周期 1 纳秒上下，内存算是比较接近 CPU 的，其他设备都等不起； CPU 处理数据的速度远大于 IO 准备数据的速度 。所以理论上 任何编程语言 都会遇到这种 CPU 处理速度和 IO 速度不匹配的问题，在网络编程中如何进行网络 IO 优化，怎么高效地利用 CPU 进行网络数据处理就变得非常重要。 ","date":"2021-01-21","objectID":"/posts/linux-network-io-model/:1:0","tags":["Linux"],"title":"Linux 网络 IO 模型","uri":"/posts/linux-network-io-model/"},{"categories":["Linux"],"content":"程序空间与内核空间 五种模型经历的两个阶段： 等待数据准备好（Waiting for the data to be ready）； 将准备好的数据，从内核空间复制到进程空间（Copying the data from the kernel to the process）； ","date":"2021-01-21","objectID":"/posts/linux-network-io-model/:2:0","tags":["Linux"],"title":"Linux 网络 IO 模型","uri":"/posts/linux-network-io-model/"},{"categories":["Linux"],"content":"五种模型概念 Linux 在处理文件和网络连接时，都需要打开和关闭 FD（File Descriptor）。每个进程都会有默认的 FD： 0：标准输入 stdin。 1：标准输出 stdout。 2：错误输出 stderr。 ","date":"2021-01-21","objectID":"/posts/linux-network-io-model/:3:0","tags":["Linux"],"title":"Linux 网络 IO 模型","uri":"/posts/linux-network-io-model/"},{"categories":["Linux"],"content":"阻塞 IO 模型 阻塞 IO 模型（Blocking IO）是最常用的 IO 模型，缺省情况下，所有文件操作都是阻塞的。以套接字为例：在进程空间中调用 recvfrom，其系统调用直到数据包到达且被复制到应用进程的缓冲区中或发生错误时才返回。在此期间一直会等待，进程从调用 recvfrom 开始到它返回的整段时间都是被阻塞的。即 recvfrom 的调用会被阻塞。 ","date":"2021-01-21","objectID":"/posts/linux-network-io-model/:3:1","tags":["Linux"],"title":"Linux 网络 IO 模型","uri":"/posts/linux-network-io-model/"},{"categories":["Linux"],"content":"非阻塞 IO 模型 非阻塞 IO 模型（Non-blocking IO），recvfrom 从应用层到内核的时候，如果缓冲区没有数据的话，就直接返回一个 EWOULDBLOCK 错误，一般对非阻塞 IO 模型进行轮询检查这个状态，看内核是不是有数据到来。即反复调用 recvfrom 等待成功指示（轮询）。 ","date":"2021-01-21","objectID":"/posts/linux-network-io-model/:3:2","tags":["Linux"],"title":"Linux 网络 IO 模型","uri":"/posts/linux-network-io-model/"},{"categories":["Linux"],"content":"IO 复用模型 IO 复用模型（IO Multiplexing），Linux 提供 select/poll，进程通过将一个或者多个 fd 传递给 select 或 poll 系统调用，阻塞在 select 操作上，这样 select/poll 可以帮我们检测到多个 fd 是否处于就绪状态。select/poll 是顺序扫描 fd 是否就绪，而且支持的 fd 数量有限，因此它的使用受到了一些制约。Linux 还提供了 epoll 系统调用，epoll 使用基于事件驱动方式代替顺序扫描，因此性能更高。当有 fd 就绪时，立即回调函数 callback。即阻塞在 select/poll/epoll，以及数据复制拷贝的这段时间。 ","date":"2021-01-21","objectID":"/posts/linux-network-io-model/:3:3","tags":["Linux"],"title":"Linux 网络 IO 模型","uri":"/posts/linux-network-io-model/"},{"categories":["Linux"],"content":"信号驱动 IO 模型 信号驱动 IO 模型（Signal Driven IO），首先开启信号曲驱动 IO 功能，并通过系统调用 Sigaction 执行一个信号处理函数（此系统调用立即返回，进程继续工作，它是非阻塞的）。当数据准备就绪时，就为该进程生成一个 SIGIO 信号，通过信号回调通知应用程序调用 recvfrom 来读取数据，并通知主循环函数处理数据。即阻塞在数据复制拷贝的这段时间。 ","date":"2021-01-21","objectID":"/posts/linux-network-io-model/:3:4","tags":["Linux"],"title":"Linux 网络 IO 模型","uri":"/posts/linux-network-io-model/"},{"categories":["Linux"],"content":"异步 IO 异步 IO（Asynchronous IO），告知内核启动某个文件，并让内核整个操作完成后（包括将数据从内核复制到用户自己的缓冲区）通知我们。这种模型与信号模型的组要区别是：信号驱动 IO 由内核通知我们何时可以开始一个 IO 操作；异步 IO 模型由内核通知我们 IO 操作何时已完成。 ","date":"2021-01-21","objectID":"/posts/linux-network-io-model/:3:5","tags":["Linux"],"title":"Linux 网络 IO 模型","uri":"/posts/linux-network-io-model/"},{"categories":["Linux"],"content":"五种模型的区别 阻塞 IO、非阻塞 IO、多路复用 IO、信号驱动 IO 都是同步 IO，五种模型在内核数据 Copy 到用户空间时都是阻塞的。 阻塞与非阻塞 IO：发起 IO 请求是否会被阻塞，如果阻塞就是传统的阻塞 IO，不如不阻塞就是非阻塞 IO； 同步与异步 IO：如果实际的 IO 读写阻塞请求过程，那么就是同步 IO，如果不阻塞，而是操作系统协助做完 IO 操作再将结果返回给你，那么就是异步 IO； ","date":"2021-01-21","objectID":"/posts/linux-network-io-model/:4:0","tags":["Linux"],"title":"Linux 网络 IO 模型","uri":"/posts/linux-network-io-model/"},{"categories":["Linux"],"content":"IO 多路复用技术 ","date":"2021-01-21","objectID":"/posts/linux-network-io-model/:5:0","tags":["Linux"],"title":"Linux 网络 IO 模型","uri":"/posts/linux-network-io-model/"},{"categories":["Linux"],"content":"应用场景 IO 多路复用就是通过一种机制，一个进程可以监视多个文件描述符，一旦某个描述符就绪（读就绪或写就绪），能够通知程序进行相应的读写操作。 当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用 IO 复用； 当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现； 服务器需要同时处理多个处于监听状态或多个连接状态的套接字； 服务器需要同时处理多个服务或多个协议的套接字； 与多进程和多线程技术相比，IO 多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。 ","date":"2021-01-21","objectID":"/posts/linux-network-io-model/:5:1","tags":["Linux"],"title":"Linux 网络 IO 模型","uri":"/posts/linux-network-io-model/"},{"categories":["Linux"],"content":"使用技术 select 关于 select 函数的系统调用和 do_select 定义。 int select(int nfds, fd_set *restrict readfds, fd_set *restrict writefds, fd_set *restrict exceptfds, struct timeval *restrict timeout); select 函数的参数 __readfds、__writefds 和 __exceptfds 表示的是被监听描述符的集合，其实就是被监听套接字的集合。 select 函数使用三个集合，表示监听的三类事件，分别是读数据事件（对应 __readfds 集合）、写数据事件（对应 __writefds 集合）和异常事件（对应 __exceptfds 集合）。 使用 select 机制来实现网络通信： 首先，我们在调用 select 函数前，可以先创建好传递给 select 函数的描述符集合，然后再创建监听套接字。而为了让创建的监听套接字能被 select 函数监控，我们需要把这个套接字的描述符加入到创建好的描述符集合中。 然后，我们就可以调用 select 函数，并把创建好的描述符集合作为参数传递给 select 函数。程序在调用 select 函数后，会发生阻塞。而当 select 函数检测到有描述符就绪后，就会结束阻塞，并返回就绪的文件描述符个数。此时，就可以在描述符集合中查找哪些描述符就绪了。 之后，就可以对已就绪描述符对应的套接字进行处理。比如，如果是 __readfds 集合中有描述符就绪，这就表明这些就绪描述符对应的套接字上，有读事件发生，此时，就在该套接字上读取数据。因为 select 函数一次可以监听 1024 个文件描述符的状态，所以 select 函数在返回时，也可能会一次返回多个就绪的文件描述符。这样一来，我们就可以使用一个循环流程，依次对就绪描述符对应的套接字进行读写或异常处理操作。 select 函数存在两个设计上的不足： select 函数对单个进程能监听的文件描述符数量是有限制的，它能监听的文件描述符个数由 __FD_SETSIZE 决定，默认值是 1024。 当 select 函数返回后，我们需要遍历描述符集合，才能找到具体是哪些描述符就绪了。这个遍历过程会产生一定开销，从而降低程序的性能。 select 函数的特点： 优点： 良好跨平台支持。 缺点： 单个进程可监视的 FD 数量被限制，即能监听端口的大小有限。一般来说这个数目和系统内存关系很大，具体数目可以 cat /proc/sys/fs/file-max 查看。32 位机默认是 1024 个。64 位机默认是 2048 个。 对 Socket 进行扫描时是线性扫描，即采用轮询的方法，效率较低：当套接字比较多的时候，每次 select() 都要通过遍历 FD_SETSIZE 个 Socket 来完成调度，不管哪个 Socket 是活跃的，都遍历一遍。这会浪费很多 CPU 时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是 epoll 与 kqueue 做的。 需要维护一个用来存放大量 FD 的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。 可以在一个线程内同时处理多个 Socket 的 IO 请求。在网络编程中，当涉及到多客户访问服务器的情况，我们首先想到的办法就是 fork 出多个进程来处理每个客户连接。现在，我们同样可以使用 select 来处理多客户问题，而不用 fork。 用 select 处理带外数据，网络程序中，select 能处理的异常情况只有一种：socket 上接收到带外数据。 带外数据：带外数据（out—of—band data），有时也称为加速数据（expedited data），是指连接双方中的一方发生重要事情，想要迅速地通知对方。这种通知在已经排队等待发送的任何普通（有时称为「带内」）数据之前发送。带外数据设计为比普通数据有更高的优先级。带外数据是映射到现有的连接中的，而不是在客户机和服务器间再用一个连接。 poll 关于 poll 函数的系统调用和 do_poll 的定义。 为了解决 select 函数受限于 1024 个文件描述符的不足，poll 函数对此做了改进。 int poll (struct pollfd *__fds, nfds_t __nfds, int __timeout); 其中，参数 *__fds 是 pollfd 结构体数组，参数 __nfds 表示的是 *__fds 数组的元素个数，而 __timeout 表示 poll 函数阻塞的超时时间。 struct pollfd { int fd; // 进行监听的文件描述符。 short int events; // 要监听的事件类型。 short int revents; // 实际发生的事件类型。 }; pollfd 结构体里包含了要监听的描述符，以及该描述符上要监听的事件类型。 使用 poll 函数完成网络通信： 第一步，创建 pollfd 数组和监听套接字，并进行绑定。 第二步，将监听套接字加入 pollfd 数组，并设置其监听读事件，也就是客户端的连接请求。 第三步，循环调用 poll 函数，检测 pollfd 数组中是否有就绪的文件描述符。 如果是连接套接字就绪，这表明是有客户端连接，我们可以调用 accept 接受连接，并创建已连接套接字，并将其加入 pollfd 数组，并监听读事件。 如果是已连接套接字就绪，这表明客户端有读写请求，我们可以调用 recv/send 函数处理读写请求。 其实，和 select 函数相比，poll 函数的改进之处主要就在于，它允许一次监听超过 1024 个文件描述符。但是当调用了 poll 函数后，我们仍然需要遍历每个文件描述符，检测该描述符是否就绪，然后再进行处理。 poll 函数的特点： 优点： 用 pollfd 数组代替了 bitmap，没有最大文件描述符数量的限制。 利用结构体 pollfd，每次置位 revents 字段，每次只需恢复 revents 即可。pollfd 可重用。 缺点： 和 select 一样，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。 同 select 一样，内核需要将消息传递到用户空间，都需要内核拷贝动作。 和 select 函数一样，poll 返回后，需要轮询 pollfd 来获取就绪的描述符。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。 epoll 为了避免遍历每个描述符呢，使用 epoll 机制实现 IO 多路复用。 epoll 函数的特点： 优点： 没有最大并发连接的限制，能打开的 FD 的上限远大于 1024（1G 的内存上能监听约 10 万个端口）。 IO 效率不会随着 FD 数目的增加而线性下将，只有活跃可用的 FD 才会调用 callback 函数。 内存拷贝，利用 mmap 文件映射内存加速与内核空间的消息传递。epoll 使用 mmap 减少复制开销，即 epoll 使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。 通过内核和用户空间共享一块内存来实现，不需要内核拷贝动作。 epoll 拥有更加简单的 API。 缺点： epoll 每次只遍历活跃的 fd（如果是 LT，也会遍历先前活跃的 fd），在活跃 fd 较少的情况下就会很有优势，如果大部分 fd 都是活跃的，epoll 的效率可能还不如 select/poll。 epoll 对文件描述符的操作有两种模式： LT（Level Trigger，水平触发）模式：是缺省的工作方式，并且同时支持 block 和 non-block socket。当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 epoll_wait 时，会再次响应应用程序并通知此事件，这种机制可以比较好的保证每个数据用户都处理掉了。 ET（Edge Trigger，边缘触发）模式：是高速工作方式，只支持 non-block socket。,当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此事件。简而言之，就是内核通知过的事情不会再说第二遍，数据错过没读，你自己负责。这种机制确实速度提高了，但是风险相伴而行。 ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。 ","date":"2021-01-21","objectID":"/posts/linux-network-io-model/:5:2","tags":["Linux"],"title":"Linux 网络 IO 模型","uri":"/posts/linux-network-io-model/"},{"categories":["Linux"],"content":"技术区别 select poll epoll 事件集合 用户每次调用将重置可读可写及异常事件参数，内核通过参数在线修改来反馈其中的就绪事件 统一处理所有事件类型，仅一个事件参数，用户通过 pollfd.events 传入感兴趣的事件，内核通过修改 pollfd.revents 参数反馈其中就绪的事件 内核通过一个事件直接管理用户感兴趣的所有事件，每次调用 epoll_wait 时，无需反复传入用户感兴趣的事件，epoll_wait 系统调用的参数 events 仅用来反馈就绪的事件 工作原则 采用轮询方式检测就绪事件，时间复杂度：O(n) 采用轮询方式检测就绪事件，时间复杂度：O(n) 采用回调方式检测就绪事件，时间复杂度：O(1) 最大连接 1024 无上限 无上限 工作模式 LT LT LT 和 ET 文件描述 每次调用，每次拷贝 每次调用，每次拷贝 通过 mmap 的内存映射技术，降低拷贝的资源消耗 ","date":"2021-01-21","objectID":"/posts/linux-network-io-model/:5:3","tags":["Linux"],"title":"Linux 网络 IO 模型","uri":"/posts/linux-network-io-model/"},{"categories":["Linux"],"content":"参考 Async IO on Linux: select, poll, and epoll Socket programming Elixir Cross Referencer - Quick View Code ","date":"2021-01-21","objectID":"/posts/linux-network-io-model/:6:0","tags":["Linux"],"title":"Linux 网络 IO 模型","uri":"/posts/linux-network-io-model/"},{"categories":["Git"],"content":"通往 Git 的路上并不总是那么一帆风顺，你是否和我一样总是为了那么一条应景的命令抓狂，貌似记得大概是这么操作的，但总是敲不对头，在披荆斩棘的千钧一发利刃竟然还没出鞘，真特么气人，为了解燃眉之急，我垫了一块超大的 Git 命令大全，但那是别人家的，我要的是自己收集整理的这种，还好，我整理了一份，总算是出了口恶气。 Git 起步 Git 基本操作 Git 查看日志 Git 分支 Git 中一个客户端设置多个账号 Git Workflow Git 命令大全 ","date":"2020-09-07","objectID":"/posts/git-collection-command/:0:0","tags":["Git"],"title":"Git 命令大全","uri":"/posts/git-collection-command/"},{"categories":["Git"],"content":"Git 命令分类 配置操作； 基本操作； 分支操作； 合并操作； 标签操作； 回滚操作； 日志操作； 远程操作； 统计操作； ","date":"2020-09-07","objectID":"/posts/git-collection-command/:1:0","tags":["Git"],"title":"Git 命令大全","uri":"/posts/git-collection-command/"},{"categories":["Git"],"content":"git filter-repo Quickly rewrite git repository history git-filter-repo manual page // 安装 git-filter-repo $ brew install git-filter-repo // 将用户名 tony 替换为 pony $ git-filter-repo --name-callback 'return name.replace(b\"tony\", b\"pony\")' --force // 将邮箱 foo@gmail.com 替换为 bar@gmail.com $ git-filter-repo --email-callback 'return email.replace(b\"foo@gmail.com\", b\"bar@gmail.com\")' --force ","date":"2020-09-07","objectID":"/posts/git-collection-command/:2:0","tags":["Git"],"title":"Git 命令大全","uri":"/posts/git-collection-command/"},{"categories":["Git"],"content":"git blame // 查找指定文件的第 40-60 行的历史信息 $ git blame -L 40,60 /path/to/file.txt 另外，这一篇写的太水了，见谅。 ","date":"2020-09-07","objectID":"/posts/git-collection-command/:3:0","tags":["Git"],"title":"Git 命令大全","uri":"/posts/git-collection-command/"},{"categories":["Redis"],"content":"Redis 是一个 K-V 存储系统，是一个高性能的 K-V 数据库，是目前大规模使用的缓存中间件。单节点的Redis 已经就达到了很高的性能，为了提高可用性我们可以使用 Redis 集群。 Redis Website ","date":"2020-01-16","objectID":"/posts/redis-cluster/:0:0","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"集群简介 Redis 集群是一个可以在多个 Redis 节点之间进行数据共享的设施（installation）。 Redis 集群不支持那些需要同时处理多个键的 Redis 命令， 因为执行这些命令需要在多个 Redis 节点之间移动数据， 并且在高负载的情况下， 这些命令将降低 Redis 集群的性能，并导致不可预测的行为。 Redis 集群通过分区（partition）来提供一定程度的可用性（availability）：即使集群中有一部分节点失效或者无法进行通讯，集群也可以继续处理命令请求。 Redis 集群提供了以下两个好处： 将数据自动切分（split）到多个节点的能力 当集群中的一部分节点失效或者无法进行通讯时，仍然可以继续处理命令请求的能力 ","date":"2020-01-16","objectID":"/posts/redis-cluster/:1:0","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"集群说明 ","date":"2020-01-16","objectID":"/posts/redis-cluster/:2:0","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"集群数据共享 Redis 集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现：一个 Redis 集群包含 16384 个哈希槽（hash slot），数据库中的每个键都属于这 16384 个哈希槽的其中一个，集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽，其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和。 ","date":"2020-01-16","objectID":"/posts/redis-cluster/:2:1","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"集群中的每个节点负责处理一部分哈希槽 一个集群可以有三个哈希槽，其中： 节点 A 负责处理 0 号至 5500 号哈希槽 节点 B 负责处理 5501 号至 11000 号哈希槽 节点 C 负责处理 11001 号至 16384 号哈希槽 ","date":"2020-01-16","objectID":"/posts/redis-cluster/:2:2","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"集群中的主从复制 为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下，仍然可以正常运作，Redis 集群对节点使用了主从复制功能：集群中的每个节点都有 1 个至 N 个复制品（replica），其中一个复制品为主节点（master），而其余的 N-1 个复制品为从节点（slave） ","date":"2020-01-16","objectID":"/posts/redis-cluster/:2:3","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"集群 TCP 端口 每个 Redis Cluster 节点都需要 2 个 TCP 连接打开，正常的 Redis TCP 端口被服务于客户端，例如：6379，加上通过增加 10000 到数据端口获取的端口，例如：16379。 第二个高端口被用来 Redis Cluster Bus，也就是使用二进制协议的一个节点到节点的通信信道。Redis Cluster Bus 被节点用于故障检测，配置更新，故障转移授权等等。客户端不应该尝试与 Redis Cluster Bus 端口进行通信，而是始终使用正常的 Redis 命令端口，然而要确保在防火墙中打开两个端口，否则 Redis Cluster 节点将无法通信。 命令端口和 Redis Cluster Bus 端口偏移是固定的，始终为 10000。 注意，为了使 Redis Cluster 正常工作，你需要为每个节点： 用于客户端进行通信的普通客户端通信端口（通常使用 6379）对所有需要到达集群的客户端，以及所有其它集群节点（使用客户端端口进行密钥迁移）都是开放的 Redis Cluster Bus 端口（客户端端口 +10000）必须可从所有其它集群节点访问 如果不打开两个 TCP 端口，集群将无法按预期工作 Redis Cluster Bus 使用不同的二进制协议进行节占到节点的数据交换，这更适合于使用少量的带宽和处理时间交换节点之间的信息 ","date":"2020-01-16","objectID":"/posts/redis-cluster/:2:4","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"安装依赖 $ sudo gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 $ sudo curl -sSL https://get.rvm.io | bash -s stable $ sudo source ~/.rvm/scripts/rvm $ sudo echo \"ruby_url=https://cache.ruby-china.org/pub/ruby\" \u003e ~/.rvm/user/db $ rvm -v $ sudo rvm install 2.4.1 $ sudo gem update $ sudo gem install redis ","date":"2020-01-16","objectID":"/posts/redis-cluster/:3:0","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"集群配置 ","date":"2020-01-16","objectID":"/posts/redis-cluster/:4:0","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"安装 Redis $ cd ~ $ wget http://download.redis.io/releases/redis-4.0.9.tar.gz $ tar xzf redis-4.0.9.tar.gz $ cd redis-4.0.9 $ sudo make ","date":"2020-01-16","objectID":"/posts/redis-cluster/:4:1","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"创建配置目录 $ sudo mkdir -pv /usr/local/redis-cluster/{bin,etc,log,run,var} ","date":"2020-01-16","objectID":"/posts/redis-cluster/:4:2","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"创建配置文件 $ sudo cp ~/redis-4.0.9/redis.conf /usr/local/redis-cluster/etc/redis-7001.conf ","date":"2020-01-16","objectID":"/posts/redis-cluster/:4:3","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"复制命令文件 $ cd ~/redis-4.0.9/src/ $ sudo cp mkreleasehdr.sh redis-benchmark redis-check-aof redis-check-rdb redis-sentinel redis-cli redis-server /usr/local/redis-cluster/bin ","date":"2020-01-16","objectID":"/posts/redis-cluster/:4:4","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"修改配置文件 $ sudo vim /usr/local/redis-cluster/etc/redis-7001.conf bind 192.168.33.110 port 7001 daemonize yes pidfile /user/local/redis-cluster/run/7001.pid logfile /usr/local/redis-cluster/log/7001.log dbfilename dump-7001.rdb dir /usr/local/redis-cluster/var appendonly yes appendfilename \"appendonly-7001.aof\" cluster-enabled yes cluster-config-file nodes-7001.conf cluster-node-timeout 15000 ","date":"2020-01-16","objectID":"/posts/redis-cluster/:4:5","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"复制配置文件 将复制后的文件中的 7001 换成相应的名称 $ sudo cp /usr/local/redis-cluster/etc/redis-7001.conf /usr/local/redis-cluster/etc/redis-7002.conf $ sudo cp /usr/local/redis-cluster/etc/redis-7001.conf /usr/local/redis-cluster/etc/redis-7003.conf $ sudo cp /usr/local/redis-cluster/etc/redis-7001.conf /usr/local/redis-cluster/etc/redis-7004.conf $ sudo cp /usr/local/redis-cluster/etc/redis-7001.conf /usr/local/redis-cluster/etc/redis-7005.conf $ sudo cp /usr/local/redis-cluster/etc/redis-7001.conf /usr/local/redis-cluster/etc/redis-7006.conf ","date":"2020-01-16","objectID":"/posts/redis-cluster/:4:6","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"集群部署 ","date":"2020-01-16","objectID":"/posts/redis-cluster/:5:0","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"启动节点 // 启动配置的所有节点 $ sudo /usr/local/redis-cluster/bin/redis-cli /usr/local/redis-cluster/etc/redis-7001.conf $ sudo /usr/local/redis-cluster/bin/redis-cli /usr/local/redis-cluster/etc/redis-7002.conf $ sudo /usr/local/redis-cluster/bin/redis-cli /usr/local/redis-cluster/etc/redis-7003.conf $ sudo /usr/local/redis-cluster/bin/redis-cli /usr/local/redis-cluster/etc/redis-7004.conf $ sudo /usr/local/redis-cluster/bin/redis-cli /usr/local/redis-cluster/etc/redis-7005.conf $ sudo /usr/local/redis-cluster/bin/redis-cli /usr/local/redis-cluster/etc/redis-7006.conf ","date":"2020-01-16","objectID":"/posts/redis-cluster/:5:1","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"检查服务 $ ps -ef | grep redis root 20077 1 0 May18 ? 00:01:04 /usr/local/bin/redis-server 192.168.33.110:7001 [cluster] root 20079 1 0 May18 ? 00:01:03 /usr/local/bin/redis-server 192.168.33.110:7002 [cluster] root 20081 1 0 May18 ? 00:01:03 /usr/local/bin/redis-server 192.168.33.110:7003 [cluster] root 20089 1 0 May18 ? 00:01:03 /usr/local/bin/redis-server 192.168.33.110:7004 [cluster] root 20091 1 0 May18 ? 00:01:03 /usr/local/bin/redis-server 192.168.33.110:7005 [cluster] root 20096 1 0 May18 ? 00:01:03 /usr/local/bin/redis-server 192.168.33.110:7006 [cluster] ","date":"2020-01-16","objectID":"/posts/redis-cluster/:5:2","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"停止节点 $ sudo /usr/local/redis-cluster/bin/redis-cli -c -h 192.168.33.110 -p 7001 shutdown ","date":"2020-01-16","objectID":"/posts/redis-cluster/:5:3","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"节点加入集群 $ sudo cp ~/redis-4.0.9/src/redis-trib.rb /usr/local/redis-cluster/bin/redis-trib $ sudo chmod a+x /usr/local/redis-cluster/bin/redis-trib $ sudo /usr/local/redis-cluster/bin/redis-trib create --replicas 1 \\ \u003e 192.168.33.110:7001 \\ \u003e 192.168.33.110:7002 \\ \u003e 192.168.33.110:7003 \\ \u003e 192.168.33.110:7004 \\ \u003e 192.168.33.110:7005 \\ \u003e 192.168.33.110:7006 \\ \u003e\u003e\u003e Creating cluster \u003e\u003e\u003e Performing hash slots allocation on 6 nodes... Using 3 masters: 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 Adding replica 127.0.0.1:7005 to 127.0.0.1:7001 Adding replica 127.0.0.1:7006 to 127.0.0.1:7002 Adding replica 127.0.0.1:7004 to 127.0.0.1:7003 \u003e\u003e\u003e Trying to optimize slaves allocation for anti-affinity [WARNING] Some slaves are in the same host as their master M: 4ed7d8f54311fb883431c1c5a4715c1ae59d5215 127.0.0.1:7001 slots:0-5460 (5461 slots) master M: 31030e4c35659d5de1146941a2d1f2c1524b53e9 127.0.0.1:7002 slots:5461-10922 (5462 slots) master M: 573752b8b0747bc2c7bb3e4a1edb0e467cfdef0e 127.0.0.1:7003 slots:10923-16383 (5461 slots) master S: 11f577639b081c1514f28a74764c9330d819dcb8 127.0.0.1:7004 replicates 573752b8b0747bc2c7bb3e4a1edb0e467cfdef0e S: ff6d7ca3ea29036385c89a5dc93f807f91307871 127.0.0.1:7005 replicates 4ed7d8f54311fb883431c1c5a4715c1ae59d5215 S: a6f79f4d1de8d7bef4911e934b802829ed29a2d3 127.0.0.1:7006 replicates 31030e4c35659d5de1146941a2d1f2c1524b53e9 Can I set the above configuration? (type 'yes' to accept): yes \u003e\u003e\u003e Nodes configuration updated \u003e\u003e\u003e Assign a different config epoch to each node \u003e\u003e\u003e Sending CLUSTER MEET messages to join the cluster Waiting for the cluster to join.. \u003e\u003e\u003e Performing Cluster Check (using node 127.0.0.1:7001) M: 4ed7d8f54311fb883431c1c5a4715c1ae59d5215 127.0.0.1:7001 slots:0-5460 (5461 slots) master 1 additional replica(s) S: 11f577639b081c1514f28a74764c9330d819dcb8 127.0.0.1:7004 slots: (0 slots) slave replicates 573752b8b0747bc2c7bb3e4a1edb0e467cfdef0e S: a6f79f4d1de8d7bef4911e934b802829ed29a2d3 127.0.0.1:7006 slots: (0 slots) slave replicates 31030e4c35659d5de1146941a2d1f2c1524b53e9 S: ff6d7ca3ea29036385c89a5dc93f807f91307871 127.0.0.1:7005 slots: (0 slots) slave replicates 4ed7d8f54311fb883431c1c5a4715c1ae59d5215 M: 31030e4c35659d5de1146941a2d1f2c1524b53e9 127.0.0.1:7002 slots:5461-10922 (5462 slots) master 1 additional replica(s) M: 573752b8b0747bc2c7bb3e4a1edb0e467cfdef0e 127.0.0.1:7003 slots:10923-16383 (5461 slots) master 1 additional replica(s) [OK] All nodes agree about slots configuration. \u003e\u003e\u003e Check for open slots... \u003e\u003e\u003e Check slots coverage... [OK] All 16384 slots covered. 可以看到，创建集群这个过程比较繁琐，可以创建脚本来完成这些操作 启动脚本 $ sudo vim /usr/local/redis-cluster/bin/start.sh #!/usr/bin/env bash RedisServerPath=/usr/local/redis-cluster/bin RedisConfPath=/usr/local/redis-cluster/etc for i in 1 2 3 4 5 6; do $RedisServerPath/redis-server $RedisConfPath/redis-700$i.conf done /usr/local/redis-cluster/bin/redis-trib.rb create --replicas 1 \\ 192.168.33.110:7001 \\ 192.168.33.110:7002 \\ 192.168.33.110:7003 \\ 192.168.33.110:7004 \\ 192.168.33.110:7005 \\ 192.168.33.110:7006 \\ $ sudo chmod a+x /usr/local/redis-cluster/bin/start.sh 停止脚本 $ sudo vim /usr/local/redis-cluster/bin/stop.sh #!/usr/bin/env bash RedisClusterPath=/usr/local/redis-cluster RedisCliPath=/usr/local/redis-cluster/bin ip=192.168.33.110 for i in 1 2 3 4 5 6; do $RedisCliPath/redis-cli -c -h $ip -p 700$i shutdown done rm -rf $RedisClusterPath/log/* rm -rf $RedisClusterPath/run/* rm -rf $RedisClusterPath/var/* $ sudo chmod a+x /usr/local/redis-cluster/bin/stop.sh ","date":"2020-01-16","objectID":"/posts/redis-cluster/:5:4","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"查看信息 $ /usr/local/redis-cluster/bin/redis-cli -c -h 192.168.33.110 -p 7001 192.168.33.110:7001\u003e cluster nodes # 查看节点信息 5521b06a46910c873e7ee8a274f2cb9fc41ffed1 192.168.33.110:7003@17003 master - 0 1526681994008 3 connected 10923-16383 8153a1b35e0fab1e48f0171653f6cffd82cbc5a6 192.168.33.110:7004@17004 slave d7e0395152496f41fe73fbbdabc8499c79f6632e 0 1526681996033 4 connected a2ff29661185f6ad17c99232d0490b3814ba0164 192.168.33.110:7006@17006 slave affc237bf177fd4ac591314736a1358e16545d0c 0 1526681995020 6 connected d7e0395152496f41fe73fbbdabc8499c79f6632e 192.168.33.110:7002@17002 master - 0 1526681993000 2 connected 5461-10922 8b613e4b5abbdf3c2486dfcb8bc1e9dde1897820 192.168.33.110:7005@17005 slave 5521b06a46910c873e7ee8a274f2cb9fc41ffed1 0 1526681993000 5 connected affc237bf177fd4ac591314736a1358e16545d0c 192.168.33.110:7001@17001 myself,master - 0 1526681994000 1 connected 0-5460 192.168.33.110:7001\u003e cluster info # 查看集群信息 cluster_state:ok cluster_slots_assigned:16384 cluster_slots_ok:16384 cluster_slots_pfail:0 cluster_slots_fail:0 cluster_known_nodes:6 cluster_size:3 cluster_current_epoch:6 cluster_my_epoch:1 cluster_stats_messages_ping_sent:59501 cluster_stats_messages_pong_sent:61755 cluster_stats_messages_sent:121256 cluster_stats_messages_ping_received:61750 cluster_stats_messages_pong_received:59501 cluster_stats_messages_meet_received:5 cluster_stats_messages_received:121256 ","date":"2020-01-16","objectID":"/posts/redis-cluster/:5:5","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"相关命令 命令 说明 CLUSTER INFO 打印集群信息 CLUSTER NODES 列出集群当前已知的所有节点信息 CLUSTER MEET \u003cip\u003e \u003cport\u003e 将 ip 和 port 所指定的节点添加到集群当中 CLUSTER FORGET \u003cnode_id\u003e 从集群中移除 node_id 指定的节点 CLUSTER REPLICATE \u003cnode_id\u003e 将当前节点设置为 node_id 指定的节点的从节点 CLUSTER SAVECONFIG 将节点的配置文件保存到硬盘里面 CLUSTER ADDSLOTS \u003cslot\u003e [slot ...] 将一个或多个槽（slot）指派（assign）给当前节点 CLUSTER DELSLOTS \u003cslot\u003e [slot ...] 移除一个或多个槽对当前节点的指派 CLUSTER FLUSHSLOTS 移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点 CLUSTER SETSLOT \u003cslot\u003e NODE \u003cnode_id\u003e 将槽 slot 指派给 node_id 指定的节点，如果槽已经指派给另一个节点，那么先让另一个节点删除该槽，然后再进行指派 CLUSTER SETSLOT \u003cslot\u003e MIGRATING \u003cnode_id\u003e 将本节点的槽 slot 迁移到 node_id 指定的节点中 CLUSTER SETSLOT \u003cslot\u003e IMPORTING \u003cnode_id\u003e 从 node_id 指定的节点中导入槽 slot 到本节点 CLUSTER SETSLOT \u003cslot\u003e STABLE 取消对槽 slot 的导入（import）或者迁移（migrate） CLUSTER KEYSLOT \u003ckey\u003e 计算键 key 应该被放置在哪个槽上 CLUSTER COUNTKEYSINSLOT \u003cslot\u003e 返回槽 slot 目前包含的键值对数量 CLUSTER GETKEYSINSLOT \u003cslot\u003e \u003ccount\u003e 返回 count 个 slot 槽中的键 ","date":"2020-01-16","objectID":"/posts/redis-cluster/:5:6","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"实例操作 ","date":"2020-01-16","objectID":"/posts/redis-cluster/:6:0","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"客户端操作 // 从某个节点设置值后，去不同的节点获取设置的值 $ /usr/local/redis-cluster/bin/redis-cli -c -h 192.168.33.110 -p 7001 192.168.33.110:7001\u003e set foo bar -\u003e Redirected to slot [12182] located at 192.168.33.110:7003 OK $ /usr/local/redis-cluster/bin/redis-cli -c -h 192.168.33.110 -p 7001 192.168.33.110:7001\u003e get foo -\u003e Redirected to slot [12182] located at 192.168.33.110:7003 \"bar\" $ /usr/local/redis-cluster/bin/redis-cli -c -h 192.168.33.110 -p 7002 192.168.33.110:7002\u003e get foo -\u003e Redirected to slot [12182] located at 192.168.33.110:7003 \"bar\" $ /usr/local/redis-cluster/bin/redis-cli -c -h 192.168.33.110 -p 7003 192.168.33.110:7003\u003e get foo \"bar\" $ /usr/local/redis-cluster/bin/redis-cli -c -h 192.168.33.110 -p 7004 192.168.33.110:7004\u003e get foo -\u003e Redirected to slot [12182] located at 192.168.33.110:7003 \"bar\" $ /usr/local/redis-cluster/bin/redis-cli -c -h 192.168.33.110 -p 7005 192.168.33.110:7005\u003e get foo -\u003e Redirected to slot [12182] located at 192.168.33.110:7003 \"bar\" $ /usr/local/redis-cluster/bin/redis-cli -c -h 192.168.33.110 -p 7006 192.168.33.110:7006\u003e get foo -\u003e Redirected to slot [12182] located at 192.168.33.110:7003 \"bar\" ","date":"2020-01-16","objectID":"/posts/redis-cluster/:6:1","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Redis"],"content":"程序操作 下载安装 Flexible and feature-complete Redis client for PHP and HHVM Quick tour $ cd ~ $ mkdir test $ cd test $ composer init $ composer install $ composer require predis/predis 测试代码 \u003c?php require __DIR__ . '/vendor/autoload.php'; for ($i = 0; $i \u003c 6; $i++) { $parameters[] = [ 'host' =\u003e '192.168.33.110', 'port' =\u003e '700' . $i, 'password' =\u003e null, 'database' =\u003e 0, 'timeout' =\u003e 5, 'read_write_timeout' =\u003e 5, ]; } $options = ['cluster' =\u003e 'redis']; try { $cluster = new \\Predis\\Client($parameters, $options); } catch (\\Predis\\PredisException $e) { echo $e-\u003egetMessage(); exit(); } for ($i = 1; $i \u003c 100; $i++) { $format = 'No.%s is a RedisCluster test.'; $cluster-\u003eset(\"$i\", sprintf($format, $i)); echo $cluster-\u003eget(\"$i\") . PHP_EOL; } 测试结果 $ php cluster.php No.1 is a Redis cluster test. No.2 is a Redis cluster test. No.3 is a Redis cluster test. ... No.99 is a Redis cluster test. $ /usr/local/redis-cluster/bin/redis-cli -c -h 192.168.33.110 -p 7001 192.168.33.110:7001\u003e get 11 \"No.11 is a RedisCluster test.\" 192.168.33.110:7001\u003e get 23 -\u003e Redirected to slot [9671] located at 192.168.33.110:7002 \"No.23 is a RedisCluster test.\" 192.168.33.110:7002\u003e get 33 \"No.33 is a RedisCluster test.\" 192.168.33.110:7002\u003e get 67 \"No.67 is a RedisCluster test.\" 192.168.33.110:7002\u003e get 88 -\u003e Redirected to slot [15207] located at 192.168.33.110:7003 \"No.88 is a RedisCluster test.\" 192.168.33.110:7003\u003e get 99 -\u003e Redirected to slot [6263] located at 192.168.33.110:7002 \"No.99 is a RedisCluster test.\" 192.168.33.110:7002\u003e get 100 -\u003e Redirected to slot [339] located at 192.168.33.110:7001 (nil) 192.168.33.110:7001\u003e get 17 -\u003e Redirected to slot [12304] located at 192.168.33.110:7003 \"No.17 is a RedisCluster test.\" 192.168.33.110:7003\u003e get 42 -\u003e Redirected to slot [8000] located at 192.168.33.110:7002 \"No.42 is a RedisCluster test.\" 192.168.33.110:7002\u003e get 56 -\u003e Redirected to slot [11509] located at 192.168.33.110:7003 \"No.56 is a RedisCluster test.\" 192.168.33.110:7003\u003e get 61 -\u003e Redirected to slot [2369] located at 192.168.33.110:7001 \"No.61 is a RedisCluster test.\" ","date":"2020-01-16","objectID":"/posts/redis-cluster/:6:2","tags":["Redis"],"title":"Redis 集群搭建","uri":"/posts/redis-cluster/"},{"categories":["Linux"],"content":"Crontab 命令被用来提交和管理用户的需要周期性执行的任务。 ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:0:0","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"简介 通过 crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script 脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。 ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:1:0","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"选项 -e：编辑该用户的计时器设置； -l：列出该用户的计时器设置； -r：删除该用户的计时器设置； -u\u003cusername\u003e：指定要设定计时器的用户名称。 ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:2:0","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"任务调度 ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:3:0","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"系统任务调度 系统任务调度 是系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在 /etc 目录下有一个 crontab 文件，这个就是系统任务调度的配置文件。 /etc/crontab 文件包括下面几行： SHELL=/bin/bash # SHELL变量指定了系统要使用哪个 shell，这里是 bash PATH=/sbin:/bin:/usr/sbin:/usr/bin # PATH 变量指定了系统执行命令的路径 MAILTO=\"\" # MAILTO 变量指定了 crond 的任务执行信息将通过电子邮件发送给 root 用户，如果 MAILTO 变量的值为空，则表示不发送任务执行信息给用户 HOME=/ # HOME 变量指定了在执行命令或者脚本时使用的主目录 # run-parts 51 * * * * root run-parts /etc/cron.hourly 24 7 * * * root run-parts /etc/cron.daily 22 4 * * 0 root run-parts /etc/cron.weekly 42 4 1 * * root run-parts /etc/cron.monthly ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:3:1","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"用户任务调度 用户任务调度 是用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的 crontab 文件都被保存在 /var/spool/cron 目录中。其文件名与用户名一致，使用者权限文件如下： /etc/cron.deny 该文件中所列用户不允许使用 crontab 命令； /etc/cron.allow 该文件中所列用户允许使用 crontab 命令； /var/spool/cron/ 所有用户 crontab 文件存放的目录，以用户名命名。 ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:3:2","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"文件格式 在以上各个字段中，还可以使用以下特殊字符： *：代表所有可能的值，例如 month 字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作； ,：可以用逗号隔开的值指定一个列表范围，例如：1,2,5,7,8,9； -：可以用整数之间的中杠表示一个整数范围，例如：2-6 表示 2,3,4,5,6； /：可以用正斜线指定时间的间隔频率，例如：0-23/2 表示每两小时执行一次。同时正斜线可以和星号一起使用，例如：*/10，如果用在 minute 字段，表示每十分钟执行一次。 ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:4:0","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"使用实例 {% note info %} 最好在 crontab 文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的定时作业。 {%endnote %} ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:5:0","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"每 1 分钟执行一次命令 * * * * * command ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:5:1","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"每小时的第 3 和第 15 分钟执行 3,15 * * * * command ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:5:2","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"上午 8 点到 11 点的第 3 和第 15 分钟执行 3,15 8-11 * * * command ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:5:3","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"每隔两天的上午 8 点到 11 点的第 3 和第 15 分钟执行 3,15 8-11 */2 * * command ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:5:4","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"每个星期一的上午 8 点到 11 点的第 3 和第 15 分钟执行 3,15 8-11 * * 1 command ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:5:5","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"每晚的 21:30 重启 smb 30 21 * * * /etc/init.d/smb restart ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:5:6","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"每月 1、10、22 日的 4:45 重启 smb 45 4 1,10,22 * * /etc/init.d/smb restart ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:5:7","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"每周六、周日的 1:10 重启 smb 10 1 * * 6,0 /etc/init.d/smb restart ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:5:8","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"每天 18:00 至 23:00 之间每隔 30 分钟重启 smb 0,30 18-23 * * * /etc/init.d/smb restart ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:5:9","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"每星期六的晚上 11:00 PM 重启 smb 0 23 * * 6 /etc/init.d/smb restart ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:5:10","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"每一小时重启 smb * */1 * * * /etc/init.d/smb restart ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:5:11","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"晚上 11 点到早上 7 点之间，每隔一小时重启 smb * 23-7/1 * * * /etc/init.d/smb restart ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:5:12","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"每月的 4 号与每周一到周三的 11 点重启 smb 0 11 4 * mon-wed /etc/init.d/smb restart ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:5:13","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"一月一号的 4 点重启 smb 0 4 1 jan * /etc/init.d/smb restart ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:5:14","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"每小时执行 /etc/cron.hourly 目录内的脚本 01 * * * * root run-parts /etc/cron.hourly ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:5:15","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"参考 crontab guru ","date":"2019-12-29","objectID":"/posts/linux-crontab-command/:6:0","tags":["Linux"],"title":"Linux crontab 命令","uri":"/posts/linux-crontab-command/"},{"categories":["Linux"],"content":"是时候体验下 iproute2 网络配置工具全家桶了，net-tools 家族有的 iproute2 一样也不差。我起初也不知道，直到新买的百度云服务器查看地址时出现command not found，才查阅资料了解了一下，原来 net-tools 这货已经寿终正寝了。Arch Linux 和 CentOS 已经完全抛弃了 net-tools，只支持 iproute2。 ","date":"2019-12-04","objectID":"/posts/linux-network-conf-tools/:0:0","tags":["Linux"],"title":"Linux 网络配置工具","uri":"/posts/linux-network-conf-tools/"},{"categories":["Linux"],"content":"net-tools net-tools 命令 描述 ifconfig -a 显示所有已连接的网络接口 sudo ifconfig eth1 up 激活网络接口 sudo ifconfig eth1 down 停用网络接口 sudo ifconfig eth1 10.0.0.1/24 为网络接口分配 IPv4 地址 sudo ifconfig eth1 0 移除网络接口的 IPv4 地址 ifconfig eth1 显示网络接口的 IPv4 或 IPv6 地址 sudo ifconfig eth1 inet6 add 2080::f816:3ea1:fe98:7b20/64 为网络接口分配 IPv6 地址 sudo ifconfig eth1 inet6 del 2080::f816:3ea1:fe98:7b20/64 移除网络设备的 IPv6 地址 sudo ifconfig eth1 hw ether 00:16:3e:04:d9:97 改变网络接口的 MAC 地址 route -n 或 netstat -rn 查看 IP 路由表 sudo route add default gw 192.168.1.2 eth0 添加默认路由 sudo route del default gw 192.168.1.1 eth0 修改默认路由 sudo route add -net 172.16.32.0/24 gw 192.168.1.1 dev eth0 添加静态路由 sudo route del -net 172.16.32.0/24 移除静态路由 netstat 或 netstat -l 查看套接字统计信息 arp -an 查看 ARP 表 sudo arp -s 192.168.1.100 00:16:3e:04:d9:07 添加静态 ARP 项 sudo arp -d 192.168.1.100 删除静态 ARP 项 sudo ipmaddr add 33:44:00:00:00:01 dev eth0 添加多播地址 sudo ipmaddr del 33:44:00:00:00:01 dev eth0 删除多播地址 ipmaddr show dev eth0 或 netstat -g 查看多播地址 ","date":"2019-12-04","objectID":"/posts/linux-network-conf-tools/:1:0","tags":["Linux"],"title":"Linux 网络配置工具","uri":"/posts/linux-network-conf-tools/"},{"categories":["Linux"],"content":"iproute2 iproute2 Linux routing utilities 命令 描述 ip link show 显示所有已连接的网络接口 sudo ip link set up eth1 激活网络接口 sudo ip link set down eth1 停用网络接口 sudo ip addr add 10.0.0.1/24 dev eth1 为网络接口分配 IPv4 地址 sudo ip addr del 10.0.0.1/24 dev eth1 移除网络接口的 IPv4 地址 ip addr show dev eth1 或 ip -6 addr show dev eth1 显示网络接口的 IPv4 或 IPv6 地址 sudo ip -6 addr add 2002:0db5:0:f102::1/64 dev eth1 为网络接口分配 IPv6 地址 sudo ip -6 addr del 2002:0db5:0:f102::1/64 dev eth1 移除网络设备的 IPv6 地址 sudo ip link set dev eth1 address 00:16:3e:04:d9:97 改变网络接口的 MAC 地址 ip route show 查看 IP 路由表 sudo ip route add default via 192.168.1.2 dev eth0 添加默认路由 sudo ip route replace default via 192.168.1.2 dev eth0 修改默认路由 sudo ip route add 172.16.32.0/24 via 192.168.1.1 dev eth0 添加静态路由 sudo ip route del 172.16.32.0/24 移除静态路由 ss 或 ss -l 查看套接字统计信息 ip neigh 查看 ARP 表 sudo ip neigh add 192.168.1.100 lladdr 00:0c:29:c0:5a:ef dev eth0 添加静态 ARP 项 sudo ip neigh del 192.168.1.100 dev eth0 删除静态 ARP 项 sudo ip maddr add 33:44:00:00:00:01 dev eth0 添加多播地址 sudo ip maddr del 33:44:00:00:00:01 dev eth0 删除多播地址 ip maddr list dev eth0 查看多播地址 ","date":"2019-12-04","objectID":"/posts/linux-network-conf-tools/:2:0","tags":["Linux"],"title":"Linux 网络配置工具","uri":"/posts/linux-network-conf-tools/"},{"categories":["Linux"],"content":"参考 Linux TCP/IP networking: net-tools vs. iproute2 ","date":"2019-12-04","objectID":"/posts/linux-network-conf-tools/:3:0","tags":["Linux"],"title":"Linux 网络配置工具","uri":"/posts/linux-network-conf-tools/"},{"categories":["PHP"],"content":"每当看到 PHP 写的很冗长奇臭的代码亦或片段，我就有一股将它斩成几节的冲动，无奈中自有一种拔剑四顾心茫然之感（由于不同的 PHP 版本，加上语法的限制）。我在开发工具上是一个比较挑剔的人，在 macOS 也花了不少钱购置工具，每次看到其它人为了破解工具折腾的死去活来痛不欲生时，我巴不得他们多折腾一会儿。 ","date":"2019-12-02","objectID":"/posts/php-some-ingenious-ways/:0:0","tags":["PHP"],"title":"PHP 中的一些巧妙写法","uri":"/posts/php-some-ingenious-ways/"},{"categories":["PHP"],"content":"更加优雅的判断语句 ","date":"2019-12-02","objectID":"/posts/php-some-ingenious-ways/:1:0","tags":["PHP"],"title":"PHP 中的一些巧妙写法","uri":"/posts/php-some-ingenious-ways/"},{"categories":["PHP"],"content":"isset 语句 isset 参与判断赋值 \u003c?php $array = $_REQUEST; $result = ''; if (is_array($array) \u0026\u0026 isset($array['key'])) { $result = $array['key']; } 改写为 \u003c?php $array = (array) $_REQUEST; $result = $array['key'] ?? ''; isset 参与并且的多个判断 \u003c?php $array = (array) $_REQUEST; $result = false; if (isset($array['a']) \u0026\u0026 isset($array['b']) \u0026\u0026 isset($array['c'])) { $result = true; } 改写为 \u003c?php $array = (array) $_REQUEST; $result = isset($array['a'], $array['b'], $array['c']); isset 参与或者的多个判断 \u003c?php $array = (array) $_REQUEST; $result = false; if (isset($array['a']) || isset($array['b']) || isset($array['c'])) { $result = true; } 改写为 \u003c?php $array = (array) $_REQUEST; $result = isset($array['a']) || isset($array['b']) || isset($array['c']); ","date":"2019-12-02","objectID":"/posts/php-some-ingenious-ways/:1:1","tags":["PHP"],"title":"PHP 中的一些巧妙写法","uri":"/posts/php-some-ingenious-ways/"},{"categories":["PHP"],"content":"empty 语句 empty 参与判断赋值 \u003c?php $array = ['a' =\u003e 0, 'b' =\u003e false, 'c' =\u003e '0']; $result = 'oldValue'; if (! empty($array['a']) \u0026\u0026 ! empty($array['b']) \u0026\u0026 ! empty($array['c'])) { $result = 'newValue'; } 改写为 \u003c?php $array = ['a' =\u003e 0, 'b' =\u003e false, 'c' =\u003e '0']; $result = $array['a'] ?: $array['b'] ?: $array['c'] ?: 'oldValue'; empty 参与并且的多个判断 \u003c?php $array = ['a' =\u003e 1, 'b' =\u003e true, 'c' =\u003e 'null']; $result = false; if (! empty($array['a']) \u0026\u0026 ! empty($array['b']) \u0026\u0026 ! empty($array['c'])) { $result = true; } 改写为 \u003c?php $array = ['a' =\u003e 1, 'b' =\u003e true, 'c' =\u003e 'null']; $result = ! empty($array['a']) \u0026\u0026 ! empty($array['b']) \u0026\u0026 ! empty($array['c']); empty 参与或者的多个判断 \u003c?php $array = ['a' =\u003e 1, 'b' =\u003e true, 'c' =\u003e 'null']; $result = false; if (! empty($array['a']) || ! empty($array['b']) || ! empty($array['c'])) { $result = true; } 改写为 \u003c?php $array = ['a' =\u003e 1, 'b' =\u003e true, 'c' =\u003e 'null']; $result = ! empty($array['a']) || ! empty($array['b']) || ! empty($array['c']); ","date":"2019-12-02","objectID":"/posts/php-some-ingenious-ways/:1:2","tags":["PHP"],"title":"PHP 中的一些巧妙写法","uri":"/posts/php-some-ingenious-ways/"},{"categories":["PHP"],"content":"判断大小语句 \u003c?php function compare(int $a, int $b): int { if ($a === $b) { return 0; } return $a \u003e $b ? 1 : -1; } 改写为 \u003c?php function compare(int $a, int $b): int { return $a \u003c=\u003e $b; } ","date":"2019-12-02","objectID":"/posts/php-some-ingenious-ways/:1:3","tags":["PHP"],"title":"PHP 中的一些巧妙写法","uri":"/posts/php-some-ingenious-ways/"},{"categories":["PHP"],"content":"Null 合并运算符 \u003c?php $array = ['a' =\u003e 0, 'b' =\u003e false, 'c' =\u003e null, 'd']; if (is_null($array['c'])) { $array['c'] = 'c is null'; } if ($array['d'] === null) { $array['d'] = 'd is null'; } 改写为 \u003c?php $array = ['a' =\u003e 0, 'b' =\u003e false, 'c' =\u003e null, 'd']; $array['c'] ??= 'c is null'; $array['d'] ??= 'd is null'; ","date":"2019-12-02","objectID":"/posts/php-some-ingenious-ways/:1:4","tags":["PHP"],"title":"PHP 中的一些巧妙写法","uri":"/posts/php-some-ingenious-ways/"},{"categories":["PHP"],"content":"方法参数变短 方法参数变短的风险时增加了调用的难度，所以注释就很必要了。不过带来的好处时，方法的复用性远甚固定参数。尤其适合重构的场景，比如：之前的方法（N 多的地方调用这个方法）多加一个参数 就可以处理 现在的逻辑 的场景，我想你一定会遇到过，如果没有遇到过，别着急，迟早的事。 \u003c?php function test(string $a, string $b, string $c, string $d, string $e, array $f, bool $g = false) { var_dump($a, $b, $c, $d, $e, $f, $e); } 改写为 function test(...$args) { var_dump($args); } // 或者 function test() { var_dump(func_get_args()); } ","date":"2019-12-02","objectID":"/posts/php-some-ingenious-ways/:2:0","tags":["PHP"],"title":"PHP 中的一些巧妙写法","uri":"/posts/php-some-ingenious-ways/"},{"categories":["PHP"],"content":"更加优雅的预定义变量 \u003c?php function test(array $array, bool $printed = false): array { $a = ''; $b = []; $c = false; $d = 0; $e = new \\stdClass(); // TODO: 处理... $result = doSomething(); return $result ?: []; } 改写为 \u003c?php function test(array $array, bool $printed = false): array { [$a, $b, $c, $d, $e] = ['', [], false, 0, new \\stdClass()]; // TODO: 处理... $result = doSomething(); return $result ?: []; } ","date":"2019-12-02","objectID":"/posts/php-some-ingenious-ways/:3:0","tags":["PHP"],"title":"PHP 中的一些巧妙写法","uri":"/posts/php-some-ingenious-ways/"},{"categories":["PHP"],"content":"使用标准类库 PHP标准库 (SPL) SPL，即 PHP 标准库（Standard PHP Library），从 PHP 5.0 起内置的组件和接口，并且从 PHP5.3 已逐渐的成熟。SPL 其实在所有的 PHP5 开发环境中被内置，同时无需任何设置。然而 SPL 了似乎被我们无视了，我们总是喜欢造一些不靠谱的轮子也不愿意花时间去学习一些成熟的解决方案。通过 SPL 工具集合我们就可以轻松组装一把瑞士军刀，当然，我这么说可能有些苍白无力，如果你刷过算法和数据结构，你一定懂 SPL 的匠心。 ","date":"2019-12-02","objectID":"/posts/php-some-ingenious-ways/:4:0","tags":["PHP"],"title":"PHP 中的一些巧妙写法","uri":"/posts/php-some-ingenious-ways/"},{"categories":["PHP"],"content":"实例之文件信息类 \u003c?php $filename = __DIR__ . '/a.txt'; $info = new SplFileInfo($filename); var_dump($info-\u003egetBasename('.txt')); var_dump($info-\u003egetExtension()); var_dump($info-\u003egetFilename()); var_dump($info-\u003egetGroup()); var_dump(date('Y-m-d H:i:s', $info-\u003egetCTime())); var_dump(date('Y-m-d H:i:s', $info-\u003egetATime())); var_dump($info-\u003eisDir()); var_dump($info-\u003eisFile()); var_dump($info-\u003eisReadable()); var_dump($info-\u003eisWritable()); var_dump($info-\u003eisExecutable()); var_dump($info-\u003egetOwner()); // 结果 string(1) \"a\" string(3) \"txt\" string(5) \"a.txt\" int(20) string(19) \"2019-12-03 03:18:21\" string(19) \"2019-12-03 03:18:22\" bool(false) bool(true) bool(true) bool(true) bool(false) int(501) ","date":"2019-12-02","objectID":"/posts/php-some-ingenious-ways/:4:1","tags":["PHP"],"title":"PHP 中的一些巧妙写法","uri":"/posts/php-some-ingenious-ways/"},{"categories":["PHP"],"content":"实例之优先级队列 \u003c?php $queue = new SplPriorityQueue(); $queue-\u003einsert('A', 3); $queue-\u003einsert('B', 6); $queue-\u003einsert('C', 1); $queue-\u003einsert('D', 2); $queue-\u003einsert('E', 5); $queue-\u003einsert('F', 4); var_dump($queue-\u003ecount()); while ($queue-\u003evalid()) { echo $queue-\u003ecurrent(), ' '; $queue-\u003enext(); } echo PHP_EOL; var_dump($queue-\u003ecompare('A', 'F')); // 结果 int(6) B E F A D C int(-1) ","date":"2019-12-02","objectID":"/posts/php-some-ingenious-ways/:4:2","tags":["PHP"],"title":"PHP 中的一些巧妙写法","uri":"/posts/php-some-ingenious-ways/"},{"categories":["PHP"],"content":"其它 ","date":"2019-12-02","objectID":"/posts/php-some-ingenious-ways/:5:0","tags":["PHP"],"title":"PHP 中的一些巧妙写法","uri":"/posts/php-some-ingenious-ways/"},{"categories":["PHP"],"content":"交换两个变量 \u003c?php $a = 1; $b = 2; [$b, $a] = [$a, $b]; var_dump($a, $b); // 结果 int(2) int(1) 或者 \u003c?php $a = 1; $b = 2; $a ^= $b; $b ^= $a; $a ^= $b; var_dump($a, $b); // 结果 int(2) int(1) \u003c?php $a = 1; $b = 2; $tmp = $a; $a = $b; $b = $tmp; var_dump($a, $b); // 结果 int(2) int(1) ","date":"2019-12-02","objectID":"/posts/php-some-ingenious-ways/:5:1","tags":["PHP"],"title":"PHP 中的一些巧妙写法","uri":"/posts/php-some-ingenious-ways/"},{"categories":["PHP"],"content":"定义函数并立即执行 \u003c?php call_user_func(static function () { echo 'Hello World!'; }); ","date":"2019-12-02","objectID":"/posts/php-some-ingenious-ways/:5:2","tags":["PHP"],"title":"PHP 中的一些巧妙写法","uri":"/posts/php-some-ingenious-ways/"},{"categories":["PHP"],"content":"闭包当成对象的成员方法或者静态成员方法 关于 bind 和 bindTo 的官网文档解释有点绕，其实它们的功能与 JS 中的 call 和 apply 差求不多，另外 JavaScript 中 apply 、call 的详解 实例一 \u003c?php class Test { private function doSomething(array $array): array { return array_map('strtoupper', $array); } } $test = new Test(); $func = function (array $array) { return $this-\u003edoSomething($array); }; $result = $func-\u003ebindTo($test, $test)(['a', 'b', 'c', 'd']); var_dump($result); // 结果 array(4) { [0]=\u003e string(1) \"A\" [1]=\u003e string(1) \"B\" [2]=\u003e string(1) \"C\" [3]=\u003e string(1) \"D\" } 实例二 \u003c?php trait DynamicDefinition { public function __call(string $name, $args = null) { if (is_callable($this-\u003e{$name})) { return call_user_func($this-\u003e{$name}, $args); } throw new \\RuntimeException(\"Method {$name} does not exist\"); } public function __set(string $name, $value = null) { $this-\u003e{$name} = is_callable($value) ? $value-\u003ebindTo($this, $this) : $value; } } class Foo { use DynamicDefinition; private string $privateValue = 'I am private'; } $foo = new Foo; $foo-\u003ebar = function (...$arguments) { $args = $arguments[0]; $prefix = implode('➣', $args); return $prefix . ' ' . $this-\u003eprivateValue; }; print $foo-\u003ebar('🙏', '🧨', '🎉'); // 结果 🙏➣🧨➣🎉 I am private 实例三 \u003c?php class Foo { private static int $a = 11; private int $b = 22; } $aFunc = static function () { return Foo::$a; }; $bFunc = function () { return $this-\u003eb; }; $aResult = Closure::bind($aFunc, null, Foo::class); $bResult = Closure::bind($bFunc, new Foo(), Foo::class); var_dump($aResult(), $bResult()); ","date":"2019-12-02","objectID":"/posts/php-some-ingenious-ways/:5:3","tags":["PHP"],"title":"PHP 中的一些巧妙写法","uri":"/posts/php-some-ingenious-ways/"},{"categories":["PHP"],"content":"整理一下 PHP-7.4.0 提供的一些改进和新特性。 Typed Properties Array Functions Limited Return Type Convariance and Argument Type Contravariance Unpacking Inside Arrays Numeric Literal Separator Weak References Allow Exception from __toString() Opcache Preloading Several Deprecations Extensions Removed from the Core ","date":"2019-11-29","objectID":"/posts/php-php74-new-features/:0:0","tags":["PHP"],"title":"PHP74 新特性","uri":"/posts/php-php74-new-features/"},{"categories":["PHP"],"content":"有类型的类属性 类属性现在支持类型声明。 \u003c?php class User { public int $id; public string $name; } $user = new User(); $user-\u003eid = '123'; $user-\u003ename = 123; var_dump($user-\u003eid, $user-\u003ename); // 结果 int(123) string(3) \"123\" ","date":"2019-11-29","objectID":"/posts/php-php74-new-features/:1:0","tags":["PHP"],"title":"PHP74 新特性","uri":"/posts/php-php74-new-features/"},{"categories":["PHP"],"content":"箭头函数 箭头函数为使用隐式按值范围绑定定义函数提供了一种简写语法。 \u003c?php $factor = 10; $nums = array_map(fn($n) =\u003e $n * $factor, [1, 2, 3, 4]); var_dump($nums); // 结果 array(4) { [0]=\u003e int(10) [1]=\u003e int(20) [2]=\u003e int(30) [3]=\u003e int(40) } ","date":"2019-11-29","objectID":"/posts/php-php74-new-features/:2:0","tags":["PHP"],"title":"PHP74 新特性","uri":"/posts/php-php74-new-features/"},{"categories":["PHP"],"content":"有限返回类型协变和参数类型逆变 \u003c?php class A { } class B extends A { } class Producer { public function method(): A { echo __METHOD__, PHP_EOL; return new A(); } } class ChildProducer extends Producer { public function method(): B { echo __METHOD__, PHP_EOL; return new B(); } } $producer = new Producer(); $childProducer = new ChildProducer(); if ($producer-\u003emethod() instanceof A) { var_dump('我特么就返回 A 的实例'); } if ($childProducer-\u003emethod() instanceof B) { var_dump('我特么就返回 B 的实例'); } // 结果 Producer::method string(30) \"我特么就返回 A 的实例\" ChildProducer::method string(30) \"我特么就返回 B 的实例\" ","date":"2019-11-29","objectID":"/posts/php-php74-new-features/:3:0","tags":["PHP"],"title":"PHP74 新特性","uri":"/posts/php-php74-new-features/"},{"categories":["PHP"],"content":"NULL 合并运算符 \u003c?php function defaultValue(): string { return ''; } $array = $_REQUEST; // PHP74 之前 if (! isset($array['key'])) { $array['key'] = defaultValue(); } // PHP74 开始 $array['key'] ??= defaultValue(); // 虽然以下代码也可以，但是本人强烈反对这样写，不要问我为什么。代码块我总是用 {} 包起来 if (! isset($array['key'])) $array['key'] = defaultValue(); ","date":"2019-11-29","objectID":"/posts/php-php74-new-features/:4:0","tags":["PHP"],"title":"PHP74 新特性","uri":"/posts/php-php74-new-features/"},{"categories":["PHP"],"content":"在数组内部展开元素 \u003c?php $parts = ['apple', 'pear']; $fruits = ['banana', 'orange', ...$parts, 'watermelon']; var_dump($fruits); // 结果 array(5) { [0]=\u003e string(6) \"banana\" [1]=\u003e string(6) \"orange\" [2]=\u003e string(5) \"apple\" [3]=\u003e string(4) \"pear\" [4]=\u003e string(10) \"watermelon\" } ","date":"2019-11-29","objectID":"/posts/php-php74-new-features/:5:0","tags":["PHP"],"title":"PHP74 新特性","uri":"/posts/php-php74-new-features/"},{"categories":["PHP"],"content":"数字字面量分隔符 人眼并未针对快速解析长数字序列进行优化。 因此，缺少视觉分隔符会使读取和调试代码花费更长的时间，并可能导致意外错误。 所以 数字字面量分隔符 就是解决人眼快速识别而做出的优化，你看，代码的的确确是机器去执行的，但更重要的是 可读、可写、可赏、可赞 😂。 6.674_083e-11; // float 299_792_458; // decimal 0xCAFE_F00D; // hexadecimal 0b0101_1111; // binary 0137_041; // octal 1_000_000; // versus 1000000 3.141_592; // versus 3.141592 0x02_56_12; // versus 0x025612 0b0010_1101; // versus 0b00101101 0267_3432; // versus 02673432 1_123.456_7e2 // versus 1123.4567e2 \u003c?php usleep(345126); // without separator usleep(345_126); // with separator if (12345678989876 === 12345678998876) { echo 'Equal'; } else { echo 'Unequal'; } echo PHP_EOL; if (12_345_678_989_876 === 12_345_678_998_876) { echo 'Equal'; } else { echo 'Unequal'; } ","date":"2019-11-29","objectID":"/posts/php-php74-new-features/:6:0","tags":["PHP"],"title":"PHP74 新特性","uri":"/posts/php-php74-new-features/"},{"categories":["PHP"],"content":"弱引用 ","date":"2019-11-29","objectID":"/posts/php-php74-new-features/:7:0","tags":["PHP"],"title":"PHP74 新特性","uri":"/posts/php-php74-new-features/"},{"categories":["PHP"],"content":"允许来自 toString() 的异常 Request #53648 Allow __toString() to throw exceptions \u003c?php class CustomException extends \\Exception { } class Foo { public function __toString() { throw new CustomException('Oops!'); } } $foo = new Foo(); try { var_dump((string) $foo); } catch (CustomException $e) { var_dump($e); } // 结果 // PHP56 PHP Fatal error: Method Foo::__toString() must not throw an exception in /path/to/User.php on line 0 // PHP73 PHP Fatal error: Method Foo::__toString() must not throw an exception, caught CustomException: Oops! in /path/to/a.php on line 0 // PHP74 object(CustomException)#2 (7) { [\"message\":protected]=\u003e string(5) \"Oops!\" [\"string\":\"Exception\":private]=\u003e string(0) \"\" [\"code\":protected]=\u003e int(0) [\"file\":protected]=\u003e string(47) \"/Users/xxx/Codes/example/untitled/User.php\" [\"line\":protected]=\u003e int(11) [\"trace\":\"Exception\":private]=\u003e array(1) { [0]=\u003e array(6) { [\"file\"]=\u003e string(47) \"/Users/xxx/Codes/example/untitled/User.php\" [\"line\"]=\u003e int(18) [\"function\"]=\u003e string(10) \"__toString\" [\"class\"]=\u003e string(3) \"Foo\" [\"type\"]=\u003e string(2) \"-\u003e\" [\"args\"]=\u003e array(0) { } } } [\"previous\":\"Exception\":private]=\u003e NULL } ","date":"2019-11-29","objectID":"/posts/php-php74-new-features/:8:0","tags":["PHP"],"title":"PHP74 新特性","uri":"/posts/php-php74-new-features/"},{"categories":["PHP"],"content":"Opcache 预加载 opcache.preload string：指定要在服务器启动时期进行编译和缓存的 PHP 脚本文件，这些文件也可能通过 include 或者 opcache_compile_file() 函数来预加载其他文件。所有这些文件中包含的实体，包括函数、类等，在服务器启动的时候就被加载和缓存，对于用户代码来讲是『开箱可用』的。 ","date":"2019-11-29","objectID":"/posts/php-php74-new-features/:9:0","tags":["PHP"],"title":"PHP74 新特性","uri":"/posts/php-php74-new-features/"},{"categories":["PHP"],"content":"一些不推荐 Deprecated Features ","date":"2019-11-29","objectID":"/posts/php-php74-new-features/:10:0","tags":["PHP"],"title":"PHP74 新特性","uri":"/posts/php-php74-new-features/"},{"categories":["PHP"],"content":"从核心中移除的扩展 Removed Extensions ","date":"2019-11-29","objectID":"/posts/php-php74-new-features/:11:0","tags":["PHP"],"title":"PHP74 新特性","uri":"/posts/php-php74-new-features/"},{"categories":["MySQL"],"content":"使用 MySQL 这么长时间了，经常使用的情况时，除了自增主键和日期时间之外 ，能 varchar 的基本上都给 varchar 了。团队内部还出现过 VARCHAR(2)、VARCHAT(4)、...、VARCHAT(2^N) 的情况，现在看来确实有点搞笑。 MySQL 数据类型 MySQL 用户管理 MySQL 关键字查询 MySQL 字符串函数 MySQL 字符串连接函数 MySQL 忘记 root 密码后重置 MySQL 最值查询 MySQL 日期时间函数 MySQL 联合查询 MySQL 查询当前年、季、月、周的第一天和最后一天 MySQL 支持 emoji 图标的设置 MySQL 存储引擎 MySQL 隔离级别及其脏读不可重复读幻读 ","date":"2019-11-17","objectID":"/posts/mysql-data-types/:0:0","tags":["MySQL"],"title":"MySQL 数据类型","uri":"/posts/mysql-data-types/"},{"categories":["MySQL"],"content":"数据类型 数值类型 整数：tinyint、smallint、mediumint、int、bigint 小数：float、double、real、decimal 日期和时间类型：date、time、datetime、timestamp、year 字符串类型 字符串：char、varchat 大文本：tinytext、text、mediumtext、longtext 其他：enum、set 二进制类型：tinyblob、blob、mediumblob、longblob 空间数据类型：geometry、geometrycollection、point、linestring JSON 数据类型： ","date":"2019-11-17","objectID":"/posts/mysql-data-types/:1:0","tags":["MySQL"],"title":"MySQL 数据类型","uri":"/posts/mysql-data-types/"},{"categories":["MySQL"],"content":"主要类型 Data Type Storage Requirements ","date":"2019-11-17","objectID":"/posts/mysql-data-types/:2:0","tags":["MySQL"],"title":"MySQL 数据类型","uri":"/posts/mysql-data-types/"},{"categories":["MySQL"],"content":"整数型 类型 存储空间(Bytes) 有符号最小值与最大值 无符号最小值与最大值 tinyint 1 -128~127 或 -2^7~2^7-1 0~255 或 0~2^8-1 smallint 2 -32768~32767 或 -2^15~2^15-1 0~65535 或 0~2^16-1 mediumint 3 -8388608~8388607 或 -2^23~2^23-1 0~16777215 或 0~2^24-1 int 4 -2147483648~2147483647 或 -2^31~^31-1 0~4294967295 或 0~2^32-1 bigint 8 -9223372036854775808~9223372036854775807 或 -2^63~2^63-1 0~1.8446744e+19 或 0~2^64-1 ","date":"2019-11-17","objectID":"/posts/mysql-data-types/:2:1","tags":["MySQL"],"title":"MySQL 数据类型","uri":"/posts/mysql-data-types/"},{"categories":["MySQL"],"content":"浮点型 类型 存储空间(Bytes) 有符号最小值与最大值 无符号最小值与最大值 float(M, D) 4 -3.402823466E+38~-1.175494351E-38 1.175494351E-38~3.402823466E+38 double(M, D) 8 -1.7976931348623157E+308~-2.2250738585072014E-308 0 和 2.2250738585072014E-308~1.7976931348623157E+308 ","date":"2019-11-17","objectID":"/posts/mysql-data-types/:2:2","tags":["MySQL"],"title":"MySQL 数据类型","uri":"/posts/mysql-data-types/"},{"categories":["MySQL"],"content":"定点型 DECIMAL 范围 这里我复制一下官方文档的解释： The declaration syntax for a DECIMAL column is DECIMAL(M,D). The ranges of values for the arguments are as follows: M is the maximum number of digits (the precision). It has a range of 1 to 65. D is the number of digits to the right of the decimal point (the scale). It has a range of 0 to 30 and must be no larger than M. If D is omitted, the default is 0. If M is omitted, the default is 10. 高精度的数据类型，常用来存储交易相关的数据 decimal(M, D) 解释：M 代表总精度（小数点前后数字总个数），D 代表刻度（小数点后的位数）。比如：decimal(5, 2) 表示存储范围为 -999.99~999.99 decimal(M, D) 范围：1\u003c= M \u003c= 65、0 \u003c= D \u003c= 30 如果省略 D，默认值是 0。如果省略 M，默认值是 10 存储空间变长（M+2 bytes） ","date":"2019-11-17","objectID":"/posts/mysql-data-types/:2:3","tags":["MySQL"],"title":"MySQL 数据类型","uri":"/posts/mysql-data-types/"},{"categories":["MySQL"],"content":"日期时间型 类型 存储空间(Bytes) 格式 范围 year 1 YYYY 1901~2155 date 3 YYYY-MM-DD 1000-01-01~9999-12-31 time 3 hh:mm:ss -838:59:59~838:59:59 datetime 8 yyyy-mm-dd hh:mm:ss 1000-01-01 00:00:00~9999-12-31 23:59:59' timestamp 4 YYYYMMDDhhmmss UTC: 1970-01-01 00:00:01~2038-01-19 03:14:07 包含两位数年份值的日期是模糊的，因为世纪是未知的。MySQL 使用这些规则解释两位数的年值： 00~69 范围内的年份值被转换为 2000~2069 70~99 范围内的年份值被转换为 1970~1999 ","date":"2019-11-17","objectID":"/posts/mysql-data-types/:2:4","tags":["MySQL"],"title":"MySQL 数据类型","uri":"/posts/mysql-data-types/"},{"categories":["MySQL"],"content":"字符串型 类型 说明 char(M) 固定长度的字符串（可以包含字母，数字和特殊字符）。 M 参数指定以 字符 为单位的列长度（范围：0~255）。默认值为 1 varchat(M) 长度可变的字符串（可以包含字母，数字和特殊字符）。 M 参数指定以 字符 为单位的最大列长度（范围：0~65525） binary(M) 等于 char(M)，但存储二进制 字节 字符串。 M 参数指定以 字节 为单位的列长度。 默认为 1 varbinary 等于 varchat(M)，但存储二进制 字节 字符串。 M 参数指定最大列长度。 tinyblob 用户 BLOB（二进制大对象）。最大长度 255 个 字节 tinytext 包含最大长度为 255（255B）个 字符 的字符串 blob(M) 对于 BLOB（二进制大对象）。最多可容纳 65535 个 字节 的数据 text(M) 容纳最大长度为 65535（64KB）个 字符 的字符串 mediumblob 对于 BLOB（二进制大对象）。最多容纳 16777215 个 字节 的数据 mediumtext 容纳最大长度为 16777215（16MB）个 字符 的字符串 longblob 对于 BLOB（二进制大对象）。最多可容纳 4294967295 个 字节 的数据 longtext 包含最大长度为 4294967295（4GB）个 字符 的字符串 enum('v1', 'v2', ...) 从可能值列表中选择的只能有一个值的字符串对象。你可以在 ENUM 列表中最多列出 65535 个值。如果插入的值不在列表中，则将插入空白值。值按输入顺序排序 set(v1, v2, v3, ...) 从可能值列表中选择的可以具有 0 个或多个值的字符串对象。你可以在 SET 列表中最多列出 64 个值 关于 char(M)、varchar(M) 和 text 的问题： char(M) 和 varchar(M) 中 M 代表 字符个数，并不是字节个数。当使用 UTF-8 时意味着可以插入 M 个字符，但实际会占用 M*3 个字节 char(M) 不管实际值都会占用 M 个字符的空间，页 varchar(M) 只会占用实际字符应该占用的空间 +1，并且实际空间为 +1 \u003c= M 超过 char(M) 和 varchar(M) 的 M 设置后，字符串会被截断 char 的上限为 255 字符，varchar 和 text 的上限 65535 字符 char 在存储的时候会截断尾部的空格，varchar 和 text 不会 varchar 会使用 1~3 个字节来存储长度，而 text 不会 值 char(4) 存储需要 varchat(4) 存储需要 '' ' ' 4 bytes '' 1 bytes 'ab' 'ab ' 4 bytes 'ab' 3 bytes 'abcd' 'abcd' 4 bytes 'abcd' 5 bytes 'abcdefgh' 'abcd' 4 bytes 'abcd' 5 bytes 如上所述： char 存定长，速度快，存在空间浪费的可能，会处理尾部空格，上限 255 varchar 存变长，速度慢，不存在空间浪费，不处理尾部空格，上限 65535，但是有存储长度实际 65532 最大可用 text，存变长大数据，速度慢，不存在空间浪费，不处理尾部空格，上限 65535，会用额外空间存放数据长度，因此可以全部使用 65535 ","date":"2019-11-17","objectID":"/posts/mysql-data-types/:2:5","tags":["MySQL"],"title":"MySQL 数据类型","uri":"/posts/mysql-data-types/"},{"categories":["Nginx"],"content":"曾经某段时间这个 499 状态码是面试的必考题，好像你不知道这个状态码就觉得你欠了面试官不少钱似的，我也来记录一下。 ","date":"2019-11-15","objectID":"/posts/nginx-499-faq/:0:0","tags":["Nginx"],"title":"Nginx 499 状态码","uri":"/posts/nginx-499-faq/"},{"categories":["Nginx"],"content":"什么是 Nginx 499 错误 Nginx 源码中对 499 状态码的定义： /* * HTTP does not define the code for the case when a client closed * the connection while we are processing its request so we introduce * own code to log such situation when a client has closed the connection * before we even try to send the HTTP header to it */ #define NGX_HTTP_CLIENT_CLOSED_REQUEST 499 翻译成人话就是： 当一个客户端关闭时，HTTP 不为这种情形定义代码。同时我们处理它的请求时，我们引入了当一个客户端在我们尝试向其发送 HTTP 头之前关闭连接时，使用自己的代码（也就是 499 状态码）来记录这种情况。 进一步理解就是：我们特么的也不知道这种情况该怎样弄，于是乎我们就决定定义一种状态码来记录一下，至于这种情况怎么处理，就交给你了！ 总结一下： 499 状态码不是 HTTP 的标准代码 499 状态码是 Nginx 自己定义，用来 记录（你没看错，就是记录一下） 服务端向客户端发送 HTTP 请求头之前，客户端已经关闭连接的一种情况 最常见的场景就是 timeout 设置不合理，Nginx 把请求转发上游服务器，上游服务器慢吞吞的处理，客户端等不及了主动断开链接，Nginx 就负责记录了 499 ","date":"2019-11-15","objectID":"/posts/nginx-499-faq/:1:0","tags":["Nginx"],"title":"Nginx 499 状态码","uri":"/posts/nginx-499-faq/"},{"categories":["Nginx"],"content":"什么情况 Nginx 记录 499 错误日志 这里我们使用 curl 模拟请求一下，更多 curl 的骚操作请访问 curl 的用法指南。 for i in $(seq 1 10); do curl -m 2 http://api.example.test; done curl: (28) Operation timed out after 2000 milliseconds with 0 bytes received curl: (28) Operation timed out after 2004 milliseconds with 0 bytes received curl: (28) Operation timed out after 2004 milliseconds with 0 bytes received curl: (28) Operation timed out after 2001 milliseconds with 0 bytes received curl: (28) Operation timed out after 2000 milliseconds with 0 bytes received curl: (28) Operation timed out after 2003 milliseconds with 0 bytes received curl: (28) Operation timed out after 2002 milliseconds with 0 bytes received curl: (28) Operation timed out after 2005 milliseconds with 0 bytes received curl: (28) Operation timed out after 2000 milliseconds with 0 bytes received curl: (28) Operation timed out after 2001 milliseconds with 0 bytes received tail -f /var/log/nginx/apiexample.access.log 172.19.0.1 - - [15/Nov/2019:06:32:19 +0000] \"GET / HTTP/1.1\" 499 0 \"-\" \"curl/7.67.0\" 172.19.0.1 - - [15/Nov/2019:06:32:22 +0000] \"GET / HTTP/1.1\" 499 0 \"-\" \"curl/7.67.0\" 172.19.0.1 - - [15/Nov/2019:06:32:24 +0000] \"GET / HTTP/1.1\" 499 0 \"-\" \"curl/7.67.0\" 172.19.0.1 - - [15/Nov/2019:06:32:26 +0000] \"GET / HTTP/1.1\" 499 0 \"-\" \"curl/7.67.0\" 172.19.0.1 - - [15/Nov/2019:06:32:28 +0000] \"GET / HTTP/1.1\" 499 0 \"-\" \"curl/7.67.0\" 172.19.0.1 - - [15/Nov/2019:06:32:30 +0000] \"GET / HTTP/1.1\" 499 0 \"-\" \"curl/7.67.0\" 172.19.0.1 - - [15/Nov/2019:06:32:32 +0000] \"GET / HTTP/1.1\" 499 0 \"-\" \"curl/7.67.0\" 172.19.0.1 - - [15/Nov/2019:06:32:34 +0000] \"GET / HTTP/1.1\" 499 0 \"-\" \"curl/7.67.0\" 172.19.0.1 - - [15/Nov/2019:06:32:36 +0000] \"GET / HTTP/1.1\" 499 0 \"-\" \"curl/7.67.0\" 172.19.0.1 - - [15/Nov/2019:06:32:38 +0000] \"GET / HTTP/1.1\" 499 0 \"-\" \"curl/7.67.0\" 如上所见，使用 Timeout 很容易模拟出 499 这种情形。 记录 499 的情形： 如上所示，数据传输的最大允许时间超时的话，Curl 断开了请求，而 Web 服务器如 Nginx 还在处理的话，则 Nginx 会记录 499 如果 Nginx 作为反向代理时，Nginx 将请求分发至对应的处理服务器时，有两对超时参数的设置：proxy_send_timeout 和 proxy_read_timeout、fastcgi_send_timeout 和 fastcgi_read_timeout。两对参数默认的超时时间都是 60s。在 Nginx 出现 499 的情况下，可以结合请求断开前的耗时和这两对设定的时间进行对比，看一下是不是在 proxy_pass 或者 fastcgi_pass 处理时，设置的超时时间短了 如果 PHP 操作超时。打开 php.ini 查看 max_execution_time 和 max_input_time 两个参数。两者分别是 PHP 程序执行的最长时间和表单提交的最长时间 如果两次提交 POST 过快就会出现 499 的情况，Nginx 认为是不安全的连接，主动拒绝了客户端的连接 相关负载均衡配置等 ","date":"2019-11-15","objectID":"/posts/nginx-499-faq/:2:0","tags":["Nginx"],"title":"Nginx 499 状态码","uri":"/posts/nginx-499-faq/"},{"categories":["Nginx"],"content":"如何有效防止 Nginx 记录 499 错误 综上所述，我们可以得出一个结论，HTTP 请求在指定的时间内没能拿到响应而关闭了连接，就会发生 Nginx 记录 499 错误的情况。这个涉及到两个重要的问题：时间问题 和 性能问题（性能问题太过宽泛就不提及了），所以解决这个问题也就从这两方面入手。 当然还有配置 proxy_ignore_client_abort 参数为 on 来解决的（让代理服务端不要主动关闭客户端的连接）。但是这样也有一定的风险，会拖垮服务器。发生这个错误，如果服务器 CPU 和 Memory 不算太高，一般是数据库和程序的问题，数据库处理较慢或者程序线程较低。结合情况调整，比如读写分离或者程序线程数调高。 文档中对 proxy_ignore_client_abort 参数的说明： Determines whether the connection with a proxied server should be closed when a client closes the connection without waiting for a response. 翻译：当一个客户端关闭连接而不等待响应时，确定与代理服务器的连接是否应该关闭。 ","date":"2019-11-15","objectID":"/posts/nginx-499-faq/:3:0","tags":["Nginx"],"title":"Nginx 499 状态码","uri":"/posts/nginx-499-faq/"},{"categories":["MySQL"],"content":"MySQL 中，InnoDB 所提供的事务符合 ACID 的要求，而事务通过事务日志中的 redo log 和 undo log 满足了原子性、一致性、持久性，事务还会通过锁机制满足隔离性，在 InnoDB 存储引擎中，有不同的隔离级别，它们有着不同的隔离性。 MySQL 数据类型 MySQL 用户管理 MySQL 关键字查询 MySQL 字符串函数 MySQL 字符串连接函数 MySQL 忘记 root 密码后重置 MySQL 最值查询 MySQL 日期时间函数 MySQL 联合查询 MySQL 查询当前年、季、月、周的第一天和最后一天 MySQL 支持 emoji 图标的设置 MySQL 存储引擎 MySQL 隔离级别及其脏读不可重复读幻读 ","date":"2019-11-07","objectID":"/posts/mysql-isolation-level/:0:0","tags":["MySQL"],"title":"MySQL 隔离级别及其脏读不可重复读幻读","uri":"/posts/mysql-isolation-level/"},{"categories":["MySQL"],"content":"事务的特性 原子性（Atomicity - [ˌætəˈmɪsəti] ）：一个事务（Transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即指处于同一个事务中的多条语句是不可分割的 一致性（Consistency - [kənˈsɪstənsi]）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。即事务必须使数据库从一个一致性状态变换到另外一个一致性状态 隔离性（Isolation - [ˌaɪsəˈleɪʃn]）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。即指多线程环境下，一个线程中的事务不能被其他线程中的事务打扰 持久性（Durability - [dərəˈbɪlɪti]）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。即事务一旦提交，就应该被永久保存起来 ","date":"2019-11-07","objectID":"/posts/mysql-isolation-level/:1:0","tags":["MySQL"],"title":"MySQL 隔离级别及其脏读不可重复读幻读","uri":"/posts/mysql-isolation-level/"},{"categories":["MySQL"],"content":"事务的组成部分 顺便提一下 DQL（数据查询语言：Data Query Language）。 一个或多个 DML（Data Manipulation Language） 语句，比如：INSERT、UPDATE、SELECT、DELETE 等 一个 DDL（数据定义语言：Data Definition Language）语句，比如：CREATE、ALTER、DROP 等 一个 DCL（数据控制语言：Data Control Language）语句，比如：GRANT、DENY、REVOKE 等 ","date":"2019-11-07","objectID":"/posts/mysql-isolation-level/:2:0","tags":["MySQL"],"title":"MySQL 隔离级别及其脏读不可重复读幻读","uri":"/posts/mysql-isolation-level/"},{"categories":["MySQL"],"content":"不隔离事务带来的问题 脏读（Drity Read）：一个事务读取到另一个事务未提交的数据，侧重点在 事务未提交 不可重复读（Non-Repeatable Read）：一个事务对同一行数据重复读取两次，但得到的结果不同，侧重点在 更新修改 幻读或虚读（Phantom Read）：一个事务执行两次查询，第二次查询时，莫名的多出了一些之前不存在数据，或者莫名的不见了一些数据，侧重点在 新增删除 丢失更新（Lost Update）：两个事务同时更新一行数据，后提交（或撤销）的事务将之前事务提交的数据覆盖了 丢失更新可分为两类，分别是第一类丢失更新和第二类丢失更新： 第一类丢失更新：指两个事务同时操作同一个数据时，当第一个事务撤销时，把已经提交的第二个事务的更新数据覆盖了，第二个事务就造成了数据丢失 第二类丢失更新：指当两个事务同时操作同一个数据时，第一个事务将修改结果成功提交后，对第二个事务已经提交的修改结果进行了覆盖，对第二个事务造成了数据丢失 ","date":"2019-11-07","objectID":"/posts/mysql-isolation-level/:3:0","tags":["MySQL"],"title":"MySQL 隔离级别及其脏读不可重复读幻读","uri":"/posts/mysql-isolation-level/"},{"categories":["MySQL"],"content":"事务的隔离级别 读未提交（Read Uncommitted）：一个事务在执行过程中，既可以访问其他事务未提交的新插入的数据，又可以访问未提交的修改数据。如果一个事务已经开始写数据，则另外一个事务不允许同时进行写操作，但允许其他事务读此行数据，即一个事务读取到另一个事务中未提交的数据。此隔离级别可防止丢失更新 读已提交（Read Committed）：一个事务在执行过程中，既可以访问其他事务成功提交的新插入的数据，又可以访问成功修改的数据。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行，即一个事务读取到另一个事务中已提交的数据。此隔离级别可有效防止脏读 可重复读（Repeatable Read）：一个事务在执行过程中，可以访问其他事务成功提交的新插入的数据，但不可以访问成功修改的数据。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务，即一个事务可以重复读，每次读取的结果集都相同，而不管其他事务有没有提交。此隔离级别可有效防止不可重复读和脏读 可串行化（Serializable）：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。此隔离级别可有效防止脏读、不可重复读和幻读。但这个级别可能导致大量的超时现象和锁竞争，在实际应用中很少使用 隔离级别表（级别越高，数据越安全，但性能越低）： 隔离级别 脏读 不可重复读 幻读 读未提交 有可能 有可能 有可能 读已提交 不可能 有可能 有可能 可重复读 不可能 不可能 有可能 可串行化 不可能 不可能 不可能 ","date":"2019-11-07","objectID":"/posts/mysql-isolation-level/:4:0","tags":["MySQL"],"title":"MySQL 隔离级别及其脏读不可重复读幻读","uri":"/posts/mysql-isolation-level/"},{"categories":["MySQL"],"content":"事务处理的方式 ","date":"2019-11-07","objectID":"/posts/mysql-isolation-level/:5:0","tags":["MySQL"],"title":"MySQL 隔离级别及其脏读不可重复读幻读","uri":"/posts/mysql-isolation-level/"},{"categories":["MySQL"],"content":"显示局部设置 # 开启一个事务 BEGIN # 事务回滚 ROLLBACK # 提交事务 COMMIT ","date":"2019-11-07","objectID":"/posts/mysql-isolation-level/:5:1","tags":["MySQL"],"title":"MySQL 隔离级别及其脏读不可重复读幻读","uri":"/posts/mysql-isolation-level/"},{"categories":["MySQL"],"content":"隐式全局设置 # 禁止自动提交 SET AUTOCOMMIT=0 # 开启自动提交 SET AUTOCOMMIT=1 ","date":"2019-11-07","objectID":"/posts/mysql-isolation-level/:5:2","tags":["MySQL"],"title":"MySQL 隔离级别及其脏读不可重复读幻读","uri":"/posts/mysql-isolation-level/"},{"categories":["MySQL"],"content":"隔离级别操作 // 查看事务隔离级别 mysql root@localhost:mysql\u003e select @@transaction_isolation; +-------------------------+ | @@transaction_isolation | +-------------------------+ | REPEATABLE-READ | +-------------------------+ 1 row in set Time: 0.017s // 设置当前会话隔离级别为读未提交 mysql root@localhost:mysql\u003e set session transaction isolation level read uncommitted; Query OK, 0 rows affected Time: 0.043s // 设置当前会话隔离级别为读已提交 mysql root@localhost:mysql\u003e set session transaction isolation level read committed; Query OK, 0 rows affected Time: 0.043s // 设置当前会话隔离级别为可重复读 mysql root@localhost:mysql\u003e set session transaction isolation level repeatable read; Query OK, 0 rows affected Time: 0.043s // 设置当前会话隔离级别为可串行化 mysql root@localhost:mysql\u003e set session transaction isolation level serializable; Query OK, 0 rows affected Time: 0.043s // 查看当前 Session 的事务隔离级别 mysql root@localhost:mysql\u003e show variables like '%transaction_isolation%'; +-----------------------+------------------+ | Variable_name | Value | +-----------------------+------------------+ | transaction_isolation | READ-UNCOMMITTED | +-----------------------+------------------+ 1 row in set Time: 0.067s // 查看全局的事务隔离级别 mysql root@localhost:mysql\u003e show global variables like '%transaction_isolation%'; +-----------------------+-----------------+ | Variable_name | Value | +-----------------------+-----------------+ | transaction_isolation | REPEATABLE-READ | +-----------------------+-----------------+ 1 row in set Time: 0.016s 实验环节待续中。。。 ","date":"2019-11-07","objectID":"/posts/mysql-isolation-level/:6:0","tags":["MySQL"],"title":"MySQL 隔离级别及其脏读不可重复读幻读","uri":"/posts/mysql-isolation-level/"},{"categories":["Redis"],"content":"Redis 和其他很多 key-value 数据库的不同之处在于，Redis 不仅支持简单的字符串键值对，它还提供了一系列数据结构类型值，比如列表、哈希、集合和有序集，并在这些数据结构类型上定义了一套强大的 API。通过对不同类型的值进行操作，Redis 可以很轻易地完成其他只支持字符串键值对的 key-value 数据库很难（或者无法）完成的任务。在 Redis 的内部，数据结构类型值由高效的数据结构和算法进行支持，并且在 Redis 自身的构建当中，也大量用到了这些数据结构。 ","date":"2019-11-06","objectID":"/posts/redis-command-operation/:0:0","tags":["Redis"],"title":"Redis 常用命令操作","uri":"/posts/redis-command-operation/"},{"categories":["Redis"],"content":"数据类型 字符串：String 哈希或散列：Hash 列表：List 集合：Set 有序集合：Sorted Set ","date":"2019-11-06","objectID":"/posts/redis-command-operation/:1:0","tags":["Redis"],"title":"Redis 常用命令操作","uri":"/posts/redis-command-operation/"},{"categories":["Redis"],"content":"操作实例 ","date":"2019-11-06","objectID":"/posts/redis-command-operation/:2:0","tags":["Redis"],"title":"Redis 常用命令操作","uri":"/posts/redis-command-operation/"},{"categories":["Redis"],"content":"字符串 Redis 数据库是以无序的方式存放数据库键的，一个新加入的键可能会出现在数据库的任何位置上。因此我们在使用 Redis 的过程中不应该对键在数据库中的摆放位置做任何假设，以免造成错误。 设置字符串键值： 127.0.0.1:6379\u003e SET phone 10086 OK 获取字符串键值： 127.0.0.1:6379\u003e GET phone \"10086\" 覆盖字符串键值： 127.0.0.1:6379\u003e SET redis \"Redis is an in-memory database that persists on disk\" OK 127.0.0.1:6379\u003e GET redis \"Redis is an in-memory database that persists on disk\" 127.0.0.1:6379\u003e SET redis \"Redis is often referred as a data structures server\" OK 127.0.0.1:6379\u003e GET redis \"Redis is often referred as a data structures server\" 仅在键没有值时进行设置： 127.0.0.1:6379\u003e GET password (nil) 127.0.0.1:6379\u003e SET password \"password\" NX OK 127.0.0.1:6379\u003e GET password \"password\" 127.0.0.1:6379\u003e SET password \"123456\" NX (nil) 127.0.0.1:6379\u003e GET password \"password\" 仅在键已有值时进行设置： 127.0.0.1:6379\u003e GET redis:password (nil) 127.0.0.1:6379\u003e SET redis:password \"redis.io\" XX (nil) 127.0.0.1:6379\u003e GET redis:password (nil) 127.0.0.1:6379\u003e SET redis:password \"redis.io\" OK 127.0.0.1:6379\u003e SET redis:password \"Redis.IO\" XX OK 获取键目前的值，然后为键设置新值，最后把之前获取到的旧值返回： 127.0.0.1:6379\u003e GET phone (nil) 127.0.0.1:6379\u003e GETSET phone 10086 (nil) 127.0.0.1:6379\u003e SET phone 10086 OK 127.0.0.1:6379\u003e GETSET phone 10001 \"10086\" 127.0.0.1:6379\u003e GET phone \"10001\" 一次为多个字符串键设置值： 127.0.0.1:6379\u003e MSET a hello b world c 10086 OK 127.0.0.1:6379\u003e MGET a 1) \"hello\" 127.0.0.1:6379\u003e MGET b 1) \"world\" 127.0.0.1:6379\u003e MGET c 1) \"10086\" 127.0.0.1:6379\u003e MSET a redis b memory c 10001 OK 127.0.0.1:6379\u003e MGET a 1) \"redis\" 127.0.0.1:6379\u003e MGET b 1) \"memory\" 127.0.0.1:6379\u003e MGET c 1) \"10001\" 一次获取多个字符串键的值： 127.0.0.1:6379\u003e MSET a \"Hello World\" b 10086 OK 127.0.0.1:6379\u003e MGET a b 1) \"Hello World\" 2) \"10086\" 仅在键不存在时，一次为多个字符串键设置值： 127.0.0.1:6379\u003e MSET a hello b world c 10086 OK 127.0.0.1:6379\u003e MSETNX a 1 b 2 c 3 d 4 (integer) 0 127.0.0.1:6379\u003e MGET a b c d 1) \"hello\" 2) \"world\" 3) \"10086\" 4) (nil) 127.0.0.1:6379\u003e MSETNX d 4 (integer) 1 127.0.0.1:6379\u003e MGET a b c d 1) \"hello\" 2) \"world\" 3) \"10086\" 4) \"4\" 获取字符串值的字节长度： 127.0.0.1:6379\u003e SET org \"中国人民解放军\" OK 127.0.0.1:6379\u003e STRLEN org (integer) 21 127.0.0.1:6379\u003e SET str \"Hello World!\" OK 127.0.0.1:6379\u003e STRLEN str (integer) 12 获取字符串值指定索引范围上的内容： 127.0.0.1:6379\u003e SET org Microsoft OK 127.0.0.1:6379\u003e GETRANGE org 0 4 \"Micro\" 对字符串的指定索引范围进行设置： 127.0.0.1:6379\u003e SET message \"Hello World\" OK 127.0.0.1:6379\u003e SETRANGE message 6 Redis (integer) 11 127.0.0.1:6379\u003e GET message \"Hello Redis\" 自动扩展被修改的字符串： 127.0.0.1:6379\u003e SET message \"Hello World\" OK 127.0.0.1:6379\u003e GET message \"Hello World\" 127.0.0.1:6379\u003e SETRANGE message 6 \"Redis, Hello World\" (integer) 24 127.0.0.1:6379\u003e GET message \"Hello Redis, Hello World\" 在值里面填充空字节： \\x00 符号代表一个空字符。 127.0.0.1:6379\u003e SET message Hello OK 127.0.0.1:6379\u003e get message \"Hello\" 127.0.0.1:6379\u003e SETRANGE message 10 Redis (integer) 15 127.0.0.1:6379\u003e GET message \"Hello\\x00\\x00\\x00\\x00\\x00Redis\" 追加新内容到值的末尾： 127.0.0.1:6379\u003e SET message Hello OK 127.0.0.1:6379\u003e APPEND message \" Redis\" (integer) 11 127.0.0.1:6379\u003e GET message \"Hello Redis\" 127.0.0.1:6379\u003e APPEND message \", Hello World\" (integer) 24 127.0.0.1:6379\u003e GET message \"Hello Redis, Hello World\" 不存在的键追加内容： 效果等同于 SET 命令。 127.0.0.1:6379\u003e GET message (nil) 127.0.0.1:6379\u003e APPEND message \"Hello Redis\" (integer) 11 127.0.0.1:6379\u003e APPEND message \", Hello World\" (integer) 24 127.0.0.1:6379\u003e GET message \"Hello Redis, Hello World\" 整数值的加法、减法操作： 127.0.0.1:6379\u003e SET number 1000 OK 127.0.0.1:6379\u003e GET number \"1000\" 127.0.0.1:6379\u003e INCRBY number 100 (integer) 1100 127.0.0.1:6379\u003e INCRBY number 300 (integer) 1400 127.0.0.1:6379\u003e GET number \"1400\" 127.0.0.1:6379\u003e DECRBY number 300 (integer) 1100 127.0.0.1:6379\u003e DECRBY number 100 (integer) 1000 127.0.0.1:6379\u003e get number \"1000\" 错误的实例： 127.0.0.1:6379\u003e SET number 1.105 OK 127.0.0.1:6379\u003e INCRBY number 1 (error) ERR value is not an integer or out of range 127.0.0.1:6379\u003e SET message Hello OK 127.0.0.1:6379\u003e DECRBY message 2 (error) ERR value is not an integer or out of range 127.0.0.1:6379\u003e SET bignumber 123456789123456789123456789 OK 127.0.0.1:6379\u003e INCRBY bignumber 3 (error) ER","date":"2019-11-06","objectID":"/posts/redis-command-operation/:2:1","tags":["Redis"],"title":"Redis 常用命令操作","uri":"/posts/redis-command-operation/"},{"categories":["Redis"],"content":"哈希或散列 为字段设置值： 127.0.0.1:6379\u003e HSET user:1001 name imajinyun age 18 (integer) 2 127.0.0.1:6379\u003e HSET user:1001 gender male (integer) 1 127.0.0.1:6379\u003e HSET user:1001 created_at 1573036176 (integer) 1 127.0.0.1:6379\u003e HGETALL user:1001 1) \"name\" 2) \"imajinyun\" 3) \"age\" 4) \"18\" 5) \"gender\" 6) \"male\" 7) \"created_at\" 8) \"1573036176\" 使用新值覆盖旧值： 127.0.0.1:6379\u003e HSET user:1001 name iphone (integer) 1 127.0.0.1:6379\u003e HSET user:1001 name imajinyun (integer) 0 127.0.0.1:6379\u003e HGET user:1001 name \"imajinyun\" 仅在字段不存在的情况下为它设置值： 127.0.0.1:6379\u003e HSETNX user:1001 name peter (integer) 1 127.0.0.1:6379\u003e HSETNX user:1001 name imajinyun (integer) 0 127.0.0.1:6379\u003e HGET user:1001 name \"peter\" 127.0.0.1:6379\u003e HSETNX user:1001 age 18 (integer) 1 127.0.0.1:6379\u003e HGETALL user:1001 1) \"name\" 2) \"peter\" 3) \"age\" 4) \"18\" 获取单个、多个字段的值： 127.0.0.1:6379\u003e HSET user:1001 name imajinyun age 18 (integer) 2 127.0.0.1:6379\u003e HGET user:1001 name \"imajinyun\" 127.0.0.1:6379\u003e HGET user:1001 age \"18\" 127.0.0.1:6379\u003e HGETALL user:1001 1) \"name\" 2) \"imajinyun\" 3) \"age\" 4) \"18\" 获取不存在的字段或者不存在的哈希： 127.0.0.1:6379\u003e HSET user:1001 name imajinyun (integer) 1 127.0.0.1:6379\u003e HGET user:1001 age (nil) 127.0.0.1:6379\u003e HGET user:1002 age (nil) 127.0.0.1:6379\u003e HGETALL user:1002 (empty list or set) 对字段存储的整数值进行加法或减法操作： 127.0.0.1:6379\u003e ","date":"2019-11-06","objectID":"/posts/redis-command-operation/:2:2","tags":["Redis"],"title":"Redis 常用命令操作","uri":"/posts/redis-command-operation/"},{"categories":["Redis"],"content":"列表 ","date":"2019-11-06","objectID":"/posts/redis-command-operation/:2:3","tags":["Redis"],"title":"Redis 常用命令操作","uri":"/posts/redis-command-operation/"},{"categories":["Redis"],"content":"集合 ","date":"2019-11-06","objectID":"/posts/redis-command-operation/:2:4","tags":["Redis"],"title":"Redis 常用命令操作","uri":"/posts/redis-command-operation/"},{"categories":["Redis"],"content":"有序集合 ","date":"2019-11-06","objectID":"/posts/redis-command-operation/:2:5","tags":["Redis"],"title":"Redis 常用命令操作","uri":"/posts/redis-command-operation/"},{"categories":["Redis"],"content":"其它 ","date":"2019-11-06","objectID":"/posts/redis-command-operation/:3:0","tags":["Redis"],"title":"Redis 常用命令操作","uri":"/posts/redis-command-operation/"},{"categories":["PHP","Swoole"],"content":"Swoole 虽然是标准的 PHP 扩展，实际上与普通的扩展不同。普通的扩展只是提供一个库函数。而 Swoole 扩展在运行后会接管 PHP 的控制权，进入事件循环。当 IO 事件发生后底层会自动回调指定的 PHP 函数。说它重新定义了 PHP，一点也不夸张。 ","date":"2019-10-27","objectID":"/posts/php-swoole-get-started/:0:0","tags":["PHP","Swoole"],"title":"Swoole 起步","uri":"/posts/php-swoole-get-started/"},{"categories":["PHP","Swoole"],"content":"概述 Coroutine asynchronous programming framework for PHP Swoole：面向生产环境的 PHP 协程框架 Easy Swoole Swoole Wiki Swoole 到底是个什么东西？ Swoole 是面向生产环境的 PHP 协程框架。使 PHP 开发人员可以编写高性能的协程 TCP、UDP、Unix Socket、HTTP，WebSocket 服务。Swoole 可以广泛应用于互联网、移动通信、企业软件、云计算、网络游戏、物联网（IOT）、车联网、智能家居等领域。 使用 PHP + Swoole 作为网络通信框架，可以使企业 IT 研发团队的效率大大提升，更加专注于开发创新产品。 ","date":"2019-10-27","objectID":"/posts/php-swoole-get-started/:1:0","tags":["PHP","Swoole"],"title":"Swoole 起步","uri":"/posts/php-swoole-get-started/"},{"categories":["PHP","Swoole"],"content":"安装 apt-get update \u0026\u0026 apt-get install vim -y \u0026\u0026 \\ apt-get install openssl -y \u0026\u0026 \\ apt-get install libssl-dev -y \u0026\u0026 \\ apt-get install wget -y \u0026\u0026 \\ apt-get install git -y \u0026\u0026 \\ apt-get install procps -y \u0026\u0026 \\ apt-get install htop -y cd /usr/local/src \u0026\u0026 \\ git clone https://github.com/swoole/swoole-src.git \u0026\u0026 \\ cd swoole-src \u0026\u0026 \\ git checkout v4.4.8 \u0026\u0026 \\ phpize \u0026\u0026 \\ ./configure --enable-openssl \u0026\u0026 \\ make \u0026\u0026 make install touch /usr/local/etc/php/conf.d/swoole.ini \u0026\u0026 echo 'extension=swoole.so' \u003e /usr/local/etc/php/conf.d/swoole.ini ","date":"2019-10-27","objectID":"/posts/php-swoole-get-started/:2:0","tags":["PHP","Swoole"],"title":"Swoole 起步","uri":"/posts/php-swoole-get-started/"},{"categories":["PHP","Swoole"],"content":"使用 ","date":"2019-10-27","objectID":"/posts/php-swoole-get-started/:3:0","tags":["PHP","Swoole"],"title":"Swoole 起步","uri":"/posts/php-swoole-get-started/"},{"categories":["PHP","Swoole"],"content":"创建 HTTP 服务器 \u003c?php $http = new \\Swoole\\Http\\Server('127.0.0.1', 8080); $http-\u003eon('start', static function ($server) { echo \"Swoole http server is started at http://127.0.0.1:8080\\n\"; }); $http-\u003eon('request', static function ($request, $response) { $response-\u003eheader('Content-Type', 'text/plain'); $response-\u003eend(\"Hello World!\\n\"); }); $http-\u003estart(); ","date":"2019-10-27","objectID":"/posts/php-swoole-get-started/:3:1","tags":["PHP","Swoole"],"title":"Swoole 起步","uri":"/posts/php-swoole-get-started/"},{"categories":["PHP","Swoole"],"content":"创建 WebSocket 服务器 \u003c?php $websocket = new \\Swoole\\WebSocket\\Server('127.0.0.1', 8080); $websocket-\u003eon('open', static function ($server, $request) { echo \"Connection open: {$request-\u003efd}\\n\"; }); $websocket-\u003eon('message', static function ($server, $frame) { echo \"Received message: {$frame-\u003edata}\\n\"; $server-\u003epush($frame-\u003efd, json_encode(['hello', 'world'])); }); $websocket-\u003eon('close', static function ($server, $fd) { echo \"Connection close: {$fd}\\n\"; }); $websocket-\u003estart(); ","date":"2019-10-27","objectID":"/posts/php-swoole-get-started/:3:2","tags":["PHP","Swoole"],"title":"Swoole 起步","uri":"/posts/php-swoole-get-started/"},{"categories":["PHP","Swoole"],"content":"创建 TCP 服务器 TCP 服务器： \u003c?php $server = new \\Swoole\\Server('127.0.0.1', 8080); $server-\u003eon('connect', static function ($server, $request) { echo \"Connection open: {$request-\u003efd}\\n\"; }); $server-\u003eon('receive', static function ($server, $fd, $id, $data) { $server-\u003esend($fd, \"Swoole: {$data}\"); $server-\u003eclose($fd); }); $server-\u003eon('close', static function ($server, $fd) { echo \"Connection close: {$fd}\\n\"; }); $server-\u003estart(); TCP 客户端： \u003c?php $client = new \\Swoole\\Client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_ASYNC); $client-\u003eon('connect', static function ($client) { $client-\u003esend(\"Hello World!\\n\"); }); $client-\u003eon('receive', static function ($client, $data) { echo \"Received: {$data}\\n\"; }); $client-\u003eon('error', static function ($client) { echo \"Connection failed\\n\"; }); $client-\u003eon('close', static function ($client) { echo \"Connection close\\n\"; }); $client-\u003econnect('127.0.0.1', 8080, 0.5); ","date":"2019-10-27","objectID":"/posts/php-swoole-get-started/:3:3","tags":["PHP","Swoole"],"title":"Swoole 起步","uri":"/posts/php-swoole-get-started/"},{"categories":["PHP","Swoole"],"content":"问题 error \"Enable openssl support, require openssl library.： // 确定 openssl 位置 which openssl /usr/local/opt/openresty-openssl/bin/openssl // 安装 swoole 时指定 openssl 路径 pecl install swoole downloading swoole-4.4.8.tgz ... Starting to download swoole-4.4.8.tgz (1,427,235 bytes) .........................................................................................................................................................................................................................................................................................done: 1,427,235 bytes 391 source files, building running: phpize Configuring for: PHP Api Version: 20180731 Zend Module Api No: 20180731 Zend Extension Api No: 320180731 enable sockets supports? [no] : yes enable openssl support? [no] : yes --with-openssl-dir=/usr/local/opt/openssl@1.1/bin/openssl enable http2 support? [no] : yes enable mysqlnd support? [no] : yes building in /private/tmp/pear/temp/pear-build-majinyunwRSXz0/swoole-4.4.8 // 安装成功信息 Build process completed successfully Installing '/usr/local/Cellar/php/7.3.10/include/php/ext/swoole/config.h' Installing '/usr/local/Cellar/php/7.3.10/pecl/20180731/swoole.so' install ok: channel://pecl.php.net/swoole-4.4.8 Extension swoole enabled in php.ini ","date":"2019-10-27","objectID":"/posts/php-swoole-get-started/:4:0","tags":["PHP","Swoole"],"title":"Swoole 起步","uri":"/posts/php-swoole-get-started/"},{"categories":["Mac"],"content":"记录一些终端中的技巧和命令，鉴于经常使用终端，在某个不经意的瞬间忘记了『还有这种操作』，特此记录以飨自己。 ","date":"2019-02-05","objectID":"/posts/mac-command-commands-2/:0:0","tags":["Mac"],"title":"Mac 实用命令收集二","uri":"/posts/mac-command-commands-2/"},{"categories":["Mac"],"content":"移除打开终端时的提示语 Remove the『Last login』Message from the Terminal // 创建 .hushlogin 文件 $ touch .hushlogin ","date":"2019-02-05","objectID":"/posts/mac-command-commands-2/:1:0","tags":["Mac"],"title":"Mac 实用命令收集二","uri":"/posts/mac-command-commands-2/"},{"categories":["Mac"],"content":"终端中使用 telnet How to Get Telnet for MacOS in Mojave or High Sierra // 安装 telnet $ brew install telnet ","date":"2019-02-05","objectID":"/posts/mac-command-commands-2/:2:0","tags":["Mac"],"title":"Mac 实用命令收集二","uri":"/posts/mac-command-commands-2/"},{"categories":["Mac"],"content":"终端中使用上传下载 Set rz and sz on Mac macOS 中使用 rz、sz 传输文件 // 安装 lrzsz $ brew install lrzsz ","date":"2019-02-05","objectID":"/posts/mac-command-commands-2/:3:0","tags":["Mac"],"title":"Mac 实用命令收集二","uri":"/posts/mac-command-commands-2/"},{"categories":["Mac"],"content":"检索文件 // 更新索引 $ sudo /usr/libexec/locate.updatedb // 检索文件 $ locate xxx.xxx ","date":"2019-02-05","objectID":"/posts/mac-command-commands-2/:4:0","tags":["Mac"],"title":"Mac 实用命令收集二","uri":"/posts/mac-command-commands-2/"},{"categories":["Mac"],"content":"masOS VSCode Vim 模式无法持续按键 // For VSCode $ defaults write com.microsoft.VSCode ApplePressAndHoldEnabled -bool false // For VSCode Insiders $ defaults write com.microsoft.VSCodeInsiders ApplePressAndHoldEnabled -bool false // For VSCodium $ defaults write com.visualstudio.code.oss ApplePressAndHoldEnabled -bool false // To enable global key-repeat // this is helpful if you\\'re using Vim in a PWA like code-server $ defaults write -g ApplePressAndHoldEnabled -bool false OR $ defaults delete -g ApplePressAndHoldEnabled // 查看对 com.microsoft.VSCode 的设置 $ defaults read com.microsoft.VSCode ApplePressAndHoldEnabled ","date":"2019-02-05","objectID":"/posts/mac-command-commands-2/:5:0","tags":["Mac"],"title":"Mac 实用命令收集二","uri":"/posts/mac-command-commands-2/"},{"categories":["Mac"],"content":"『千里之行，始于足下』，掌握高频使用的命令也不例外。积铢累寸，总有一天，你终会在命令行中游刃有余。 ","date":"2019-02-04","objectID":"/posts/mac-command-commands-1/:0:0","tags":["Mac"],"title":"Mac 实用命令收集一","uri":"/posts/mac-command-commands-1/"},{"categories":["Mac"],"content":"让终端说英语 $ say hello // 让程序执行完了说一声 $ sleep 5 \u0026\u0026 say \"this is a test\" ","date":"2019-02-04","objectID":"/posts/mac-command-commands-1/:1:0","tags":["Mac"],"title":"Mac 实用命令收集一","uri":"/posts/mac-command-commands-1/"},{"categories":["Mac"],"content":"标记文件或者文件夹，用 Spotlight 打开 选中一个文件或者文件夹，Command+I 打开简介，在添加标记中输入关键词，关闭简介窗口。打开 Spotlight 输入刚才的关键词，可以准确定位 ","date":"2019-02-04","objectID":"/posts/mac-command-commands-1/:2:0","tags":["Mac"],"title":"Mac 实用命令收集一","uri":"/posts/mac-command-commands-1/"},{"categories":["Mac"],"content":"使用 sips 命令批量处理图片 // 将图片宽度缩小为 800px，高度按比例缩放 $ sips -Z 800 ~/001.jpg // 顺时针旋转 90 度 $ sips -r 90 ~/001.jpg // 垂直反转 $ sips -f vertical ~/001.jpg ","date":"2019-02-04","objectID":"/posts/mac-command-commands-1/:3:0","tags":["Mac"],"title":"Mac 实用命令收集一","uri":"/posts/mac-command-commands-1/"},{"categories":["Mac"],"content":"把当前网页附加到待发送邮件中 在 Safari 浏览器中浏览网页时，通过 Command+I 可以直接打开邮件并把当前网页附加到待发送的邮件中 ","date":"2019-02-04","objectID":"/posts/mac-command-commands-1/:4:0","tags":["Mac"],"title":"Mac 实用命令收集一","uri":"/posts/mac-command-commands-1/"},{"categories":["Mac"],"content":"删除文件和清空纸篓 删除文件：Command+Delete 彻底删除：Command+Alt+Delete ","date":"2019-02-04","objectID":"/posts/mac-command-commands-1/:5:0","tags":["Mac"],"title":"Mac 实用命令收集一","uri":"/posts/mac-command-commands-1/"},{"categories":["Mac"],"content":"安装 Go2Shell，快速在当前目录打开终端的工具 默认情况下是打开系统终端，这里配置成用 iTerm2 打开终端 $ open -a Go2Shell --args config ","date":"2019-02-04","objectID":"/posts/mac-command-commands-1/:6:0","tags":["Mac"],"title":"Mac 实用命令收集一","uri":"/posts/mac-command-commands-1/"},{"categories":["Mac"],"content":"修改终端电脑名称 $ sudo scutil --set HostName your-host-name $ hostname // 查看 `hostname` ","date":"2019-02-04","objectID":"/posts/mac-command-commands-1/:7:0","tags":["Mac"],"title":"Mac 实用命令收集一","uri":"/posts/mac-command-commands-1/"},{"categories":["Mac"],"content":"快速复制和粘贴 // 将列出的主目录复制到剪贴板 $ ls ~ | pbcopy // 文件的内容读入剪贴板 $ pbcopy \u003c ~/.zshrc // 将剪贴板的内容写入到文件中 $ pbpaste \u003e\u003e ~/demo.php ","date":"2019-02-04","objectID":"/posts/mac-command-commands-1/:8:0","tags":["Mac"],"title":"Mac 实用命令收集一","uri":"/posts/mac-command-commands-1/"},{"categories":["Mac"],"content":"找回任何来源选项 // 找回安全与隐私中的信任 \"任何来源\" 选项 $ sudo spctl --master-disable ","date":"2019-02-04","objectID":"/posts/mac-command-commands-1/:9:0","tags":["Mac"],"title":"Mac 实用命令收集一","uri":"/posts/mac-command-commands-1/"},{"categories":["Mac"],"content":"快速查看日历 $ cal 或 $ cal 2018 ","date":"2019-02-04","objectID":"/posts/mac-command-commands-1/:10:0","tags":["Mac"],"title":"Mac 实用命令收集一","uri":"/posts/mac-command-commands-1/"},{"categories":["Mac"],"content":"Xcode Command Line Tools ","date":"2019-02-04","objectID":"/posts/mac-command-commands-1/:11:0","tags":["Mac"],"title":"Mac 实用命令收集一","uri":"/posts/mac-command-commands-1/"},{"categories":["Mac"],"content":"检查 Xcode 安装包是否已经被安装 $ xcode-select -p ","date":"2019-02-04","objectID":"/posts/mac-command-commands-1/:11:1","tags":["Mac"],"title":"Mac 实用命令收集一","uri":"/posts/mac-command-commands-1/"},{"categories":["Mac"],"content":"安装 $ xcode-select --install ","date":"2019-02-04","objectID":"/posts/mac-command-commands-1/:11:2","tags":["Mac"],"title":"Mac 实用命令收集一","uri":"/posts/mac-command-commands-1/"},{"categories":["Mac"],"content":"Mac 的启动组合键 这些组合键适用于基于 Intel 的 Mac 电脑。在 Mac 启动后，可以使用其他 Mac 键盘快捷键 Shortcut Description Shift (⇧) 以安全模式启动 Option (⌥) 启动进入启动管理器 D 从内建的 Apple Hardware Test 或 Apple Diagnostics 实用工具启动，具体取决于 Mac 机型 N 从兼容的 NetBoot 服务器（若可用）启动。要使用 NetBoot 服务器上默认的引导映像，则请按住 Option-N Command+R 从内建的 macOS 恢复系统启动。或者可以使用 Option+Command+R 或 Shift+Option+Command+R 以通过互联网从 macOS 恢复功能启动 Option+Command+P+R 重置 NVRAM（或 PRAM） Command+S 以单用户模式启动 T 以目标磁盘模式启动 Command+V 以详细模式启动 推出键 (⏏)、F12、鼠标键或触控板按钮 推出可移动介质 ","date":"2019-02-04","objectID":"/posts/mac-command-commands-1/:12:0","tags":["Mac"],"title":"Mac 实用命令收集一","uri":"/posts/mac-command-commands-1/"},{"categories":["Mac"],"content":"终端中上传下载 // Mac 安装 $ brew install lrzsz // Linux 安装 $ yum install -y lrzsz 或 $ apt install -y lrzsz // Intel Chip $ cd /usr/local/bin // M1 Chip $ cd /opt/homebrew/bin // 创建 iterm2-recv-zmodem.sh 文件 $ vim iterm2-recv-zmodem.sh #!/bin/bash # Author: Matt Mastracci (matthew@mastracci.com) # AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script # licensed under cc-wiki with attribution required # Remainder of script public domain osascript -e 'tell application \"iTerm2\" to version' \u003e /dev/null 2\u003e\u00261 \u0026\u0026 NAME=iTerm2 || NAME=iTerm if [[ $NAME = \"iTerm\" ]]; then FILE=`osascript -e 'tell application \"iTerm\" to activate' -e 'tell application \"iTerm\" to set thefile to choose folder with prompt \"Choose a folder to place received files in\"' -e \"do shell script (\\\"echo \\\"\u0026(quoted form of POSIX path of thefile as Unicode text)\u0026\\\"\\\")\"` else FILE=`osascript -e 'tell application \"iTerm2\" to activate' -e 'tell application \"iTerm2\" to set thefile to choose folder with prompt \"Choose a folder to place received files in\"' -e \"do shell script (\\\"echo \\\"\u0026(quoted form of POSIX path of thefile as Unicode text)\u0026\\\"\\\")\"` fi if [[ $FILE = \"\" ]]; then echo Cancelled. # Send ZModem cancel echo -e \\\\x18\\\\x18\\\\x18\\\\x18\\\\x18 sleep 1 echo echo \\# Cancelled transfer else cd \"$FILE\" # TODO: Here according to the actual command address /usr/local/bin/rz -E -e -b sleep 1 echo echo echo \\# Sent \\-\\\u003e $FILE fi // 创建 iterm2-send-zmodem.sh 文件 $ vim iterm2-send-zmodem.sh #!/bin/bash # Author: Matt Mastracci (matthew@mastracci.com) # AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script # licensed under cc-wiki with attribution required # Remainder of script public domain osascript -e 'tell application \"iTerm2\" to version' \u003e /dev/null 2\u003e\u00261 \u0026\u0026 NAME=iTerm2 || NAME=iTerm if [[ $NAME = \"iTerm\" ]]; then FILE=`osascript -e 'tell application \"iTerm\" to activate' -e 'tell application \"iTerm\" to set thefile to choose file with prompt \"Choose a file to send\"' -e \"do shell script (\\\"echo \\\"\u0026(quoted form of POSIX path of thefile as Unicode text)\u0026\\\"\\\")\"` else FILE=`osascript -e 'tell application \"iTerm2\" to activate' -e 'tell application \"iTerm2\" to set thefile to choose file with prompt \"Choose a file to send\"' -e \"do shell script (\\\"echo \\\"\u0026(quoted form of POSIX path of thefile as Unicode text)\u0026\\\"\\\")\"` fi if [[ $FILE = \"\" ]]; then echo Cancelled. # Send ZModem cancel echo -e \\\\x18\\\\x18\\\\x18\\\\x18\\\\x18 sleep 1 echo echo \\# Cancelled transfer else # TODO: Here according to the actual command address /usr/local/bin/sz \"$FILE\" -e -b sleep 1 echo echo \\# Received $FILE fi // 添加执行权限 $ chmod +x /path/to/iterm2-* 打开终端的偏好，Profiles \u003e Profile Name (选中你自定义设置) \u003e Advanced \u003e Triggers，点击编辑，进行如下设置： Regular Expression Action Parameters Instant Enabled rz waiting to receive.\\*\\*B0100 Run Silent Coprocess... /opt/homebrew/bin/iterm2-send-zmodem.sh False True \\*\\*B00000000000000 Run Silent Coprocess... /opt/homebrew/bin/iterm2-recv-zmodem.sh False True ","date":"2019-02-04","objectID":"/posts/mac-command-commands-1/:13:0","tags":["Mac"],"title":"Mac 实用命令收集一","uri":"/posts/mac-command-commands-1/"},{"categories":["Mac"],"content":"终端下批量替换目录下文件中的内容 # 查看当前目录下所有文件中的 foo 内容 grep -nr 'foo' . # 预览将要替换的文件内容 grep -rl 'foo' . | xargs sed 's/foo/bar/g' # 批量替换 grep -rl 'foo' . | xargs sed -i '' 's/foo/bar/g' ","date":"2019-02-04","objectID":"/posts/mac-command-commands-1/:14:0","tags":["Mac"],"title":"Mac 实用命令收集一","uri":"/posts/mac-command-commands-1/"},{"categories":["Linux"],"content":"Shadowsocks 是一种基于 Socks5 代理方式的加密传输协议，也可以指实现这个协议的各种开发包。当前包使用 Python、C、C++、C#、Go 语言等编程语言开发，大部分主要实现（iOS 平台的除外）采用 Apache 许可证、GPL、MIT 许可证等多种自由软件许可协议开放源代码。Shadowsocks 分为服务器端和客户端，在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。不多说，你懂得。 ","date":"2019-01-02","objectID":"/posts/linux-shadowsocks/:0:0","tags":["Linux"],"title":"Ubuntu 安装配置 Shadowsocks","uri":"/posts/linux-shadowsocks/"},{"categories":["Linux"],"content":"服务端 ","date":"2019-01-02","objectID":"/posts/linux-shadowsocks/:1:0","tags":["Linux"],"title":"Ubuntu 安装配置 Shadowsocks","uri":"/posts/linux-shadowsocks/"},{"categories":["Linux"],"content":"服务端安装 参见不同支持语言的安装方式 // 安装 pip3 $ sudo apt install python3-pip // 安装 shadowsocks $ pip3 install https://github.com/shadowsocks/shadowsocks/archive/master.zip // 检查 shadowsocks 版本 $ ssserver --version Shadowsocks 3.0.0 ","date":"2019-01-02","objectID":"/posts/linux-shadowsocks/:1:1","tags":["Linux"],"title":"Ubuntu 安装配置 Shadowsocks","uri":"/posts/linux-shadowsocks/"},{"categories":["Linux"],"content":"服务端配置 $ sudo mkdir /etc/shadowsocks $ sudo vim /etc/shadowsocks/shadowsocks.json { \"server\": \"server_ip\", // 服务端监听 IP 地址，有人填 0.0.0.0 据说也可以 \"server_port\": 9009, // 服务器监听端口号，一般自定义 \"local_address\": \"127.0.0.1\", // 本地代理 IP 地址 \"local_port\": 1080, // 本地代理端口号 \"password\": \"password\", // 服务端密码 \"timeout\": 300, // 超时时间，以秒为单位 \"method\": \"aes-256-cfb\", // 加密方式，据说 rc4-md5 的加密方式速度要快 \"mode\": \"udp\" // 运行模式 } ","date":"2019-01-02","objectID":"/posts/linux-shadowsocks/:1:2","tags":["Linux"],"title":"Ubuntu 安装配置 Shadowsocks","uri":"/posts/linux-shadowsocks/"},{"categories":["Linux"],"content":"服务启动 // 加载配置启动服务 $ sudo ssserver -c /etc/shadowsocks/shadowsocks.json -d start 或 $ sudo ssserver -s 0.0.0.0 -p 443 -k password -m rc4-md5 -t 300 --user nobody -d start // 后台一直运行 Shadowsocks 服务 $ sudo nohup ssserver -c /etc/shadowsocks/shadowsocks.json \u003e /dev/null 2\u003e\u00261 \u0026 // 停止服务 $ sudo ssserver -d stop // 查看日志 $ cat /var/log/shadowsocks.log ","date":"2019-01-02","objectID":"/posts/linux-shadowsocks/:1:3","tags":["Linux"],"title":"Ubuntu 安装配置 Shadowsocks","uri":"/posts/linux-shadowsocks/"},{"categories":["Linux"],"content":"开机启动配置 配置文件 // 在 /lib/systemd/system 下创建文件并粘贴如下内容 $ sudo vim /lib/systemd/system/shadowsocks.service [Unit] Description=Shadowsocks Server After=network.target [Service] ExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks/shadowsocks.json Restart=on-abort [Install] WantedBy=multi-user.target 设置启动 // 设置开机启动 $ sudo systemctl enable shadowsocks.service // 启动 $ sudo systemctl start shadowsocks.service // 状态 $ sudo systemctl status shadowsocks.service ● shadowsocks.service - Shadowsocks Server Loaded: loaded (/lib/systemd/system/shadowsocks.service; enabled; vendor preset: enabled) Active: active (running) since Tue 2019-01-01 21:45:35 EST; 48min ago Main PID: 446 (ssserver) Tasks: 1 (limit: 1175) CGroup: /system.slice/shadowsocks.service └─446 /usr/bin/python3 /usr/local/bin/ssserver -c /etc/shadowsocks/shadowsocks.json // 重启 $ sudo systemctl restart shadowsocks.service // 停止 $ sudo systemctl stop shadowsocks.service ","date":"2019-01-02","objectID":"/posts/linux-shadowsocks/:1:4","tags":["Linux"],"title":"Ubuntu 安装配置 Shadowsocks","uri":"/posts/linux-shadowsocks/"},{"categories":["Linux"],"content":"客户端 ","date":"2019-01-02","objectID":"/posts/linux-shadowsocks/:2:0","tags":["Linux"],"title":"Ubuntu 安装配置 Shadowsocks","uri":"/posts/linux-shadowsocks/"},{"categories":["Linux"],"content":"客户端安装 下载对应平台的安装包安装即可 ","date":"2019-01-02","objectID":"/posts/linux-shadowsocks/:2:1","tags":["Linux"],"title":"Ubuntu 安装配置 Shadowsocks","uri":"/posts/linux-shadowsocks/"},{"categories":["Linux"],"content":"客户端配置 ","date":"2019-01-02","objectID":"/posts/linux-shadowsocks/:2:2","tags":["Linux"],"title":"Ubuntu 安装配置 Shadowsocks","uri":"/posts/linux-shadowsocks/"},{"categories":["Linux"],"content":"参考 Shadowsocks (简体中文) Ubuntu 18.04安装配置Shadowsocks实现科学上网 ","date":"2019-01-02","objectID":"/posts/linux-shadowsocks/:3:0","tags":["Linux"],"title":"Ubuntu 安装配置 Shadowsocks","uri":"/posts/linux-shadowsocks/"},{"categories":["Mac"],"content":"早年有位同僚 Sublime 使的巨溜无比，各种文件切换、命令操作、文本编辑等在其指间飞舞，往来冲突，如入无人之境。顿时暗自称奇，虽诺诺问其故，道曰，此不过配以插件及代码片段，手熟罢了。卧槽，原来如此，虽暗下决心，他日策吾 Mac 扬指期间，必当远甚今日矣。自此，染指各种时髦编辑器及 IDE，乐不思蜀，竟忘了干正事了，不多逼逼了，先撩一撩代码片段。 Mac VSCode 起步 Mac VSCode 基本操作 Mac VSCode 快捷键 Mac VSCode 代码片段 Mac VSCode 效率扩展 ","date":"2018-12-05","objectID":"/posts/mac-vscode-snippets/:0:0","tags":["Mac","VSCode"],"title":"Mac VSCode 代码片段","uri":"/posts/mac-vscode-snippets/"},{"categories":["Mac"],"content":"自定义本地代码片段 点击 VScode 菜单栏中的 Code 在下拉的 首选项 菜单中点击 用户代码片段 并在输入框中输入适合的语言开始创建代码片段。 ","date":"2018-12-05","objectID":"/posts/mac-vscode-snippets/:1:0","tags":["Mac","VSCode"],"title":"Mac VSCode 代码片段","uri":"/posts/mac-vscode-snippets/"},{"categories":["Mac"],"content":"代码片段字段 代码片段的名称：尽量起的有意义即可 prefix：触发代码片段的前缀 body：代码片段的主体。$0 表示光标的最终位置；$1~$N 表示每次按 Tab 键后光标定位的位置；${N:placeholder} 表示占位，多个占位符请使用相同的标识 IDs description：代码片段的描述 ","date":"2018-12-05","objectID":"/posts/mac-vscode-snippets/:1:1","tags":["Mac","VSCode"],"title":"Mac VSCode 代码片段","uri":"/posts/mac-vscode-snippets/"},{"categories":["Mac"],"content":"代码片段实例 有时候定义了多个光标插入点，按快了 Tab 键可能跳过了正当输入的位置，此时亦可按 Shift+Tab 回跳到上一个跳过的位置处，多按可往回退。 以下是一个以 PHP 为例的代码片段。 { // 代码片段的名称 \"PHPClass\": { // 按键触发的前缀 \"prefix\": \"class\", // 触发后展开的代码主体 \"body\": [ \"${1:namespace ${2:App}};\", \"\", \"class ${3:ClassName} ${4:extends ${5:AnotherClass}} ${6:implements ${7:Interface}}\", \"{\", \"\\t$0\", \"}\", \"\" ], // 代码片段的描述 \"description\": \"PHP class\" } } ","date":"2018-12-05","objectID":"/posts/mac-vscode-snippets/:1:2","tags":["Mac","VSCode"],"title":"Mac VSCode 代码片段","uri":"/posts/mac-vscode-snippets/"},{"categories":["Mac"],"content":"写扩展分享代码片段 ","date":"2018-12-05","objectID":"/posts/mac-vscode-snippets/:2:0","tags":["Mac","VSCode"],"title":"Mac VSCode 代码片段","uri":"/posts/mac-vscode-snippets/"},{"categories":["Mac"],"content":"创建账号 到 Extensions for the Visual Studio family of products 上注册属于自己的账号。 ","date":"2018-12-05","objectID":"/posts/mac-vscode-snippets/:2:1","tags":["Mac","VSCode"],"title":"Mac VSCode 代码片段","uri":"/posts/mac-vscode-snippets/"},{"categories":["Mac"],"content":"安装扩展 安装开发辅助扩展 Yo Code - Extension and Customization Generator VSCode Yo Code Documentation // 安装 yo $ npm install -g yo npm WARN deprecated cross-spawn-async@2.2.5: cross-spawn no longer requires a build toolchain, use it instead /usr/local/bin/yo -\u003e /usr/local/lib/node_modules/yo/lib/cli.js /usr/local/bin/yo-complete -\u003e /usr/local/lib/node_modules/yo/lib/completion/index.js \u003e spawn-sync@1.0.15 postinstall /usr/local/lib/node_modules/yo/node_modules/spawn-sync \u003e node postinstall \u003e yo@2.0.5 postinstall /usr/local/lib/node_modules/yo \u003e yodoctor Yeoman Doctor Running sanity checks on your system ✔ Global configuration file is valid ✔ NODE_PATH matches the npm root ✔ Node.js version ✔ No .bowerrc file in home directory ✔ No .yo-rc.json file in home directory ✔ npm version ✔ yo version Everything looks all right! + yo@2.0.5 added 537 packages from 265 contributors in 36.448s // 安装 generator-code $ npm install -g generator-code + generator-code@1.1.43 added 381 packages from 284 contributors in 61.462s // 安装 vsce $ npm install -g vsce /usr/local/bin/vsce -\u003e /usr/local/lib/node_modules/vsce/out/vsce + vsce@1.53.2 added 60 packages from 67 contributors in 7.519s 运行开发扩展命令 $ yo code _-----_ ╭──────────────────────────╮ | | │ Welcome to the Visual │ |--(o)--| │ Studio Code Extension │ `---------´ │ generator! │ ( _´U`_ ) ╰──────────────────────────╯ /___A___\\ / | ~ | __'.___.'__ ´ ` |° ´ Y ` ? What type of extension do you want to create? (Use arrow keys) ❯ New Extension (TypeScript) New Extension (JavaScript) New Color Theme New Language Support New Code Snippets New Keymap New Extension Pack (Move up and down to reveal more choices) ","date":"2018-12-05","objectID":"/posts/mac-vscode-snippets/:2:2","tags":["Mac","VSCode"],"title":"Mac VSCode 代码片段","uri":"/posts/mac-vscode-snippets/"},{"categories":["Mac"],"content":"创建代码片段项目 $ yo code your-project-name _-----_ ╭──────────────────────────╮ | | │ Welcome to the Visual │ |--(o)--| │ Studio Code Extension │ `---------´ │ generator! │ ( _´U`_ ) ╰──────────────────────────╯ /___A___\\ / | ~ | __'.___.'__ ´ ` |° ´ Y ` ? What type of extension do you want to create? New Code Snippets Folder location that contains Text Mate (.tmSnippet) and Sublime snippets (.sublime-snippet) or press ENTER to start with a new snippet file. ? Folder name for import or none for new: ? What's the name of your extension? your-project-name ? What's the identifier of your extension? your-project-name ? What's the description of your extension? VSCode PHP Snippets Enter the language for which the snippets should appear. The id is an identifier and is single, lower-case name such as 'php', 'javascript' ? Language id: php create your-project-name/.vscode/launch.json create your-project-name/package.json create your-project-name/vsc-extension-quickstart.md create your-project-name/README.md create your-project-name/CHANGELOG.md create your-project-name/snippets/snippets.json create your-project-name/.vscodeignore Your extension your-project-name has been created! To start editing with Visual Studio Code, use the following commands: cd your-project-name code . Open vsc-extension-quickstart.md inside the new extension for further instructions on how to modify, test and publish your extension. For more information, also visit http://code.visualstudio.com and follow us @code. ","date":"2018-12-05","objectID":"/posts/mac-vscode-snippets/:2:3","tags":["Mac","VSCode"],"title":"Mac VSCode 代码片段","uri":"/posts/mac-vscode-snippets/"},{"categories":["Mac"],"content":"项目发布 package.json 文件的编写完善请参见相关文档。 Publishing Extensions // 创建发布者 $ vsce create-publisher your-publisher-name // 以发布者身份登录，需要在 Azure DevOps 提前创建令牌 $ vsce login your-publisher-name Publisher 'your-publisher-name' is already known Do you want to overwrite its PAT? [y/N] y Personal Access Token for publisher 'your-publisher-name': **** // 发布，视情况发布 $ vsce publish major|minor|patch // vsce 命令 $ vsce --help Usage: vsce [options] [command] Options: -V, --version output the version number -h, --help output usage information Commands: ls [options] Lists all the files that will be published package [options] Packages an extension publish [options] [\u003cversion\u003e] Publishes an extension unpublish [options] [\u003cextensionid\u003e] Unpublishes an extension. Example extension id: microsoft.csharp. list \u003cpublisher\u003e Lists all extensions published by the given publisher ls-publishers List all known publishers create-publisher \u003cpublisher\u003e Creates a new publisher delete-publisher \u003cpublisher\u003e Deletes a publisher login \u003cpublisher\u003e Add a publisher to the known publishers list logout \u003cpublisher\u003e Remove a publisher from the known publishers list show [options] \u003cextensionid\u003e Show extension metadata search [options] \u003ctext\u003e search extension gallery * ","date":"2018-12-05","objectID":"/posts/mac-vscode-snippets/:2:4","tags":["Mac","VSCode"],"title":"Mac VSCode 代码片段","uri":"/posts/mac-vscode-snippets/"},{"categories":["Mac"],"content":"VSCode 的强大离不开庞大的扩展市场，在 VSCode marketplace 上只有你想不到的，没有你找不到的。在经历一番折腾后少不了对它的评头论足，有那么些扩展确实有一种相见恨晚之感，当然也不能太贪，装几个高频的就好，毕竟装多了之后扩展的激活和加载也费时间，所谓『效率』也需要那么点权衡呀。 Mac VSCode 起步 Mac VSCode 基本操作 Mac VSCode 快捷键 Mac VSCode 代码片段 Mac VSCode 效率扩展 ","date":"2018-12-04","objectID":"/posts/mac-vscode-extension/:0:0","tags":["Mac","VSCode"],"title":"Mac VSCode 效率扩展","uri":"/posts/mac-vscode-extension/"},{"categories":["Mac"],"content":"操作类扩展 ","date":"2018-12-04","objectID":"/posts/mac-vscode-extension/:1:0","tags":["Mac","VSCode"],"title":"Mac VSCode 效率扩展","uri":"/posts/mac-vscode-extension/"},{"categories":["Mac"],"content":"文件操作扩展 VSCode Advanced New File File Utils - Visual Studio Code Extension VSCodeVim Change Case Extension for Visual Studio Code Rainbow Brackets Bracket Pair Colorizer 2 ","date":"2018-12-04","objectID":"/posts/mac-vscode-extension/:1:1","tags":["Mac","VSCode"],"title":"Mac VSCode 效率扩展","uri":"/posts/mac-vscode-extension/"},{"categories":["Mac"],"content":"工程增强扩展 Chinese (Simplified) Language Pack for Visual Studio Code Project Manager EditorConfig for VS Code DotENV YAML Support by Red Hat gitignore extension for Visual Studio Code Code Runner markdownlint Markdown All in One vscode-database XML Tools Better Comments VSCode Advanced New File ","date":"2018-12-04","objectID":"/posts/mac-vscode-extension/:1:2","tags":["Mac","VSCode"],"title":"Mac VSCode 效率扩展","uri":"/posts/mac-vscode-extension/"},{"categories":["Mac"],"content":"Git 增强扩展 GitLens — Git supercharged Git History ","date":"2018-12-04","objectID":"/posts/mac-vscode-extension/:1:3","tags":["Mac","VSCode"],"title":"Mac VSCode 效率扩展","uri":"/posts/mac-vscode-extension/"},{"categories":["Mac"],"content":"主题类扩展 Material Icon Theme Material Theme One Dark Pro vscode-icons ","date":"2018-12-04","objectID":"/posts/mac-vscode-extension/:2:0","tags":["Mac","VSCode"],"title":"Mac VSCode 效率扩展","uri":"/posts/mac-vscode-extension/"},{"categories":["Mac"],"content":"开发类扩展 ","date":"2018-12-04","objectID":"/posts/mac-vscode-extension/:3:0","tags":["Mac","VSCode"],"title":"Mac VSCode 效率扩展","uri":"/posts/mac-vscode-extension/"},{"categories":["Mac"],"content":"前端扩展 Debugger for Chrome ESLint HTML CSS Support IntelliSense for CSS class names in HTML Close HTML/XML tag Auto Close Tag npm npm Intellisense Path Intellisense Vetur Beautify ","date":"2018-12-04","objectID":"/posts/mac-vscode-extension/:3:1","tags":["Mac","VSCode"],"title":"Mac VSCode 效率扩展","uri":"/posts/mac-vscode-extension/"},{"categories":["Mac"],"content":"PHP 扩展 PHP Intelephense PHP Namespace Resolver PHP DocBlocker PHP Debug php cs fixer ","date":"2018-12-04","objectID":"/posts/mac-vscode-extension/:3:2","tags":["Mac","VSCode"],"title":"Mac VSCode 效率扩展","uri":"/posts/mac-vscode-extension/"},{"categories":["Mac"],"content":"经常码字少不了快捷键的帮衬，有些神奇的效果居然是在误按之下出现，着实把我惊呆了，还有这种操作之状此起彼伏。经常在误操作后记不得对应的快捷键，瞎激动一会儿后又嘎然而止。为了避免这种几度的尴尬窘境，我还是决定动动懒笔头记一记，万一哪天想起这种操作了呢？ Mac VSCode 起步 Mac VSCode 基本操作 Mac VSCode 快捷键 Mac VSCode 代码片段 Mac VSCode 效率扩展 ","date":"2018-12-03","objectID":"/posts/mac-vscode-basic/:0:0","tags":["Mac","VSCode"],"title":"Mac VSCode 基本操作","uri":"/posts/mac-vscode-basic/"},{"categories":["Mac"],"content":"基础操作法 ","date":"2018-12-03","objectID":"/posts/mac-vscode-basic/:1:0","tags":["Mac","VSCode"],"title":"Mac VSCode 基本操作","uri":"/posts/mac-vscode-basic/"},{"categories":["Mac"],"content":"光标操作 单词粒度的光标移动：左移 Alt+⬅️；右移 Alt+➡️ 行首行尾的光标移动：行首 Cmd+⬅️；行尾 Cmd+➡️ 代码块间的光标移动：按下 Shift+Cmd+\\ 后再左右闭合标签之前来回移动 文档首尾的光标移动：文档首部 Cmd+⬆️；文档尾部 Cmd+⬇️ 某行文本前后插入空行：某行文本前一行插入空行 Shift+Cmd+Enter；某行文本后一行插入空行 Cmd+Enter ","date":"2018-12-03","objectID":"/posts/mac-vscode-basic/:1:1","tags":["Mac","VSCode"],"title":"Mac VSCode 基本操作","uri":"/posts/mac-vscode-basic/"},{"categories":["Mac"],"content":"文本操作 选中光标前后的单词：选中光标之前的单词 Shift+Alt+⬅️，继续按左方向键选中更多的单词；选中光标之后的单词 Shift+All+➡️，继续按右方向键选中更多的单词 选中光标前后的整行：选中光标之前的整行 Shift+Cmd+⬅️；选中光标之后的整行 Shift+Cmd+➡️ 选中光标所在的某个闭合标签中的代码：Ctrl+Shift+Cmd+➡️，继续按右方向键扩大选择范围，按左方向键缩小选择范围 连同闭合标签一起选中，按 Shift+Cmd+P，输入 Select to Bracket 选中整行：按 Cmd+I 直接选中整行；按 Cmd+⬅️ 或 Cmd+➡️ 将光标定位到行首或者行尾，然后按 Shift+Cmd+➡️ 或 Shift+Cmd+⬅️ 删除光标前后的单词：删除光标前的单词 Alt+Delete；删除光标后的单词 fn+Alt+Delete 删除光标前后的整行：删除光标前的文本 Cmd+Delete；删除光标后的文本 fn+Cmd+Delete 删除整行：按 Cmd+X 将整行剪切掉；按 Ctrl+Shift+K 删除掉整行；先选中一行，再按 Delete 删除整行 单行文本移动：单行文本向上移动 Alt+⬆️；单行文本向下移动 Alt+⬇️ 多行文本移动：选中多行文本并按 Alt+⬆️；选中多行文本并按 Alt+⬇️ 单行文本复制：单行文本向上复制 Shift+Alt+⬆️；单行文本向下复制 Shift+Alt+⬇️ 多行文本复制：选中复制的文本后按 Shift+Alt+⬆️；选中复制的文本后按 Shift+Alt+⬇️ 代码注释：单行注释 Cmd+/；多行注释 Alt+Shift+A 代码格式化：选中格式化 Cmd+K Cmd+F；文档格式化 Alt+Shift+F 代码缩进：左缩进 Cmd+[；右缩进 Cmd+] 调换字符的位置：Ctrl+T 调整字符的大小写：转换为大写，按 Shift+Cmd+P 后输入 Transform to Uppercase；转换为小写，按 Shift+Cmd+P 后输入 Transform to Lowercase。更高级的转换使用 Change Case Extension for Visual Studio Code 插件 合并到一行：按 Ctrl+J CSS 属性排序：升序排列，按 Shift+Cmd+P 后输入 Sort Lines Ascending；降序排列，按 Shift+Cmd+P 后输入 Sort Lines Descending 撤销光标的移动和选择：按 Cmd+U 创建多光标：针对相同的文本按 Cmd+D 依次创建光标；针对不同的文本，先选中操作的文本，然后按 Alt+Shift+I 将光标定位到选中的所有文本末尾；针对要操作的一块文本，按 Alt+Cmd+⬇️ 向下依次创建光标，按 Alt+Cmd+⬆️ 向上依次创建光标 ","date":"2018-12-03","objectID":"/posts/mac-vscode-basic/:1:2","tags":["Mac","VSCode"],"title":"Mac VSCode 基本操作","uri":"/posts/mac-vscode-basic/"},{"categories":["Mac"],"content":"文件操作 当前打开的文件间跳转：按 Ctrl+Tab 打开已经打开的文件列表，接着按到想要定位的文件后松手 最近打开的文件间跳转：按 Cmd+P 打开最近打开过的文件列表，接着不要松开 Cmd 键直接按 P 定位到文件后松手，或者直接在输入框中模糊搜索；在文件列表很长时，跳过了将要选中的文件，可以按上下方向键回去 在新标签中打开定位的文件：在 Cmd+P 模糊搜索加持下定位到想打开的文件，按 Cmd+Enter 将拆分当前窗口打开定位的文件；在 Cmd+P 循环加持下定位到想打开的文件，需要鼠标点击拆分窗口按钮 行间跳转：按 Ctrl+G 输入等号，当然也可以在行号后加 : 再输入列号 精确跳转到文件的指定行列：Cmd+P 搜索到文件后输入 :行号:列号 即可 仅当前文件符号跳转：按 Cmd+R 打开文件中的所有符号列表；输入 : 后将分类列出符号列表；按上下方向键将实时预览相应的代码块 工作区文件符号跳转：按 Cmd+T 就可以在工作区文件间搜索符号列表，不过速度堪忧 定义跳转：按 F12，需要相关语言的支持 实现跳转：按 Cmd+F12 引用跳转：按 Shift+F12 查看符号被引用的列表 选中文本拖拽：选中一块文本后，直接鼠标拖拽到对应的地方 代码跳转：按住 Alt 后鼠标点击要跳转的代码 链接跳转：按住 Cmd 后鼠标点击就打开相关链接 自动补全：输入要补全的对象后，一般情况下编辑会自动提示要补全的符号列表，按上下方向键选中回车；在输入要补全的对象后，按 Tab 直到想要的补全出现为止 关闭和显示补全列表：按 Esc 关闭补全列表；按 Cmd+Space 显示补全列表；此键原本是 Ctrl+Space 与系统输入法切换冲突，改为 Cmd+Space 是遵循就近原则 快速预览符号信息：在补全列表中选中要补全的符号，按 Cmd+Space 来回切换回显 快速提示符号参数信息：按 Shift+Cmd+Space，按 Esc 关闭提示 自动更正单词拼写：在错误单词上按 Cmd+. 选择正确的进行替换，需要相关语言支持 符号名称重构：按 Cmd+F2 批量重构符号名称 ","date":"2018-12-03","objectID":"/posts/mac-vscode-basic/:1:3","tags":["Mac","VSCode"],"title":"Mac VSCode 基本操作","uri":"/posts/mac-vscode-basic/"},{"categories":["Mac"],"content":"进阶操作 以下给出的命令栏中的搜索只需输入关键字搜索即可，不用刻意完全输入。 ","date":"2018-12-03","objectID":"/posts/mac-vscode-basic/:2:0","tags":["Mac","VSCode"],"title":"Mac VSCode 基本操作","uri":"/posts/mac-vscode-basic/"},{"categories":["Mac"],"content":"工作区定制 修改值请按 Cmd+, 后在用户设置文件 settings.json 文件中添加，相关值的含义请参照默认用户设置值注释文档。 切换状态栏可见性：修改 \"workbench.statusBar.visible\" 切换活动栏可见性：修改 \"workbench.activityBar.visible\" 关闭活动栏打开编辑数量：修改 \"explorer.openEditors.visible\" 切换小地图：修改 \"editor.minimap.enabled\" 切换边栏位置：修改 \"workbench.sideBar.location\" ","date":"2018-12-03","objectID":"/posts/mac-vscode-basic/:2:1","tags":["Mac","VSCode"],"title":"Mac VSCode 基本操作","uri":"/posts/mac-vscode-basic/"},{"categories":["Mac"],"content":"编辑区定制 启用 Tab 补全：修改 \"editor.tabCompletion\" 的值为 \"on\" ","date":"2018-12-03","objectID":"/posts/mac-vscode-basic/:2:2","tags":["Mac","VSCode"],"title":"Mac VSCode 基本操作","uri":"/posts/mac-vscode-basic/"},{"categories":["Mac"],"content":"常用命令切换 切换状态栏可见性：在命令栏中搜索 View: Toggle Status Bar Visibility 回车切换 切换活动栏可见性：在命令栏中搜索 View: Toggle Activity Bar Visibility 回车切换 切换小地图：在命令栏中搜索 View: Toggle Minimap 回车切换 切换边栏位置：在命令栏中搜索 View: Toggle Side Bar Position 回车切换 切换问题（错误、警告、信息）视图：在命令栏中搜索 View: Toggle Problems 回车切换 切换输出：在命令栏中搜索 View: Toggle Output 回车切换 切换自动换行：在命令栏中搜索 View: Toggle Word Wrap 回车切换 切换开发人员工具：在命令栏中搜索 View: Toggle Developer Tools 回车切换 侧边条形图：在命令栏中搜索 View: Open Next Side Bar View 回车 关闭所有编辑器：View: Close All Editors 回车 关闭所有编辑器组：View: Close All Editor Group 回车 ","date":"2018-12-03","objectID":"/posts/mac-vscode-basic/:2:3","tags":["Mac","VSCode"],"title":"Mac VSCode 基本操作","uri":"/posts/mac-vscode-basic/"},{"categories":["Mac"],"content":"VScode 内置的快捷键之多让人瞠目结舌，作为一名卖弄风骚的 VSCoder 把常用的一些快捷键手到擒来也并非难事。相声讲究学说逗唱，编辑器自然是增删改查，加之长年吃符号的亏上字母的当硬是逼着我学会了复制粘贴大法，在此法的怂恿之下我又忍不住折腾起来，一开始没觉着，一段时间以后竟神不知鬼不觉的提高了一下码字效率，窃喜。当然这也没什么，只不过刻意练习了几个快捷键而已。 Mac VSCode 起步 Mac VSCode 基本操作 Mac VSCode 快捷键 Mac VSCode 代码片段 Mac VSCode 效率扩展 ","date":"2018-12-02","objectID":"/posts/mac-vscode-keyboard/:0:0","tags":["Mac","VSCode"],"title":"Mac VSCode 快捷键","uri":"/posts/mac-vscode-keyboard/"},{"categories":["Mac"],"content":"定制快捷键 ","date":"2018-12-02","objectID":"/posts/mac-vscode-keyboard/:1:0","tags":["Mac","VSCode"],"title":"Mac VSCode 快捷键","uri":"/posts/mac-vscode-keyboard/"},{"categories":["Mac"],"content":"修改某个动作快捷键 按 Cmd+K Cmd+S 跳转到快捷键配置页面，找到要改的命令快捷键，选中后按右键或者 Cmd+K Cmd+K 在弹出框中输入自定义的快捷键回车即可。 ","date":"2018-12-02","objectID":"/posts/mac-vscode-keyboard/:1:1","tags":["Mac","VSCode"],"title":"Mac VSCode 快捷键","uri":"/posts/mac-vscode-keyboard/"},{"categories":["Mac"],"content":"定制某个动作的快捷键 打开 keyboard.json 文件，在其中输入如下配置保存即可。 // 比如将 Cmd+D 快捷键修改为添加下一个匹配项 [ { \"key\": \"cmd+d\", \"command\": \"editor.action.addSelectionToNextFindMatch\", \"when\": \"editorFocus\" } ] ","date":"2018-12-02","objectID":"/posts/mac-vscode-keyboard/:1:2","tags":["Mac","VSCode"],"title":"Mac VSCode 快捷键","uri":"/posts/mac-vscode-keyboard/"},{"categories":["Mac"],"content":"我的快捷键 部分快捷键本人根据自己的使用习惯进行了定制。 ","date":"2018-12-02","objectID":"/posts/mac-vscode-keyboard/:2:0","tags":["Mac","VSCode"],"title":"Mac VSCode 快捷键","uri":"/posts/mac-vscode-keyboard/"},{"categories":["Mac"],"content":"Code Shortcut Key CN EN Description Cmd+, 设置 Settings Shift+Cmd+X 扩展 Cmd+K Cmd+S 键盘快捷方式 Cmd+K Cmd+M 按键映射 Cmd+K Cmd+T 颜色主题 Cmd+H 隐藏 VSCode Alt+Cmd+H 隐藏 VSCode Cmd+Q 退出 VSCode ","date":"2018-12-02","objectID":"/posts/mac-vscode-keyboard/:2:1","tags":["Mac","VSCode"],"title":"Mac VSCode 快捷键","uri":"/posts/mac-vscode-keyboard/"},{"categories":["Mac"],"content":"文件 Shortcut Key CN EN Description Cmd+N 新建文件 Cmd+Shift+N 新建窗口 Cmd+O 打开文件或文件夹 Shift+Cmd+T 重新打开已关闭的编辑文件 Cmd+S 保存 Shift+Cmd+S 另存为 Alt+Cmd+S 全部保存 Cmd+W 关闭当前窗口，没有窗口就关闭编辑器 Cmd+K F 关闭当前工程，关闭文件夹 ","date":"2018-12-02","objectID":"/posts/mac-vscode-keyboard/:2:2","tags":["Mac","VSCode"],"title":"Mac VSCode 快捷键","uri":"/posts/mac-vscode-keyboard/"},{"categories":["Mac"],"content":"编辑 Shortcut Key CN EN Description Cmd+Z 撤销 Shift+Cmd+Z 恢复 Cmd+X 剪切 Cmd+C 复制 Cmd+V 粘贴 Cmd+F 查找/替换 Shift+Cmd+F 在文件中查找 Shift+Cmd+H 在文件中替换 Cmd+/ 切换行注释 Alt+Shift+A 切换块注释 Ctrl+Cmd+Space 表情与符号 ","date":"2018-12-02","objectID":"/posts/mac-vscode-keyboard/:2:3","tags":["Mac","VSCode"],"title":"Mac VSCode 快捷键","uri":"/posts/mac-vscode-keyboard/"},{"categories":["Mac"],"content":"选择 Shortcut Key CN EN Description Cmd+A 全选 Ctrl+Shift+Cmd+➡️ 展开选定内容 Ctrl+Shift+Cmd+⬅️ 缩小选定内容 Alt+Shift+⬆️ 向上复制一行 Alt+Shift+⬇️ 向下复制一行 Alt+⬆️ 向上移动一行 Alt+⬇️ 向下移动一行 Alt+Cmd+⬆️ 在上面添加光标 Alt+Cmd+⬇️ 在下面添加光标 Cmd+D 添加下一个匹配项 Shift+Cmd+L 选择所有匹配项 ","date":"2018-12-02","objectID":"/posts/mac-vscode-keyboard/:2:4","tags":["Mac","VSCode"],"title":"Mac VSCode 快捷键","uri":"/posts/mac-vscode-keyboard/"},{"categories":["Mac"],"content":"查看 Shortcut Key CN EN Description Shift+Cmd+P 命令面板 Ctrl+Cmd+F 切换全屏 Cmd+K Z 切换 Zen 模式 Cmd+B 切换侧边栏 Cmd+J 切换面板 Cmd+= 放大 Cmd+- 缩小 Shift+Cmd+0 重置缩放 原 Cmd+NumPad0 Alt+Cmd+0 翻转布局 Shift+Cmd+E 资源管理器 Shift+Cmd+F 文件中搜索 Ctrl+Shift+G 源代码管理 Shift+Cmd+D 调试 Shift+Cmd+X 扩展 Shift+Cmd+U 输出 Shift+Cmd+M 问题 Shift+Cmd+Y 调试控制台 Ctrl+` 打开集成终端 Cmd+\\ 竖向拆分编辑器（最多 3 个） Alt+Z 切换自动换行 ","date":"2018-12-02","objectID":"/posts/mac-vscode-keyboard/:2:5","tags":["Mac","VSCode"],"title":"Mac VSCode 快捷键","uri":"/posts/mac-vscode-keyboard/"},{"categories":["Mac"],"content":"转到 Shortcut Key CN EN Description Cmd+- 后退 原 Ctrl+- Cmd+= 前进 原 Ctrl+Shift+- Alt+Cmd+➡️ 下一个编辑器 Alt+Cmd+⬅️ 上一个编辑器 Ctrl+➡️ 组中下一个使用过的编辑器 Ctrl+Shift+➡️ 组中上一个使用过的编辑器 Cmd+1 切换到第一组 Cmd+2 切换到第二组 Cmd+3 切换到第三组 Cmd+4 切换到第四组 Cmd+5 切换到第五组 Cmd+K Cmd+⬅️ 左侧组 Cmd+K Cmd+➡️ 右侧组 Cmd+K Cmd+⬆️ 上方组 Cmd+K Cmd+⬇️ 下方组 Cmd+P 转到文件 Cmd+R 转到文件中的符号 原 Shift+Cmd+O Shift+Cmd+R 转到工作区中的符号 Shift+Cmd+O 转到文件中的符号 Cmd+T 转到工作区中的符号 F12 转到定义 Cmd+F12 转到实现 Ctrl+G 转到行 ","date":"2018-12-02","objectID":"/posts/mac-vscode-keyboard/:2:6","tags":["Mac","VSCode"],"title":"Mac VSCode 快捷键","uri":"/posts/mac-vscode-keyboard/"},{"categories":["Mac"],"content":"调试 Shortcut Key CN EN Description F5 启动调试，重复按继续调试 Ctrl+F5 非调试启动 Shift+F5 停止调试 Shift+Cmd+F5 重启调试 F10 单步跳过 F11 单步执行 Shift+F11 单步跳出 F5 继续 F9 切换断点 Shift+F9 内联断点 ","date":"2018-12-02","objectID":"/posts/mac-vscode-keyboard/:2:7","tags":["Mac","VSCode"],"title":"Mac VSCode 快捷键","uri":"/posts/mac-vscode-keyboard/"},{"categories":["Mac"],"content":"终端 Shortcut Key CN EN Description Ctrl+~ 新建终端 Ctrl+\\ 拆分终端 Shift+Cmd+B 运行生成任务 ","date":"2018-12-02","objectID":"/posts/mac-vscode-keyboard/:2:8","tags":["Mac","VSCode"],"title":"Mac VSCode 快捷键","uri":"/posts/mac-vscode-keyboard/"},{"categories":["Mac"],"content":"窗口 Shortcut Key CN EN Description Cmd+M 最小化窗口 Ctrl+W 切换窗口 ","date":"2018-12-02","objectID":"/posts/mac-vscode-keyboard/:2:9","tags":["Mac","VSCode"],"title":"Mac VSCode 快捷键","uri":"/posts/mac-vscode-keyboard/"},{"categories":["Mac"],"content":"帮助 Shortcut Key CN EN Description Shift+Cmd+/ 显示帮助 ","date":"2018-12-02","objectID":"/posts/mac-vscode-keyboard/:2:10","tags":["Mac","VSCode"],"title":"Mac VSCode 快捷键","uri":"/posts/mac-vscode-keyboard/"},{"categories":["Mac"],"content":"其它 诚然，VSCode 并没有把所有的快捷键列到菜单栏中，好多快捷键自有其使用上下文，且列一下其它的快捷键。 Shortcut Key CN EN Description Ctrl+Tab 在历史打开文件之间切换 Cmd+~ 在打开的多个窗口之间切换 Cmd+[ 代码左缩进 Cmd+] 代码右缩进 Shift+Alt+F 格式化代码，或 Shift+Cmd+P 后输入 Format Document Cmd+Enter 当前行之后插入一个空行 Shift+Cmd+Enter 当前行之前插入一个空行 Cmd+⬆️ 移动光标到当前文件首行 Cmd+️⬇️ 移动光标到当前文件尾行 Cmd+⬅️ 移动光标到当前行首 Cmd+➡️ 移动光标到当前行尾 Alt+⬅️ 向左移动光标一个单词（连字） Alt+➡️ 向右移动光标一个单词（连字） Shift+Cmd+⬆️ 选中从首行到光标处的文档 Shift+Cmd+⬇️ 选中从光标到尾行处的文档 Shift+Cmd+⬅️ 选中光标处到行首 Shift+Cmd+➡️ 选中光标处到行尾 Cmd+I 选中当前行 Cmd+Delete 删除光标处到行首 Cmd+F2 光标先移动到单词上，然后按 Cmd+F2 后可以进行批量重命名 Cmd+K V Markdown 文档预览 Shift+Cmd+K 删除当前行 Shift+Cmd+\\ 在匹配的括号之前跳转 Shift+Cmd+[ 跳转到上一个编辑窗口 Shift+Cmd+] 跳转到下一个编辑窗口 Cmd+K Cmd+0 折叠所有代码 Cmd+K Cmd+1 折叠第一层代码 Cmd+K Cmd+2 折叠第二层代码 Cmd+K Cmd+3 折叠第三层代码 层数受制于代码层级 Cmd+K Cmd+[ 折叠所有代码 Cmd+K Cmd+] 展开所有代码 Cmd+K Cmd+C 添加当前行代码注释 Cmd+K Cmd+U 取消当前行代码注释 Cmd+/ 当前行注释切换 Alt+Shift+I 在所选行的行尾插入光标 Shift+Cmd+L 选中所有与当前选中内容相同的部分 Alt+Shift+光标拖动 选中代码块 Cmd+G 查找下一个 Shift+Cmd+G 查找下一个 ","date":"2018-12-02","objectID":"/posts/mac-vscode-keyboard/:2:11","tags":["Mac","VSCode"],"title":"Mac VSCode 快捷键","uri":"/posts/mac-vscode-keyboard/"},{"categories":["Mac"],"content":"快捷键定制 // 将按键绑定配置放入此文件中即可覆盖默认值 [ { \"key\": \"alt+cmd+up\", // 向上插入多个光标 \"command\": \"editor.action.insertCursorAbove\", \"when\": \"editorTextFocus\" }, { \"key\": \"alt+cmd+down\", // 向下插入多个光标 \"command\": \"editor.action.insertCursorBelow\", \"when\": \"editorTextFocus\" }, { \"key\": \"cmd+d\", // 添加下一个匹配项 \"command\": \"editor.action.addSelectionToNextFindMatch\", \"when\": \"editorFocus\" }, { \"key\": \"shift+cmd+0\", // 重置缩放 \"command\": \"workbench.action.zoomReset\" }, { \"key\": \"cmd+-\", // 后退 \"command\": \"workbench.action.navigateBack\" }, { \"key\": \"cmd+=\", // 前进 \"command\": \"workbench.action.navigateForward\" }, { \"key\": \"cmd+r\", // 符号跳转 \"command\": \"workbench.action.gotoSymbol\" }, { \"key\": \"cmd+space\", // 触发建义提示 \"command\": \"editor.action.triggerSuggest\", \"when\": \"editorHasCompletionItemProvider \u0026\u0026 textInputFocus \u0026\u0026 !editorReadonly\" }, { \"key\": \"shift+cmd+space\", // 触发参数提示 \"command\": \"editor.action.triggerParameterHints\", \"when\": \"editorHasSignatureHelpProvider \u0026\u0026 editorTextFocus\" }, { \"key\": \"alt+enter\", // 打开右键菜单 \"command\": \"editor.action.showContextMenu\", \"when\": \"textInputFocus\" }, { \"key\": \"shift+;\", // ZenMode 显示命令提示框 \"command\": \"vim.showQuickpickCmdLine\", \"when\": \"inZenMode \u0026\u0026 vim.mode != 'Insert'\" }, { \"key\": \"ctrl+j\", // 合并到一行 \"command\": \"editor.action.joinLines\", \"when\": \"editorTextFocus \u0026\u0026 !editorReadonly\" }, { \"key\": \"ctrl+t\", // 调换字符位置 \"command\": \"editor.action.transposeLetters\", \"when\": \"textInputFocus \u0026\u0026 !editorReadonly\" }, { \"key\": \"shift+cmd+space\", // 触发参数提示信息 \"command\": \"editor.action.triggerParameterHints\", \"when\": \"editorHasSignatureHelpProvider \u0026\u0026 editorTextFocus\" }, { \"key\": \"ctrl+alt+i\", // 导入类的命名空间 \"command\": \"namespaceResolver.import\", \"when\": \"editorTextFocus\" }, { \"key\": \"ctrl+alt+e\", // 展开类的命名空间 \"command\": \"namespaceResolver.expand\", \"when\": \"editorTextFocus\" }, { \"key\": \"ctrl+alt+s\", // 命名空间排序 \"command\": \"namespaceResolver.sort\", \"when\": \"editorTextFocus\" } ] ","date":"2018-12-02","objectID":"/posts/mac-vscode-keyboard/:2:12","tags":["Mac","VSCode"],"title":"Mac VSCode 快捷键","uri":"/posts/mac-vscode-keyboard/"},{"categories":["Mac"],"content":"编辑器的集大成者，免费，高颜值。轻量级的跨平台 Web 集成开发环境，比 Sublime 开源，比 Atom 更快，比 JetBrains 全家桶更轻，就冲微软的这个情怀，我特么果断入坑。当然熟练使用一款代码编辑器并不是什么了不起的技能，但请别忘了『工欲善其事，必先利其器』，其不闻人之能在于善假于物也。选择适合自己的代码编辑器一直是有追求的码农的生活方式，不知何故，每每看到那些惊艳的主题、敲击一个字符恨不得把整个世界给你的编辑器亦或 IDE，我就格外的喜悦，果然懂码农者唯编辑器尔（编程语言当然也不例外）。历尽一番折腾后，VSCode 那风骚的操作令人欲罢不能，为了能系统地学习下这些操作，记录下这些操作指令，我觉得需要记录点什么。 Mac VSCode 起步 Mac VSCode 基本操作 Mac VSCode 快捷键 Mac VSCode 代码片段 Mac VSCode 效率扩展 ","date":"2018-12-01","objectID":"/posts/mac-vscode-started/:0:0","tags":["Mac","VSCode"],"title":"Mac VSCode 起步","uri":"/posts/mac-vscode-started/"},{"categories":["Mac"],"content":"概述 ","date":"2018-12-01","objectID":"/posts/mac-vscode-started/:1:0","tags":["Mac","VSCode"],"title":"Mac VSCode 起步","uri":"/posts/mac-vscode-started/"},{"categories":["Mac"],"content":"简介 Code editing. Redefined. Free. Open source. Runs everywhere. ","date":"2018-12-01","objectID":"/posts/mac-vscode-started/:1:1","tags":["Mac","VSCode"],"title":"Mac VSCode 起步","uri":"/posts/mac-vscode-started/"},{"categories":["Mac"],"content":"安装 VSCode Website VSCode GitHub VSCode Videos VSCode Documentation 没什么好说的，直接上官网下载对应系统安装包，开箱即用。 ","date":"2018-12-01","objectID":"/posts/mac-vscode-started/:1:2","tags":["Mac","VSCode"],"title":"Mac VSCode 起步","uri":"/posts/mac-vscode-started/"},{"categories":["Mac"],"content":"插件 Extensions for the Visual Studio family of products 果然还是得插件者得天下，庞大的插件足以让 VSCode 傲视群雄。 ","date":"2018-12-01","objectID":"/posts/mac-vscode-started/:1:3","tags":["Mac","VSCode"],"title":"Mac VSCode 起步","uri":"/posts/mac-vscode-started/"},{"categories":["Mac"],"content":"界面 ","date":"2018-12-01","objectID":"/posts/mac-vscode-started/:2:0","tags":["Mac","VSCode"],"title":"Mac VSCode 起步","uri":"/posts/mac-vscode-started/"},{"categories":["Mac"],"content":"命令面板 按 Shift+Cmd+P 进入命令面板，调用各种命令。 快捷入口 - Cmd+P。 以下快捷键为默认快捷键。 直接输入文件名，快速打开文件 显示最近打开过的文件 重复按下后在最近打开过的文件之间切换 键入 ? 查看相关帮助，列出当前可执行的动作 键入 ! 显示 Errors 或 Warnings，也可以 Ctrl+Shift+M 键入 : 跳转到行数，也可以 Ctrl+G 直接进入 键入 @ 跳转到 symbol（搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入 键入 @: 根据分类跳转 symbol（查找属性或函数），也可以 Ctrl+Shift+O 后输入 : 进入 键入 # 根据名字查找 symbol，也可以 Ctrl+T ","date":"2018-12-01","objectID":"/posts/mac-vscode-started/:2:1","tags":["Mac","VSCode"],"title":"Mac VSCode 起步","uri":"/posts/mac-vscode-started/"},{"categories":["Mac"],"content":"界面概览 点击『学习』下面的『界面概览』。 ","date":"2018-12-01","objectID":"/posts/mac-vscode-started/:2:2","tags":["Mac","VSCode"],"title":"Mac VSCode 起步","uri":"/posts/mac-vscode-started/"},{"categories":["Mac"],"content":"交互式演练场 点击『学习』下面的『交互式演练场』。 ","date":"2018-12-01","objectID":"/posts/mac-vscode-started/:2:3","tags":["Mac","VSCode"],"title":"Mac VSCode 起步","uri":"/posts/mac-vscode-started/"},{"categories":["Mac"],"content":"命令行 ","date":"2018-12-01","objectID":"/posts/mac-vscode-started/:3:0","tags":["Mac","VSCode"],"title":"Mac VSCode 起步","uri":"/posts/mac-vscode-started/"},{"categories":["Mac"],"content":"命令行命令安装 安装 VSCode Shell 命令，按 Shift+Cmd+P 搜索 shell command install 回车即可。 ","date":"2018-12-01","objectID":"/posts/mac-vscode-started/:3:1","tags":["Mac","VSCode"],"title":"Mac VSCode 起步","uri":"/posts/mac-vscode-started/"},{"categories":["Mac"],"content":"命令行帮助 code --help Visual Studio Code 1.30.0 Usage: code [options] [paths...] To read from stdin, append '-' (e.g. 'ps aux | grep code | code -') Options: -d, --diff \u003cfile\u003e \u003cfile\u003e Compare two files with each other. -a, --add \u003cdir\u003e Add folder(s) to the last active window. -g, --goto \u003cfile:line[:character]\u003e Open a file at the path on the specified line and character position. -n, --new-window Force to open a new window. -r, --reuse-window Force to open a file or folder in an already opened window. -w, --wait Wait for the files to be closed before returning. --locale \u003clocale\u003e The locale to use (e.g. en-US or zh-TW). --user-data-dir \u003cdir\u003e Specifies the directory that user data is kept in. Can be used to open multiple distinct instances of Code. -v, --version Print version. -h, --help Print usage. Extensions Management: --extensions-dir \u003cdir\u003e Set the root path for extensions. --list-extensions List the installed extensions. --show-versions Show versions of installed extensions, when using --list-extension. --uninstall-extension (\u003cextension-id\u003e | \u003cextension-vsix-path\u003e) Uninstalls an extension. --install-extension (\u003cextension-id\u003e | \u003cextension-vsix-path\u003e) Installs or updates the extension. Use `--force` argument to avoid prompts. --enable-proposed-api (\u003cextension-id\u003e) Enables proposed API features for extensions. Can receive one or more extension IDs to enable individually. Troubleshooting: --verbose Print verbose output (implies --wait). --log \u003clevel\u003e Log level to use. Default is 'info'. Allowed values are 'critical', 'error', 'warn', 'info', 'debug', 'trace', 'off'. -s, --status Print process usage and diagnostics information. -p, --performance Start with the 'Developer: Startup Performance' command enabled. --prof-startup Run CPU profiler during startup --disable-extensions Disable all installed extensions. --disable-extension \u003cextension-id\u003e Disable an extension. --inspect-extensions Allow debugging and profiling of extensions. Check the developer tools for the connection URI. --inspect-brk-extensions Allow debugging and profiling of extensions with the extension host being paused after start. Check the developer tools for the connection URI. --disable-gpu Disable GPU hardware acceleration. --upload-logs Uploads logs from current session to a secure endpoint. --max-memory Max memory size for a window (in Mbytes). ","date":"2018-12-01","objectID":"/posts/mac-vscode-started/:3:2","tags":["Mac","VSCode"],"title":"Mac VSCode 起步","uri":"/posts/mac-vscode-started/"},{"categories":["Mac"],"content":"常用命令 // 在 VSCode 中打开当前目录 code . // 在最近使用过的 VSCode 窗口打开当前目录 code -r . // 创建新的窗口 code -n code --new-window // 更改语言 code --locale=es // 跳转到指定文件的指定行列，相当于跳转到指定文件的指定行的从左到右第几个字符上 code -g /path/to/\u003cfile\u003e:10:10 code --goto /path/to/\u003cfile\u003e:10:20 // 打开 diff 编辑器比较文件 code -d \u003cfile1\u003e \u003cfile2\u003e code --diff \u003cfile1\u003e \u003cfile2\u003e // 查看帮助选项 code --help // 禁用所有扩展 code --disable-extensions ","date":"2018-12-01","objectID":"/posts/mac-vscode-started/:3:3","tags":["Mac","VSCode"],"title":"Mac VSCode 起步","uri":"/posts/mac-vscode-started/"},{"categories":["Mac"],"content":"字体 以下字体安装其一就好，安装完成重启 VSCode 即可。 Cascadia Code 字体 Github 到 Releases 标签页下载 Cascadia Code 压缩包解压并安装 按 Cmd+, 搜索并配置 editor.fontFamily 和 editor.fontLigatures 即可： \"editor.fontFamily\": \"Cascadia Code\", \"editor.fontLigatures\": true, Fire Code 字体 GitHub FiraCode Wiki VS Code Instructions brew tap homebrew/cask-fonts brew cask install font-fira-code 按 Cmd+, 搜索并配置 editor.fontFamily 和 editor.fontLigatures 即可： \"editor.fontFamily\": \"Fira Code\", \"editor.fontLigatures\": true, ","date":"2018-12-01","objectID":"/posts/mac-vscode-started/:3:4","tags":["Mac","VSCode"],"title":"Mac VSCode 起步","uri":"/posts/mac-vscode-started/"},{"categories":["Mac"],"content":"问题 Could not create temporary directory: 权限被拒绝： sudo chown $USER ~/Library/Caches/com.microsoft.VSCode.ShipIt/ ","date":"2018-12-01","objectID":"/posts/mac-vscode-started/:4:0","tags":["Mac","VSCode"],"title":"Mac VSCode 起步","uri":"/posts/mac-vscode-started/"},{"categories":["PHP"],"content":"这是一道妥妥的字符串操作题呀，源于某道面试题，玩一玩，开心就好。 ","date":"2018-09-05","objectID":"/posts/php-get-file-extension/:0:0","tags":["PHP"],"title":"PHP 从路径中获取文件的扩展名","uri":"/posts/php-get-file-extension/"},{"categories":["PHP"],"content":"使用 pathinfo 函数 \u003c?php /** * 从路径中获取文件的扩展名。 * * @param string $path * * @return string */ function ext_name(string $path): string { return pathinfo($path, PATHINFO_EXTENSION); } 或者 \u003c?php /** * 从路径中获取文件的扩展名。 * * @param string $path * * @return string */ function ext_name(string $path): string { return pathinfo($path)['extension']; } ","date":"2018-09-05","objectID":"/posts/php-get-file-extension/:1:0","tags":["PHP"],"title":"PHP 从路径中获取文件的扩展名","uri":"/posts/php-get-file-extension/"},{"categories":["PHP"],"content":"使用 preg_split 函数 \u003c?php /** * 从路径中获取文件的扩展名。 * * @param string $path * * @return string */ function ext_name(string $path): string { $array = preg_split('/[\\\\.]/', $path); return $array[count($array) - 1]; } ","date":"2018-09-05","objectID":"/posts/php-get-file-extension/:2:0","tags":["PHP"],"title":"PHP 从路径中获取文件的扩展名","uri":"/posts/php-get-file-extension/"},{"categories":["PHP"],"content":"使用 end 函数 \u003c?php /** * 从路径中获取文件的扩展名。 * * @param string $path * * @return string */ function ext_name(string $path): string { $array = explode('.', $path); return end($array); } ","date":"2018-09-05","objectID":"/posts/php-get-file-extension/:3:0","tags":["PHP"],"title":"PHP 从路径中获取文件的扩展名","uri":"/posts/php-get-file-extension/"},{"categories":["PHP"],"content":"使用 strrchr 函数 \u003c?php /** * 从路径中获取文件的扩展名。 * * @param string $path * * @return string */ function ext_name(string $path): string { return substr(strrchr($path, '.'), 1); } ","date":"2018-09-05","objectID":"/posts/php-get-file-extension/:4:0","tags":["PHP"],"title":"PHP 从路径中获取文件的扩展名","uri":"/posts/php-get-file-extension/"},{"categories":["PHP"],"content":"使用 strrpos 函数 \u003c?php /** * 从路径中获取文件的扩展名。 * * @param string $path * * @return string */ function ext_name(string $path): string { return substr($path, strrpos($path, '.') + 1); } ","date":"2018-09-05","objectID":"/posts/php-get-file-extension/:5:0","tags":["PHP"],"title":"PHP 从路径中获取文件的扩展名","uri":"/posts/php-get-file-extension/"},{"categories":["PHP"],"content":"使用 preg_replace 函数 \u003c?php /** * 从路径中获取文件的扩展名。 * * @param string $path * * @return string */ function ext_name(string $path): string { return preg_replace('/^.*\\.([^.]+)$/D', \"$1\", $path); } ","date":"2018-09-05","objectID":"/posts/php-get-file-extension/:6:0","tags":["PHP"],"title":"PHP 从路径中获取文件的扩展名","uri":"/posts/php-get-file-extension/"},{"categories":["PHP"],"content":"使用 SplFileInfo 类 \u003c?php /** * 从路径中获取文件的扩展名。 * * @param string $path * * @return string */ function ext_name(string $path): string { return (new \\SplFileInfo($path))-\u003egetExtension(); } 函数调用： \u003c?php echo ext_name($_SERVER['PHP_SELF']); 输出结果： php ","date":"2018-09-05","objectID":"/posts/php-get-file-extension/:7:0","tags":["PHP"],"title":"PHP 从路径中获取文件的扩展名","uri":"/posts/php-get-file-extension/"},{"categories":["PHP"],"content":"主要归功于递归 - Recursion，又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。递归一词还较常用于描述以自相似方法重复事物的过程。例如，当两面镜子相互之间近似平行时，镜中嵌套的图像是以无限递归的形式出现的。也可以理解为自我复制的过程。 ","date":"2018-09-05","objectID":"/posts/php-traversing-directory-files/:0:0","tags":["PHP"],"title":"PHP 遍历目录下的文件","uri":"/posts/php-traversing-directory-files/"},{"categories":["PHP"],"content":"使用 dir 函数 \u003c?php /** * 遍历指定文件夹下的文件。 * * @param string $directory * * @return array */ function dir_list($directory) { static $array = []; $dir = dir($directory); while ($file = $dir-\u003eread()) { if (is_dir(\"$directory/$file\") \u0026\u0026 $file !== '.' \u0026\u0026 $file !== '..') { dir_list(\"$directory/$file\"); } else { if ($file !== '.' \u0026\u0026 $file !== '..') { $array[] = $file; } } } return $array; } ","date":"2018-09-05","objectID":"/posts/php-traversing-directory-files/:1:0","tags":["PHP"],"title":"PHP 遍历目录下的文件","uri":"/posts/php-traversing-directory-files/"},{"categories":["PHP"],"content":"使用 readdir 函数 \u003c?php /** * 遍历指定文件夹下的文件。 * * @param string $directory * * @return array */ function dir_list(string $directory): array { static $array = []; if ($dir = opendir($directory)) { while (false !== $file = readdir($dir)) { if (is_dir(\"$directory/$file\") \u0026\u0026 $file !== '.' \u0026\u0026 $file !== '..') { dir_list(\"$directory/$file\"); } else { if ($file !== '.' \u0026\u0026 $file !== '..') { $array[] = $file; } } } closedir($dir); } return $array; } ","date":"2018-09-05","objectID":"/posts/php-traversing-directory-files/:2:0","tags":["PHP"],"title":"PHP 遍历目录下的文件","uri":"/posts/php-traversing-directory-files/"},{"categories":["PHP"],"content":"使用 scandir 函数 \u003c?php /** * 遍历指定文件夹下的文件。 * * @param string $directory * * @return array */ function dir_list(string $directory): array { static $array = []; $dir = scandir($directory); foreach ($dir as $file) { if (is_dir(\"$directory/$file\") \u0026\u0026 $file !== '.' \u0026\u0026 $file !== '..') { dir_list(\"$directory/$file\"); } else { if ($file !== '.' \u0026\u0026 $file !== '..') { $array[] = $file; } } } return $array; } ","date":"2018-09-05","objectID":"/posts/php-traversing-directory-files/:3:0","tags":["PHP"],"title":"PHP 遍历目录下的文件","uri":"/posts/php-traversing-directory-files/"},{"categories":["PHP"],"content":"使用 RecursiveIteratorIterator 类 \u003c?php function dir_list(string $directory): array { static $array = []; $iterator = new \\RecursiveIteratorIterator( new \\RecursiveDirectoryIterator($directory, \\RecursiveDirectoryIterator::SKIP_DOTS), \\RecursiveIteratorIterator::LEAVES_ONLY ); foreach ($iterator as $object) { $array[] = $object-\u003egetFileName(); } return $array; } 函数调用： \u003c?php print_r(dir_list(dirname($_SERVER['PHP_SELF']))); 输出结果： Array ( [0] =\u003e myshell.sh [1] =\u003e meeting.md [2] =\u003e untitled.html [3] =\u003e server.php [4] =\u003e .DS_Store [5] =\u003e index.php [6] =\u003e desc.md . . . ) ","date":"2018-09-05","objectID":"/posts/php-traversing-directory-files/:4:0","tags":["PHP"],"title":"PHP 遍历目录下的文件","uri":"/posts/php-traversing-directory-files/"},{"categories":["PHP"],"content":"通常情况下，我们发送 HTTP 请求采用 PHP 封装的 cURL 扩展函数来实现。 ","date":"2018-06-21","objectID":"/posts/php-send-http-request/:0:0","tags":["PHP"],"title":"PHP 中发送 HTTP 请求的方式","uri":"/posts/php-send-http-request/"},{"categories":["PHP"],"content":"cURL 方式 ","date":"2018-06-21","objectID":"/posts/php-send-http-request/:1:0","tags":["PHP"],"title":"PHP 中发送 HTTP 请求的方式","uri":"/posts/php-send-http-request/"},{"categories":["PHP"],"content":"扩展函数实现 \u003c?php // 初始化一个 cURL 资源对象。 $curl = curl_init(); $options = [ // True 将 curl_exec() 获取的信息以字符串返回，而不是直接输出。 CURLOPT_RETURNTRANSFER =\u003e true, // 禁用时不会将头文件的信息作为数据流输出。 CURLOPT_HEADER =\u003e false, // True 时将会根据服务器返回 HTTP 头中的 \"Location: \" 重定向。 CURLOPT_FOLLOWLOCATION =\u003e true, // 如果为空字符串 \"\"，会发送所有支持的编码类型。 CURLOPT_ENCODING =\u003e '', // 在 HTTP 请求中包含一个 \"User-Agent: \" 头的字符串。 CURLOPT_USERAGENT =\u003e 'spider', // True 时将根据 Location: 重定向时，自动设置 Header 中的 Referer: 信息。 CURLOPT_AUTOREFERER =\u003e true, // 在尝试连接时等待的秒数。设置为 0，则无限等待。 CURLOPT_CONNECTTIMEOUT =\u003e 120, // 允许 cURL 函数执行的最长秒数。 CURLOPT_TIMEOUT =\u003e 120, // 指定最多的 HTTP 重定向次数，这个选项是和 CURLOPT_FOLLOWLOCATION 一起使用的。 CURLOPT_MAXREDIRS =\u003e 10, // 全部数据使用 HTTP 协议中的 \"POST\" 操作来发送。 CURLOPT_POSTFIELDS =\u003e 'phone=your-phone\u0026password=your-password', // True 时会发送 POST 请求，类型为：application/x-www-form-urlencoded，是 HTML 表单提交时最常见的一种。 CURLOPT_POST =\u003e true, // 启用 cURL 验证对等证书。 CURLOPT_SSL_VERIFYPEER =\u003e true, // 不检查服务器 SSL 证书中的公用名。 CURLOPT_SSL_VERIFYHOST =\u003e 0, // False 禁止 cURL 验证对等证书。 CURLOPT_SSL_VERIFYPEER =\u003e false, // True 会输出所有的信息，写入到 STDERR，或在 CURLOPT_STDERR 中指定的文件。 CURLOPT_VERBOSE =\u003e true, // 设置你需要抓取的 URL。 CURLOPT_URL =\u003e 'http://www.example.com/users/login', ]; // 设置多个 cURL 传输选项。 curl_setopt_array($curl, $options); // 运行 cURL，请求网页。 $content = curl_exec($curl); $response = [ 'errno' =\u003e curl_errno($curl), 'errmsg' =\u003e curl_error($curl), 'header' =\u003e curl_getinfo($curl), 'content' =\u003e $content, ]; // 关闭 cURL 请求。 curl_close($curl); print_r($response); // 结果 * Trying 101.201.xxx.xxx... * TCP_NODELAY set * Connected to www.example.com (101.201.xxx.xxx) port 80 (#0) \u003e POST /users/login HTTP/1.1 Host: www.example.com User-Agent: spider Accept: */* Accept-Encoding: deflate, gzip Content-Length: 41 Content-Type: application/x-www-form-urlencoded * upload completely sent off: 41 out of 41 bytes array(26) { [\"url\"]=\u003e string(37) \"http://www.example.com/users/login\" [\"content_type\"]=\u003e string(24) \"text/html; charset=UTF-8\" [\"http_code\"]=\u003e int(200) [\"header_size\"]=\u003e int(463) [\"request_size\"]=\u003e int(231) [\"filetime\"]=\u003e int(-1) [\"ssl_verify_result\"]=\u003e int(0) [\"redirect_count\"]=\u003e int(0) [\"total_time\"]=\u003e float(0.224392) [\"namelookup_time\"]=\u003e float(0.015103) [\"connect_time\"]=\u003e float(0.030847) [\"pretransfer_time\"]=\u003e float(0.03103) [\"size_upload\"]=\u003e float(41) [\"size_download\"]=\u003e float(98) [\"speed_download\"]=\u003e float(436) [\"speed_upload\"]=\u003e float(182) [\"download_content_length\"]=\u003e float(-1) [\"upload_content_length\"]=\u003e float(41) [\"starttransfer_time\"]=\u003e float(0.224266) [\"redirect_time\"]=\u003e float(0) [\"redirect_url\"]=\u003e string(0) \"\" [\"primary_ip\"]=\u003e string(15) \"101.201.xxx.xxx\" [\"certinfo\"]=\u003e array(0) { } [\"primary_port\"]=\u003e int(80) [\"local_ip\"]=\u003e string(14) \"192.168.xxx.xxx\" [\"local_port\"]=\u003e int(52637) } \u003c HTTP/1.1 200 OK \u003c Server: nginx \u003c Date: Fri, 22 Jun 2018 01:43:45 GMT \u003c Content-Type: text/html; charset=UTF-8 \u003c Transfer-Encoding: chunked \u003c Connection: keep-alive \u003c Vary: Accept-Encoding \u003c Set-Cookie: SESSID=pau0p79qdallgaee2kcj963n16; expires=Fri, 22-Jun-2018 02:13:45 GMT; Max-Age=1800; path=/; HttpOnly \u003c Expires: Thu, 19 Nov 1981 08:52:00 GMT \u003c Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0 \u003c Pragma: no-cache \u003c Content-Encoding: gzip \u003c * Connection #0 to host www.example.com left intact Process finished with exit code 0 ","date":"2018-06-21","objectID":"/posts/php-send-http-request/:1:1","tags":["PHP"],"title":"PHP 中发送 HTTP 请求的方式","uri":"/posts/php-send-http-request/"},{"categories":["PHP"],"content":"扩展包实现 Guzzle GitHub Guzzle Documentation 这里推荐使用 Guzzle 扩展包，诚实的说，也没有理由不使用它。Guzzle 是一个 PHP HTTP 客户端，可以轻松发送 HTTP 请求，并且可以轻松集成 Web服务。 特性 用于构建查询字符串，POST 请求，流式传输大型上传，流式传输大型下载，使用 HTTP cookie，上传 JSON 数据等的简单接口，等等…… 可以使用相同的接口发送同步和异步请求。 为请求，响应和流选择 PSR-7 接口。 这使您可以与 Guzzle 一起使用其他 PSR-7 兼容库。 抽象出底层的 HTTP 传输，允许您编写环境和传输不可知的代码; 即不依赖于 cURL，PHP 流，套接字或非阻塞事件循环。 中间件系统允许您增强和组合客户端行为。 安装 $ composer require guzzlehttp/guzzle 请求 \u003c?php require '../vendor/autoload.php'; try { $client = new \\GuzzleHttp\\Client(); $request = $client-\u003erequest('GET', 'https://api.github.com/repos/guzzle/guzzle'); } catch (\\GuzzleHttp\\Exception\\GuzzleException $e) { echo $e-\u003egetMessage(); } $response = [ 'status_code' =\u003e $request-\u003egetStatusCode(), 'content_type' =\u003e $request-\u003egetHeaderLine('content-type'), 'body' =\u003e $request-\u003egetBody(), ]; print_r($response); // 发送一个异步请求。 $request = new \\GuzzleHttp\\Psr7\\Request('GET', 'https://www.baidu.com'); $promise = $client-\u003esendAsync($request)-\u003ethen(function ($response) { echo PHP_EOL, 'I completed! ', PHP_EOL, $response-\u003egetBody(); }); $promise-\u003ewait(); // 结果 Array ( [status_code] =\u003e 200 [content_type] =\u003e application/json; charset=utf-8 [body] =\u003e GuzzleHttp\\Psr7\\Stream Object ( [stream:GuzzleHttp\\Psr7\\Stream:private] =\u003e Resource id #42 [size:GuzzleHttp\\Psr7\\Stream:private] =\u003e [seekable:GuzzleHttp\\Psr7\\Stream:private] =\u003e 1 [readable:GuzzleHttp\\Psr7\\Stream:private] =\u003e 1 [writable:GuzzleHttp\\Psr7\\Stream:private] =\u003e 1 [uri:GuzzleHttp\\Psr7\\Stream:private] =\u003e php://temp [customMetadata:GuzzleHttp\\Psr7\\Stream:private] =\u003e Array ( ) ) ) I completed! \u003chtml\u003e \u003chead\u003e \u003cscript\u003e location.replace(location.href.replace(\"https://\",\"http://\")); \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cnoscript\u003e\u003cmeta http-equiv=\"refresh\" content=\"0;url=http://www.baidu.com/\"\u003e\u003c/noscript\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2018-06-21","objectID":"/posts/php-send-http-request/:1:2","tags":["PHP"],"title":"PHP 中发送 HTTP 请求的方式","uri":"/posts/php-send-http-request/"},{"categories":["PHP"],"content":"Stream 方式 Stream 的概述与使用详解 ","date":"2018-06-21","objectID":"/posts/php-send-http-request/:2:0","tags":["PHP"],"title":"PHP 中发送 HTTP 请求的方式","uri":"/posts/php-send-http-request/"},{"categories":["PHP"],"content":"PHP 内置的 Stream 包装类 获取已注册的套接字传输协议列表 \u003c?php print_r(stream_get_transports()); // 结果 Array ( [0] =\u003e tcp [1] =\u003e udp [2] =\u003e unix [3] =\u003e udg [4] =\u003e ssl [5] =\u003e tls [6] =\u003e tlsv1.0 [7] =\u003e tlsv1.1 [8] =\u003e tlsv1.2 ) 获取已注册的流类型 \u003c?php print_r(stream_get_wrappers()); // 结果 Array ( [0] =\u003e https [1] =\u003e ftps [2] =\u003e compress.zlib [3] =\u003e compress.bzip2 [4] =\u003e php [5] =\u003e file [6] =\u003e glob [7] =\u003e data [8] =\u003e http [9] =\u003e ftp [10] =\u003e phar [11] =\u003e zip ) 获取已注册的数据流过滤器列表 \u003c?php print_r(stream_get_filters()); // 结果 Array ( [0] =\u003e zlib.* [1] =\u003e bzip2.* [2] =\u003e convert.iconv.* [3] =\u003e string.rot13 [4] =\u003e string.toupper [5] =\u003e string.tolower [6] =\u003e string.strip_tags [7] =\u003e convert.* [8] =\u003e consumed [9] =\u003e dechunk ) ","date":"2018-06-21","objectID":"/posts/php-send-http-request/:2:1","tags":["PHP"],"title":"PHP 中发送 HTTP 请求的方式","uri":"/posts/php-send-http-request/"},{"categories":["PHP"],"content":"流上下文 \u003c?php $data = ['phone' =\u003e 'your-phone', 'password' =\u003e 'your-password', 'sign' =\u003e 'your-sign']; $data = http_build_query($data); $options = [ 'http' =\u003e [ 'method' =\u003e 'POST', 'header' =\u003e 'Content-type: application/x-www-form-urlencoded\\r\\nContent-length:' . mb_strlen($data) . \"\\r\\n\", 'content' =\u003e $data, ], ]; $context = stream_context_create($options); $result = file_get_contents('http://www.example.com/users/login', false, $context); $result = json_decode($result, true); print_r($result); // 结果 Array ( [status] =\u003e [msg] =\u003e 账号不存在或被禁用 [data] =\u003e Array ( ) ) ","date":"2018-06-21","objectID":"/posts/php-send-http-request/:2:2","tags":["PHP"],"title":"PHP 中发送 HTTP 请求的方式","uri":"/posts/php-send-http-request/"},{"categories":["PHP"],"content":"流过滤器 $ touch test.txt $ vim test.txt HELLO WORLD THIS IS A TEST \u003c?php $handle = fopen('./test.txt', 'rb'); stream_filter_append($handle, 'string.tolower'); while (feof($handle) !== true) { echo fgets($handle); } fclose($handle); // 结果 hello world this is a test ","date":"2018-06-21","objectID":"/posts/php-send-http-request/:2:3","tags":["PHP"],"title":"PHP 中发送 HTTP 请求的方式","uri":"/posts/php-send-http-request/"},{"categories":["PHP"],"content":"Socket 方式 ","date":"2018-06-21","objectID":"/posts/php-send-http-request/:3:0","tags":["PHP"],"title":"PHP 中发送 HTTP 请求的方式","uri":"/posts/php-send-http-request/"},{"categories":["PHP"],"content":"简单请求 \u003c?php $fp = fsockopen('www.baidu.com', 80, $errno, $errstr); if (! $fp) { echo \"$errstr ($errno)\u003cbr /\u003e\\n\"; } else { $out = \"GET / HTTP/1.1\\r\\n\"; $out .= \"Host: www.baidu.com\\r\\n\"; $out .= \"Connection: Close\\r\\n\\r\\n\"; fwrite($fp, $out); while (! feof($fp)) { echo fgets($fp, 128); } fclose($fp); } // 结果 HTTP/1.1 200 OK Accept-Ranges: bytes Cache-Control: no-cache Content-Length: 14615 Content-Type: text/html Date: Fri, 22 Jun 2018 03:07:09 GMT Last-Modified: Mon, 11 Jun 2018 11:19:00 GMT P3p: CP=\" OTI DSP COR IVA OUR IND COM \" Pragma: no-cache Server: BWS/1.1 Set-Cookie: BAIDUID=CB118091B64A7DB3972039E431BB631D:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com Set-Cookie: BIDUPSID=CB118091B64A7DB3972039E431BB631D; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com Set-Cookie: PSTM=1529636829; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com Vary: Accept-Encoding X-Ua-Compatible: IE=Edge,chrome=1 Connection: close \u003c!DOCTYPE html\u003e\u003c!--STATUS OK--\u003e \u003chtml\u003e \u003chead\u003e...\u003c/head\u003e \u003cbody\u003e...\u003c/body\u003e \u003c/html\u003e ","date":"2018-06-21","objectID":"/posts/php-send-http-request/:3:1","tags":["PHP"],"title":"PHP 中发送 HTTP 请求的方式","uri":"/posts/php-send-http-request/"},{"categories":["PHP"],"content":"简单通信 创建 TCP Socket 服务器 \u003c?php error_reporting(E_ALL); set_time_limit(0); ob_implicit_flush(); $host = '127.0.0.1'; $port = 9004; // 创建一个 TCP Socket。 $socket = socket_create( AF_INET, SOCK_STREAM, SOL_TCP ) or die('socket_create() failed: ' . socket_strerror(socket_last_error())); // 在套接字资源上设置阻塞模式。 socket_set_block($socket) or die('socket_set_block() failed: ' . socket_strerror(socket_last_error($socket))); // 给套接字绑定名字。 socket_bind($socket, $host, $port) or die('socket_bind() failed: ' . socket_strerror(socket_last_error($socket))); // 侦听套接字上的连接。 socket_listen($socket, 5) or die('socket_listen() failed: ' . socket_strerror(socket_last_error($socket))); echo \"Listening the socket on $host:$port ... \", PHP_EOL; $clientId = 0; while (true) { if (($client = socket_accept($socket)) \u003c 0) { echo 'socket_accept() failed: ' . socket_strerror(socket_last_error($client)); break; } $clientId++; echo 'Client #' . $clientId . ': Connect', PHP_EOL; $welcome = \"\\nWelcome to the PHP Socket Server. \\n\" . \"To quit client type 'quit'. To shut down the server type 'shutdown'.\\n\"; socket_write($client, $welcome, strlen($welcome)); $curBuf = ''; while (true) { if (false === ($buf = socket_read($client, 2048))) { echo 'socket_read() failed: ' . socket_strerror(socket_last_error($client)) . PHP_EOL; break 2; } if ($buf === \"\\r\\n\") { if ($curBuf === \"quit\\r\\n\") { echo 'Client #' . $clientId . ': Disconnect', PHP_EOL; break; } elseif ($curBuf === \"shutdown\\r\\n\") { echo 'Client #' . $clientId . ': Shutdown server', PHP_EOL; socket_close($client); break 2; } else { $buffer = 'Output: ' . ucwords(str_replace(\"\\r\\n\", ' ', $curBuf)) . PHP_EOL; socket_write($client, $buffer, strlen($buffer)); } echo 'Client #' . $clientId . ': ' . $curBuf . PHP_EOL; $curBuf = ''; } else { $curBuf .= $buf; } } socket_close($client); } socket_close($socket); 运行： $ php server.php // 重启一个终端窗口，安装 telnet $ brew install telnet // 使用 telnet 进行测试 $ telnet 127.0.0.1 9004 ","date":"2018-06-21","objectID":"/posts/php-send-http-request/:3:2","tags":["PHP"],"title":"PHP 中发送 HTTP 请求的方式","uri":"/posts/php-send-http-request/"},{"categories":["PHP"],"content":"在最近的学习中，不断听到看到函数式编程，据说常见的编程范式有命令式编程、函数式编程、逻辑式编程等，而常见的面向对象编程居然是一种命令式编程。对于函数式编程来说，其只关心、定义输入数据和输出数据相关的关系，也就是映射。函数式编程关心数据的映射，命令式编程关心解决问题的步骤。 函数式编程概念 ","date":"2018-06-01","objectID":"/posts/php-functional-programming/:0:0","tags":["PHP"],"title":"PHP 中的函数式编程","uri":"/posts/php-functional-programming/"},{"categories":["PHP"],"content":"定义 函数式编程 - Functional Programming，一种编程范式，也就是如何编写程序的方法论。它属于『结构化编程』的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。 ","date":"2018-06-01","objectID":"/posts/php-functional-programming/:1:0","tags":["PHP"],"title":"PHP 中的函数式编程","uri":"/posts/php-functional-programming/"},{"categories":["PHP"],"content":"特性 闭包和高阶函数。 惰性计算。 递归。 函数是『第一等公民』：函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。 只用『表达式』，不用『语句』 没有『副作用』：函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。 不修改状态：函数不维护任何状态，只返回新的值，不修改系统变量。 引用透明性：如果提供同样的输入，那么函数总是返回同样的结果。 ","date":"2018-06-01","objectID":"/posts/php-functional-programming/:2:0","tags":["PHP"],"title":"PHP 中的函数式编程","uri":"/posts/php-functional-programming/"},{"categories":["PHP"],"content":"优点 代码简洁，开发快速。 接近自然语言，易于理解。 更方便的代码管理。 易于『并发编程』。 代码的热升级。 函数式编程实例 ","date":"2018-06-01","objectID":"/posts/php-functional-programming/:3:0","tags":["PHP"],"title":"PHP 中的函数式编程","uri":"/posts/php-functional-programming/"},{"categories":["PHP"],"content":"实例一 \u003c?php function map(callable $fn) { return function ($args) use ($fn) { foreach ($args as $key =\u003e $val) { yield $key =\u003e $fn($val); } }; } $a = function ($value) { return $value * 2; }; $b = function ($value) { return ucwords($value); }; $result1 = iterator_to_array(map($a)([1, 2, 3, 4])); $result2 = iterator_to_array(map($b)(['php', 'java', 'python'])); var_dump($result1, $result2); // 结果 array(4) { [0]=\u003e int(2) [1]=\u003e int(4) [2]=\u003e int(6) [3]=\u003e int(8) } array(3) { [0]=\u003e string(3) \"Php\" [1]=\u003e string(4) \"Java\" [2]=\u003e string(6) \"Python\" } ","date":"2018-06-01","objectID":"/posts/php-functional-programming/:4:0","tags":["PHP"],"title":"PHP 中的函数式编程","uri":"/posts/php-functional-programming/"},{"categories":["PHP"],"content":"实例二 \u003c?php function filter(callable $fn) { return function ($args) use ($fn) { foreach ($args as $key =\u003e $val) { if ($fn($val)) { yield $key =\u003e $val; } } }; } $a = function ($value) { return $value % 2 \u003e 0; }; $b = function ($value) { return ord($value) \u003e 97; }; $result1 = iterator_to_array(filter($a)([1, 2, 3, 4, 5])); $result2 = iterator_to_array(filter($b)(['a', 'b', 'c', 'd', 'e'])); var_dump($result1, $result2); // 结果 array(3) { [0]=\u003e int(1) [2]=\u003e int(3) [4]=\u003e int(5) } array(4) { [1]=\u003e string(1) \"b\" [2]=\u003e string(1) \"c\" [3]=\u003e string(1) \"d\" [4]=\u003e string(1) \"e\" } ","date":"2018-06-01","objectID":"/posts/php-functional-programming/:5:0","tags":["PHP"],"title":"PHP 中的函数式编程","uri":"/posts/php-functional-programming/"},{"categories":["PHP"],"content":"实例三 \u003c?php function reduce(callable $fn) { return function ($args) use ($fn) { $accumulator = 0; foreach ($args as $value) { $accumulator = $fn($accumulator, $value); } return $accumulator; }; } $a = function ($a, $b) { return $a + $b; }; $b = function ($a, $b) { return sqrt($a) + sqrt($b); }; $result1 = reduce($a)([1, 2, 3, 4, 5]); $result2 = round(reduce($b)([1, 2, 3, 4, 5]), 2); var_dump($result1, $result2); // 结果 int(15) float(4.19) ","date":"2018-06-01","objectID":"/posts/php-functional-programming/:6:0","tags":["PHP"],"title":"PHP 中的函数式编程","uri":"/posts/php-functional-programming/"},{"categories":["Mac"],"content":"如果说 VSCode 是编辑器的集大成者。那么 Sublime Text 绝对是编辑器中的一股清流，虽然闭源，但丝毫不影响它力压群雄。它们是编辑器中的双子星，足以裹挟一众码农驰骋码场，逐鹿万千码海。 ","date":"2018-05-26","objectID":"/posts/mac-sublime-text/:0:0","tags":["Mac"],"title":"Mac 万能编辑器 Sublime Text","uri":"/posts/mac-sublime-text/"},{"categories":["Mac"],"content":"简介 A sophisticated text editor for code, markup and prose. 短小精悍的简介，Sublime Text 深深打动我的是速度和易用性，无论是打开项目还是众多的项目间来回切换，还是日常编辑，它从来都没让我失望过，它以其速度碾压了绝大多数 Editor 和 IDE，其不足 15 MB 的安装包体积和流畅的表现，让人难以置信。 ","date":"2018-05-26","objectID":"/posts/mac-sublime-text/:1:0","tags":["Mac"],"title":"Mac 万能编辑器 Sublime Text","uri":"/posts/mac-sublime-text/"},{"categories":["Mac"],"content":"安装 Sublime Text 官网 Sublime Text 下载 Package Control ","date":"2018-05-26","objectID":"/posts/mac-sublime-text/:2:0","tags":["Mac"],"title":"Mac 万能编辑器 Sublime Text","uri":"/posts/mac-sublime-text/"},{"categories":["Mac"],"content":"插件管理器 Package Control- 姑且称它为插件管理器吧，它本身也是一款插件。 大部分的教程都提到安装 Package Control 时，按 Ctrl+~ 粘贴一堆代码到控制台，回车后完成安装。这里我们采用 Sublime Text 自带的命令来完成安装，根本不用粘贴代码。按 Command+Shift+P，在命令框中输入 install package control 回车即可，看图： 完成后如下图提示： 安装完成后，重启 Sublime Text，我们通过 Package Control: Install Package 来安装其它插件。 ","date":"2018-05-26","objectID":"/posts/mac-sublime-text/:3:0","tags":["Mac"],"title":"Mac 万能编辑器 Sublime Text","uri":"/posts/mac-sublime-text/"},{"categories":["Mac"],"content":"插件 Emmet：从此编写 HTML 和 CSS 代码健步如飞。 Project Manager：在不同的项目或工程间飞速的切换。 SideBarEnhancements：增强右键菜单功能。 EditorConfig：统一不同编辑器和 IDE 之间的编码风格。 SublimeLinter：代码检测框架。 SublimeLinter-php：PHP 代码检测。 AdvancedNewFile：高级的文件新建方式。 SyncedSideBar：自动定位当前文件在左边文件夹树中的位置。 Colorsublime：代码主题管理器，总有一款主题适合你。 Material Themel：绚丽夺目的编辑器主题。 GitGutter：标记代码中做的更新。 DocBlockr：自动生成 PHPDoc 风格的注释。 ConvertToUTF8：支持其它文件编码格式。 BracketHighlighter：匹配成对标签。 TrailingSpaces：检测代码中尾随的多余空格并干掉它们。 Git：Git 版本控制。 SublimeCodeIntel：代码智能提示。 AutoFileName：自动补全文件路径。 ActualVim：像 Vim 那样操作 Sublime Text。 未完待续。。。 ","date":"2018-05-26","objectID":"/posts/mac-sublime-text/:4:0","tags":["Mac"],"title":"Mac 万能编辑器 Sublime Text","uri":"/posts/mac-sublime-text/"},{"categories":["PHP"],"content":"归并排序利用归并（合并）的思想实现的排序方法。它的原理是假设初始序列含有 n 个元素，则可以看成是 n 个有序的子序列，每个子序列的长度为 1，然后两两归并，得到 n / 2 个长度为 2 或 1 的有序序列；再两两归并，……，如此重复，直至得到一个长度为 n 的有序序列为止，这种排序方法就成为两路归并排序。 ","date":"2018-05-04","objectID":"/posts/php-merge-sort/:0:0","tags":["PHP"],"title":"PHP 归并排序","uri":"/posts/php-merge-sort/"},{"categories":["PHP"],"content":"概念 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。在归并操作中将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。 ","date":"2018-05-04","objectID":"/posts/php-merge-sort/:1:0","tags":["PHP"],"title":"PHP 归并排序","uri":"/posts/php-merge-sort/"},{"categories":["PHP"],"content":"实现 ","date":"2018-05-04","objectID":"/posts/php-merge-sort/:2:0","tags":["PHP"],"title":"PHP 归并排序","uri":"/posts/php-merge-sort/"},{"categories":["PHP"],"content":"方案一 递归法 - Top-down： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤 3 直到某一指针到达序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 \u003c?php class MergeSort { /** * 主运行方法。 * * @return void */ public static function main(): void { $random = self::random(); $array = self::sort($random, 0, count($random) - 1); print_r($array); } /** * 归并排序。 * * @param array $array * @param int $left * @param int $right * * @return array */ public static function sort(array \u0026$array, int $left, int $right): array { if ($left \u003c $right) { $middle = (int)floor($left + $right) / 2; self::sort($array, $left, $middle); self::sort($array, $middle + 1, $right); self::merge($array, $left, $middle, $right); } return $array; } /** * 合并数组。 * * @param array $array * @param int $left * @param int $middle * @param int $right * * @return void */ private static function merge(array \u0026$array, int $left, int $middle, int $right): void { $i = $left; $j = $middle + 1; $k = $left; $tmp = []; while ($i \u003c= $middle \u0026\u0026 $j \u003c= $right) { if (self::compare($array[$i], $array[$j]) \u003e 0) { $tmp[$k++] = $array[$j++]; } else { $tmp[$k++] = $array[$i++]; } } while ($i \u003c= $middle) { $tmp[$k++] = $array[$i++]; } while ($j \u003c= $right) { $tmp[$k++] = $array[$j++]; } for ($k = $left; $k \u003c= $right; $k++) { $array[$k] = $tmp[$k]; } } /** * 比较大小。 * * @param int $x * @param int $y * * @return int */ private static function compare(int $x, int $y): int { return $x \u003c=\u003e $y; } /** * 互换位置。 * * @param int $x * @param int $y * * @return void */ private static function swap(int \u0026$x, int \u0026$y): void { if ($x !== $y) { $t = $x; $x = $y; $y = $t; } } /** * 生成随机数组。 * * @param int $low * @param int $high * @param int $num * * @return array */ private static function random(int $low = 1, int $high = 9999, int $num = 10): array { $num = $num \u003e $high ? $high : $num; $range = range($low, $high); $array = array_rand(array_flip($range), $num); shuffle($array); return $array; } } MergeSort::main(); // 结果 Array ( [0] =\u003e 1167 [1] =\u003e 2750 [2] =\u003e 3331 [3] =\u003e 4187 [4] =\u003e 4526 [5] =\u003e 5246 [6] =\u003e 5325 [7] =\u003e 6238 [8] =\u003e 7737 [9] =\u003e 9883 ) 由于 PHP 具备数组分割和数组合并这样的函数，所以以上的实现可以更加简单 \u003c?php class MergeSort { /** * 主运行方法。 * * @return void */ public static function main(): void { $random = self::random(); $array = self::sort($random); print_r($array); } /** * 归并排序。 * * @param array $array * * @return array */ public static function sort(array \u0026$array): array { $count = count($array); if ($count \u003c= 1) { return $array; } // 向上取整。 $middle = ($count \u003e\u003e 1) + ($count \u0026 1); $chunk = array_chunk($array, $middle); $left = self::sort($chunk[0]); $right = self::sort($chunk[1]); $arr = []; while (count($left) \u0026\u0026 count($right)) { if (self::compare($left[0], $right[0]) \u003e 0) { $arr[] = array_shift($right); } else { $arr[] = array_shift($left); } } return array_merge($arr, $left, $right); } /** * 比较大小。 * * @param int $x * @param int $y * * @return int */ private static function compare(int $x, int $y): int { return $x \u003c=\u003e $y; } /** * 互换位置。 * * @param int $x * @param int $y * * @return void */ private static function swap(int \u0026$x, int \u0026$y): void { if ($x !== $y) { $t = $x; $x = $y; $y = $t; } } /** * 生成随机数组。 * * @param int $low * @param int $high * @param int $num * * @return array */ private static function random(int $low = 1, int $high = 9999, int $num = 10): array { $num = $num \u003e $high ? $high : $num; $range = range($low, $high); $array = array_rand(array_flip($range), $num); shuffle($array); return $array; } } MergeSort::main(); // 结果 Array ( [0] =\u003e 1281 [1] =\u003e 1337 [2] =\u003e 3213 [3] =\u003e 4078 [4] =\u003e 5350 [5] =\u003e 5857 [6] =\u003e 5889 [7] =\u003e 8088 [8] =\u003e 8190 [9] =\u003e 8440 ) ","date":"2018-05-04","objectID":"/posts/php-merge-sort/:2:1","tags":["PHP"],"title":"PHP 归并排序","uri":"/posts/php-merge-sort/"},{"categories":["PHP"],"content":"方案二 迭代法 - Bottom-up： 将序列每相邻两个数字进行归并操作，形成 ceil(n/2) 个序列，排序后每个序列包含两/一个元素 若此时序列数不是 1 个则将上述序列再次归并，形成 ceil(n/4) 个序列，每个序列包含四/三个元素 重复步骤 2，直到所有元素排序完毕，即序列数为 1 // 以后完善…… ","date":"2018-05-04","objectID":"/posts/php-merge-sort/:2:2","tags":["PHP"],"title":"PHP 归并排序","uri":"/posts/php-merge-sort/"},{"categories":["PHP"],"content":"这篇算是最近写了一堆 bug 后的反省吧，日常开发中，我们总是要处理各种边界问题，尤为常见的就是给定一组范围，判断给定的范围是否在目标范围之内或者之外或者重叠之类的。这一类的判断情况稍不注意就容易滋生 bug，既然我已经中枪了，那么我就来说说这个情况如何处理。 ","date":"2018-05-02","objectID":"/posts/php-range-overlap/:0:0","tags":["PHP"],"title":"PHP 范围中的重叠关系","uri":"/posts/php-range-overlap/"},{"categories":["PHP"],"content":"问题 检查给定的一组范围的任意一个端点是否在目标范围之内 根据这个问题，我们马上想到这个要确定两种情况： 包含端点本身，即某个端点只要重叠就算，比如：[1, 2] 在 [2, 3] 端点之内，重叠部分为 2 不包含端点本身，即使有重叠的端点也不能算，比如：[1, 2] 不在 [2, 3] 端点之内，虽然有重叠部分，抱歉的是此 2 非彼 2 至于包不包含端点本身，视具体的情况而定 ","date":"2018-05-02","objectID":"/posts/php-range-overlap/:1:0","tags":["PHP"],"title":"PHP 范围中的重叠关系","uri":"/posts/php-range-overlap/"},{"categories":["PHP"],"content":"方案 \u003c?php class Range { public static function main() { $source = [1, 4]; $target = [4, 6]; // 包含端点重叠的情况。 $overlapWith = self::overlapWith($source, $target, true); // 不包含端点重叠的情况。 $nonOverlapWith = self::overlapWith($source, $target); var_dump($overlapWith, $nonOverlapWith); } /** * 是否给定的范围包含在目标范围中。 * * @param array $source * @param array $target * @param bool $overlap * * @return bool */ public static function overlapWith(array $source, array $target, $overlap = false): bool { sort($source); sort($target); if ($overlap) { return self::includeOverlap($source, $target); } return self::exclusiveOverlap($source, $target); } private static function includeOverlap(array $source, array $target): bool { [$begin, $end] = $source; if ($target[1] \u003c $begin) { return false; } if ($target[0] \u003e $end) { return false; } return true; } private static function exclusiveOverlap(array $source, array $target): bool { [$begin, $end] = $source; if ($target[1] \u003c= $begin) { return false; } if ($target[0] \u003e= $end) { return false; } return true; } } Range::main(); // 结果 bool(true) bool(false) ","date":"2018-05-02","objectID":"/posts/php-range-overlap/:2:0","tags":["PHP"],"title":"PHP 范围中的重叠关系","uri":"/posts/php-range-overlap/"},{"categories":["Git"],"content":"工作流 - Workflow：是对工作流程及其各操作步骤之间业务规则的抽象、概括描述。工作流建模，即将工作流程中的工作如何前后组织在一起的逻辑和规则，在计算机中以恰当的模型表达并对其实施计算。工作流要解决的主要问题是：为实现某个业务目标，利用计算机在多个参与者之间按某种预定规则自动传递文档、信息或者任务。 Git 起步 Git 基本操作 Git 查看日志 Git 分支 Git 中一个客户端设置多个账号 Git Workflow Git 命令大全 ","date":"2018-05-01","objectID":"/posts/git-workflow/:0:0","tags":["Git"],"title":"Git Workflow","uri":"/posts/git-workflow/"},{"categories":["Git"],"content":"Git Workflow 为了让大家有效地合作，使得项目井井有条地发展下去而抽象出来的一系列 git 操作步骤及流程，没错，是针对 git 的操作使用流程。 ","date":"2018-05-01","objectID":"/posts/git-workflow/:1:0","tags":["Git"],"title":"Git Workflow","uri":"/posts/git-workflow/"},{"categories":["Git"],"content":"常见的工作流 ","date":"2018-05-01","objectID":"/posts/git-workflow/:2:0","tags":["Git"],"title":"Git Workflow","uri":"/posts/git-workflow/"},{"categories":["Git"],"content":"集中式工作流 集中式工作流 - Centralized Workflow 创建中央仓库 假定 git 创建了一个裸仓库： $ ssh git@host $ cd ~ \u0026\u0026 mkdir -pv repository // 创建一个裸仓库，按照约定，加上 .git 扩展名 $ git init --bare /home/git/repository/repo.git 开发人员介入 第一阶段：本地开发 技巧 这一阶段，qwert 可以按自己需求反复操作多次，而不用担心中央仓库上有了什么操作，同样的情况也适用于 poiuy。 开发者 qwert： // 拉取代码 $ cd ~ \u0026\u0026 git clone ssh://git@host/home/git/repository/repo.git // 查看状态 $ git status // 创建 README.md 文件 $ touch README.md // 将 README.md 文件加入暂存区 $ git add README.md // 设置用户名和邮箱 $ git config user.email \"qwert@example.com\" $ git config user.name \"qwert\" // 提交代码到本地仓库 $ git commit -m \"Add README.md\" 开发者 poiuy // 拉取代码 $ cd ~ \u0026\u0026 git clone ssh://git@host/home/git/repository/repo.git // 查看状态 $ git status // 创建 README.md 文件 $ touch README.md // 将 README.md 文件加入暂存区 $ git add README.md $ vim README.md 1. this is the first commit. // 设置用户名和邮箱 $ git config user.email \"poiuy@example.com\" $ git config user.name \"poiuy\" // 提交代码到本地仓库 $ git commit -m \"Add README.md\" 直到这时两个人都相安无事，在各自的本地仓库玩的尽心。但事情不会就这样了结了，否则，我就没法往下写了。 第二阶段：远程同步 这时起，情况就变的有些复杂了，还好局面可控。 // qwert 提交代码到远程仓库 $ git push origin master // 接下来，poiuy 也将代码提交到远程仓库，这时真正的悲剧产生了 $ git push origin master To ssh://git@host/home/git/repository/repo.git ! [rejected] master -\u003e master (fetch first) error: failed to push some refs to 'ssh://git@host/home/git/repository/repo.git' hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first merge the remote changes (e.g., hint: 'git pull') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. // 也就是说，poiuy 得先拉一下远程仓库的代码到本地，再进行提交，因为你在人家 push 后面进行 push 的，这不怪你 $ git pull --rebase origin master warning: no common commits remote: Counting objects: 3, done. remote: Total 3 (delta 0), reused 0 (delta 0) Unpacking objects: 100% (3/3), done. From ssh://host/home/git/repository/repo * branch master -\u003e FETCH_HEAD First, rewinding head to replay your work on top of it... Applying: Add README.md Using index info to reconstruct a base tree... Falling back to patching base and 3-way merge... Auto-merging README.md 警告 --rebase：这个选项就是告诉 Git 把 poiuy 的提交移到同步了中央仓库修改后的 master 分支的顶部。如果你忘加了这个选项，pull 操作仍然可以完成，但每次 pull 操作要同步中央仓库中别人修改时，提交历史会以一个多余的『合并提交』结尾。对于集中式工作流，最好是使用 rebase 而不是生成一个合并提交。 // qwert 续续编辑文件 README.md 并提交推送到远程 $ vim README.md 1. this is the second commit. # 只将单词 first 改为 second $ git add README.md $ git commit -m \"Update README.md\" $ git push origin master // poiuy 使用 git pull 同步远程代码到本地，这将产生一个冲突 $ git pull origin master remote: Counting objects: 5, done. remote: Total 3 (delta 0), reused 0 (delta 0) Unpacking objects: 100% (3/3), done. From ssh://host/home/git/repository/repo * [new branch] master -\u003e origin/master Auto-merging README.md CONFLICT (content): Merge conflict in README.md Automatic merge failed; fix conflicts and then commit the result. // poiuy 使用 git pull --rebase 同步远程代码到本地，托 --rebase 的福没有产生冲突 $ git pull --rebase origin master From ssh://host/home/git/repository/repo * branch master -\u003e FETCH_HEAD First, rewinding head to replay your work on top of it... Fast-forwarded master to 3a24fcf204956f97a7499393fbca68e3a77df040. // poiuy 继续编辑 README.md $ vim README.md 1. this is the second commit. 2. poiuy # 新增一行 $ git add . $ git commit -m \"Update README.md\" $ git push origin master // qwert 继续编辑 README.md $ vim README.md 1. this is the second commit. 2. qwert # 新增一行 $ git add . $ git commit -m \"Update README.md\" $ git push origin master # 这时远程仓库拒绝 qwert 的提交，因为 poiuy 已经将最新改动提交到远程了，qwert 必须将远程同步到本地 To ssh://git@host/home/git/repository/repo.git ! [rejected] master -\u003e master (fetch first) error: failed to push some refs to 'ssh://git@host/home/git/repository/repo.git' hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first merge the remote changes (e.g., hint: 'git pull') before ","date":"2018-05-01","objectID":"/posts/git-workflow/:2:1","tags":["Git"],"title":"Git Workflow","uri":"/posts/git-workflow/"},{"categories":["Git"],"content":"Gitflow 工作流 Gitflow 工作流 - Gitflow Workflow 拉取远程仓库 Gitflow 工作流仍然用中央仓库作为所有开发者的交互中心。这里我沿用集中式工作流中创建的仓库。 // qwert 工作准备 $ ssh qwert@host \u0026\u0026 cd ~ \u0026\u0026 git clone ssh://git@host/home/git/repository/repo.git $ git config user.name \"qwert\" $ git config user.email \"qwert@example.com\" // poiuy 工作准备 $ ssh poiuy@host \u0026\u0026 cd ~ \u0026\u0026 git clone ssh://git@host/home/git/repository/repo.git $ git config user.name \"poiuy\" $ git config user.email \"poiuy@example.com\" Gitflow 工具安装 AVH Edition 安装说明 git-flow 备忘清单 Gitflow 两个长期分支： 主分支 master 开发分支 develop Gitflow 三个短期分支： 功能分支 feature branch 补丁分支 hotfix branch 预发分支 release branch 关于 git-flow 这篇 Learn Version Control with Git 说的非常到位。 // Linux 下安装 $ curl --insecure --silent --location https://raw.githubusercontent.com/petervanderdoes/gitflow-avh/develop/contrib/gitflow-installer.sh --output ./gitflow-installer.sh $ chmod +x ./gitflow-installer.sh $ sudo ./gitflow-installer.sh install stable Gitflow 初始化 // qwert 用户初始化 git-flow $ git flow init Which branch should be used for bringing forth production releases? - master Branch name for production releases: [master] Branch name for \"next release\" development: [develop] How to name your supporting branch prefixes? Feature branches? [feature/] Bugfix branches? [bugfix/] Release branches? [release/] Hotfix branches? [hotfix/] Support branches? [support/] Version tag prefix? [] Hooks and filters directory? [/home/qwert/repo/.git/hooks] $ git push -u origin develop # 将 develop 分支提交到远程仓库 // poiuy 用户初始化 git-flow $ git flow init Which branch should be used for bringing forth production releases? - master Branch name for production releases: [master] Branch name for \"next release\" development: [develop] How to name your supporting branch prefixes? Feature branches? [feature/] Bugfix branches? [bugfix/] Release branches? [release/] Hotfix branches? [hotfix/] Support branches? [support/] Version tag prefix? [] Hooks and filters directory? [/home/poiuy/repo/.git/hooks] 开发阶段 开发者 qwert： // qwert 开启一个功能分支，进行项目某个功能开发 $ git flow feature start feature-qwert Switched to a new branch 'feature/feature-qwert' Summary of actions: - A new branch 'feature/feature-qwert' was created, based on 'develop' - You are now on branch 'feature/feature-qwert' Now, start committing on your feature. When done, use: git flow feature finish feature-qwert // qwert 操作 $ vim README.md 1. this is the second commit. 2. poiuy 3. qwert 4. qwert feature start. $ git add README.md $ git commit -m \"Update README.md\" $ git flow feature finish feature-qwert # 此时 qwert 将完成开发结束任务，feature-qwert 分支的使命就此完结 Switched to branch 'develop' Updating d62035e..ced573c Fast-forward README.md | 1 + 1 file changed, 1 insertion(+) Deleted branch feature/feature-qwert (was ced573c). Summary of actions: - The feature branch 'feature/feature-qwert' was merged into 'develop' - Feature branch 'feature/feature-qwert' has been locally deleted - You are now on branch 'develop' $ git push origin develop # 将 develop 分支提交到远程仓库 开发者 poiuy： // poiuy 开启一个功能分支，进行项目另一个功能开发 $ git flow feature start feature-poiuy Switched to a new branch 'feature/feature-poiuy' Summary of actions: - A new branch 'feature/feature-poiuy' was created, based on 'develop' - You are now on branch 'feature/feature-poiuy' Now, start committing on your feature. When done, use: git flow feature finish feature-poiuy // poiuy 操作 $ vim README.md 1. this is the second commit. 2. poiuy 3. qwert 4. poiuy feature start. $ git README.md $ git commit -m \"Update README.md\" $ git flow feature finish feature-poiuy # 此时 poiuy 将完成开发结束任务，feature-poiuy 分支的使命就此完结 // poiuy 跟踪远程分支 $ git branch --set-upstream-to=origin/develop develop Branch develop set up to track remote branch develop from origin. $ git push origin develop # poiuy 将开发好的功能推送到远程，但抱歉的时，此时远程 develop 已经向前滚动，因为不只是你一个人在开发 To ssh://git@host/home/git/repository/repo.git ! [rejected] develop -\u003e develop (non-fast-forward) error: failed to push some refs to 'ssh://git@host/home/git/repository/repo.git' hint: Updates were rejected because the ti","date":"2018-05-01","objectID":"/posts/git-workflow/:2:2","tags":["Git"],"title":"Git Workflow","uri":"/posts/git-workflow/"},{"categories":["Git"],"content":"Forking 工作流 Forking Workflow 为了演示 Forking Workflow 的工作流程，我准备了三个 github 账号，假设为维护者 git、开发者 qwert 和 poiuy。 创建远程仓库 维护者 git 创建一个公开的远程仓库： 开发者 qwert 去 Fork 维护者 git 创建的项目，当然，开发者 poiuy 也和 qwert 一样去 Fork 仓库： 完成之后，qwert 和 poiuy 相当于把远程 git 创建的项目克隆到各自的远程仓库 功能开发 // qwert 拉取远程仓库代码到本地 $ git clone https://github.com/qwert/repo.git $ git config user.name \"qwert\" $ git config user.email \"qwert@example.com\" $ vim README.md # repo This is a forking workflow\\'s demo. ## Develop Feature 1. this is written by Quert. $ git add README.md $ git commit -m \"Update README.md\" $ git push -u origin master // poiuy 拉取远程仓库代码到本地 $ git clone https://github.com/poiuy/repo.git $ git config user.name \"poiuy\" $ git config user.email \"poiuy@example.com\" $ vim README.md # repo This is a forking workflow\\'s demo. ## Develop Feature 1. this is written by Poiuy. $ git add README.md $ git commit -m \"Update README.md\" $ git push -u origin master 发起 Pull Request 可以看到开发者 qwert 没有权限合并代码，此时只有维护者 git 才能合并代码，维护者 git 去合并代码： 开发者 poiuy 也采取和 qwert 一样的流程，但是当他申请合并时，出现了冲突，这是预科中的事，因为两人同时对一个文件相同的区域进行了编辑： poiuy 去解决冲突： 可以看到开发者 poiuy 也没有权限合并代码，此时也只有维护者 git 才能合并代码： 至此，qwert 和 poiuy 开发的新功能都合并到远程维护者的 master 分支，这一阶段的开发告一段落。 Forking 工作流的使用场景： 常用于开源软件 开发者有需要衍生出自己的衍生版的 开发者不固定，可能是任意一个远程工作者 ","date":"2018-05-01","objectID":"/posts/git-workflow/:2:3","tags":["Git"],"title":"Git Workflow","uri":"/posts/git-workflow/"},{"categories":["Git"],"content":"Feature branching 工作流 Feature Branching Workflow 这个流程大概算是 Gitflow 的简化版，不再需要安装额外 Git 插件，这个流程配合一些代码托管平台可以玩的风生水起。 特性分支下拉取远程仓库 功能分支工作流中我们仍然使用之前创建的中央仓库，并且 master 分支还是代表了正式项目的历史。这种工作流不是直接提交本地历史到各自的本地 master 分支，开发者每次在开始新功能前先基于 master 创建一个新分支，给分支起一个描述性的名称，这样分支用途就比较明显。 准备工作还是老套路 // qwert 工作准备 $ ssh qwert@host \u0026\u0026 cd ~ \u0026\u0026 git clone ssh://git@host/home/git/repository/repo.git $ git config user.name \"qwert\" $ git config user.email \"qwert@example.com\" // poiuy 工作准备 $ ssh poiuy@host \u0026\u0026 cd ~ \u0026\u0026 git clone ssh://git@host/home/git/repository/repo.git $ git config user.name \"poiuy\" $ git config user.email \"poiuy@example.com\" 功性分支下开发阶段 开发者 qwert： // 创建功能分支 $ git checkout -b dev-user-menu $ vim README.md 1. this is the second commit. 2. poiuy 3. qwert 4. qwert feature start. 5. poiuy feature start. 6. qwert another feature start. 7. poiuy tract release v1.0 8. qwert hotfix start. 9. qwert develop user menu. $ git add README.md $ git commit -m \"Develop user menu.\" $ git push -u origin master 开发者 poiuy： // 创建功能分支 $ git checkout -b dev-user-auth $ vim README.md 1. this is the second commit. 2. poiuy 3. qwert 4. qwert feature start. 5. poiuy feature start. 6. qwert another feature start. 7. poiuy tract release v1.0 8. qwert hotfix start. 9. poiuy develop user auth. $ git add README.md $ git commit -m \"Develop user auth\" $ git push -u origin dev-user-auth 一段时间以后，qwert 和 poiuy 都声称把各个负责的功能开发完成，并提交到远程仓库了 // 发布开发者 qwert 的功能到测试环境测试，测试通过后合并到 master 分支 $ git checkout master $ git pull # 拉取其它开发者的更新 remote: Counting objects: 5, done. remote: Compressing objects: 100% (2/2), done. remote: Total 3 (delta 1), reused 0 (delta 0) Unpacking objects: 100% (3/3), done. From ssh://host/home/git/repository/repo * [new branch] dev-user-auth -\u003e origin/dev-user-auth Already up-to-date. $ git checkout dev-user-menu $ git rebase master # 用 rebase 合并主干的修改，如果有冲突在此时解决 $ git checkout master // 将 qwert 新开发的功能合并到 master 分支 $ git merge dev-user-menu Updating 40e19f1..4f92cff Fast-forward README.md | 1 + 1 file changed, 1 insertion(+) $ git push origin master # 将合并后的提交到远程 master 分支 // 开发者 poiuy 的也通过测试，需要将代码合并到 master 分支 $ git checkout master Switched to branch 'master' Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded. (use \"git pull\" to update your local branch) $ git pull From ssh://host/home/git/repository/repo 40e19f1..4f92cff master -\u003e origin/master Updating 40e19f1..4f92cff Fast-forward README.md | 1 + 1 file changed, 1 insertion(+) // 切换到功能分支，用 rebase 合并主干的修改，之前由于 qwert 和 poiuy 编辑同一个区域，无疑会产生冲突 $ git checkout dev-user-auth $ git rebase master # 用 rebase 合并主干的修改，如果有冲突在此时解决 First, rewinding head to replay your work on top of it... Applying: Develop user auth Using index info to reconstruct a base tree... M README.md Falling back to patching base and 3-way merge... Auto-merging README.md CONFLICT (content): Merge conflict in README.md Failed to merge in the changes. Patch failed at 0001 Develop user auth The copy of the patch that failed is found in: /home/poiuy/repo/.git/rebase-apply/patch When you have resolved this problem, run \"git rebase --continue\". If you prefer to skip this patch, run \"git rebase --skip\" instead. To check out the original branch and stop rebasing, run \"git rebase --abort\". $ git rebase --continue # 动用 rebase --continue 命令逐个修复冲突文件，直到 No rebase in progress? 为止 $ git add README.md $ git commit -m \"Conflict resolution\" $ git push origin dev-user-auth Counting objects: 10, done. Compressing objects: 100% (4/4), done. Writing objects: 100% (6/6), 679 bytes | 0 bytes/s, done. Total 6 (delta 1), reused 0 (delta 0) To ssh://git@host/home/git/repository/repo.git ccbab61..f0aea38 dev-user-auth -\u003e dev-user-auth // 开发者 poiuy 切换到 master 分支，将冲突后的修复合并回 master $ git checkou master $ git merge dev-user-auth Updating 4f92cff..f0aea38 Fast-forward README.md | 5 +++++ 1 file changed, 5 insertions(+) $ git push origin master // 此时 qwert 再切换到 master 进行拉取，至此两个开发者的各个功能都合并到 master 分支了，可以发布 release 了 $ git checkou master $ git pull remote: Counting objects:","date":"2018-05-01","objectID":"/posts/git-workflow/:2:4","tags":["Git"],"title":"Git Workflow","uri":"/posts/git-workflow/"},{"categories":["Git"],"content":"参考 A successful Git branching model ","date":"2018-05-01","objectID":"/posts/git-workflow/:3:0","tags":["Git"],"title":"Git Workflow","uri":"/posts/git-workflow/"},{"categories":["PHP"],"content":"变量有值传递和引用传递，其实，对象也如此，所以，对象有浅克隆和深克隆这么一说。浅克隆也叫浅复制或浅拷贝，深克隆也叫深复制或深拷贝。唉，名称复名称，名称何其多？ ","date":"2018-04-27","objectID":"/posts/php-shallow-and-deep-clone/:0:0","tags":["PHP"],"title":"PHP 中的浅克隆和深克隆","uri":"/posts/php-shallow-and-deep-clone/"},{"categories":["PHP"],"content":"浅克隆 引用的解释，官方说的最靠谱 警告 自 PHP 5 起，new 运算符自动返回一个引用 浅克隆在赋值时，引用赋值，相当于取了一个别名。对其中一个的修改，会影响到另一个 ","date":"2018-04-27","objectID":"/posts/php-shallow-and-deep-clone/:1:0","tags":["PHP"],"title":"PHP 中的浅克隆和深克隆","uri":"/posts/php-shallow-and-deep-clone/"},{"categories":["PHP"],"content":"赋值 \u003c?php class Student { private $name; public function setName(string $name): self { $this-\u003ename = $name; return $this; } public function getName(): string { return $this-\u003ename; } } $jack1 = new Student(); $jack1-\u003esetName('Jack 1'); $jack2 = $jack1; $jack2-\u003esetName('Jack 2'); var_dump($jack1); var_dump($jack2); // 结果 class Student#1 (1) { private $name =\u003e string(6) \"Jack 2\" } class Student#1 (1) { private $name =\u003e string(6) \"Jack 2\" } 在以上的场景中，无论你修改哪个 Jack，都会影响到另一个对象，当然我这样说，可能有些人不服，比如： \u003c?php class Student { private $name; public function setName(string $name): self { $this-\u003ename = $name; return $this; } public function getName(): string { return $this-\u003ename; } } $jack1 = new Student(); $jack1-\u003esetName('Jack 1'); var_dump($jack1); // 这儿调整了下执行顺序 $jack2 = $jack1; $jack2-\u003esetName('Jack 2'); var_dump($jack2); // 结果 class Student#1 (1) { private $name =\u003e string(6) \"Jack 1\" } class Student#1 (1) { private $name =\u003e string(6) \"Jack 2\" } 看到了吗？两个 Jack 的学生名称就是不一样。感觉像是被打脸了，如果你再 $jack2 赋值后再打印一下 $jack1 试试，看谁能笑到最后 ","date":"2018-04-27","objectID":"/posts/php-shallow-and-deep-clone/:1:1","tags":["PHP"],"title":"PHP 中的浅克隆和深克隆","uri":"/posts/php-shallow-and-deep-clone/"},{"categories":["PHP"],"content":"克隆 警告 使用 clone 操作复制对象时，当被复制的对象有对其它对象的引用的时候，引用的对象将不会被复制 \u003c?php class Student { private $name; public function setName(string $name): self { $this-\u003ename = $name; return $this; } public function getName(): string { return $this-\u003ename; } } class Administration { private $classLeader; public function setClassLeader(Student $student) { $this-\u003eclassLeader = $student; return $this; } /** * @return \\Student */ public function getClassLeader(): Student { return $this-\u003eclassLeader; } } $jack = new Student(); $jack-\u003esetName('Jack'); $admin1 = new Administration(); $admin1-\u003esetClassLeader($jack); $admin2 = clone $admin1; $admin2-\u003egetClassLeader()-\u003esetName('Lucy'); echo $admin1-\u003egetClassLeader()-\u003egetName(), PHP_EOL, $admin2-\u003egetClassLeader()-\u003egetName(); // 结果 Lucy Lucy 操蛋呀，$admin1-\u003egetClassLeader() 和 $admin2-\u003egetClassLeader() 居然都指向同一个对象。但 $admin1 和 $admin2 都是货真价实的两个独立对象，唯一的遗憾是他们的属性出卖了他们，看来这也是个浅复制 所以，浅克隆时，被赋值对象的所有变量都还与原来对象有相同的值，而所有的对其他对象的引用都仍然指向原来的对象 ","date":"2018-04-27","objectID":"/posts/php-shallow-and-deep-clone/:1:2","tags":["PHP"],"title":"PHP 中的浅克隆和深克隆","uri":"/posts/php-shallow-and-deep-clone/"},{"categories":["PHP"],"content":"深克隆 ","date":"2018-04-27","objectID":"/posts/php-shallow-and-deep-clone/:2:0","tags":["PHP"],"title":"PHP 中的浅克隆和深克隆","uri":"/posts/php-shallow-and-deep-clone/"},{"categories":["PHP"],"content":"方案一 基于魔术变量 __clone() 的实现 \u003c?php class Student { private $name; public function setName(string $name): self { $this-\u003ename = $name; return $this; } public function getName(): string { return $this-\u003ename; } } class Administration { private $classLeader; public function __clone() { $this-\u003eclassLeader = clone $this-\u003eclassLeader; } public function setClassLeader(Student $student) { $this-\u003eclassLeader = $student; return $this; } /** * @return \\Student */ public function getClassLeader(): Student { return $this-\u003eclassLeader; } } $jack = new Student(); $jack-\u003esetName('Jack'); $admin1 = new Administration(); $admin1-\u003esetClassLeader($jack); $admin2 = clone $admin1; $admin2-\u003egetClassLeader()-\u003esetName('Lucy'); print $admin1-\u003egetClassLeader()-\u003egetName(); print PHP_EOL; print $admin2-\u003egetClassLeader()-\u003egetName(); // 结果 Jack Lucy ","date":"2018-04-27","objectID":"/posts/php-shallow-and-deep-clone/:2:1","tags":["PHP"],"title":"PHP 中的浅克隆和深克隆","uri":"/posts/php-shallow-and-deep-clone/"},{"categories":["PHP"],"content":"方案二 利用串行化做深复制 \u003c?php class Student { private $name; public function setName(string $name): self { $this-\u003ename = $name; return $this; } public function getName(): string { return $this-\u003ename; } } class Administration { private $classLeader; public function setClassLeader(Student $student) { $this-\u003eclassLeader = $student; return $this; } /** * @return \\Student */ public function getClassLeader(): Student { return $this-\u003eclassLeader; } } $jack = new Student(); $jack-\u003esetName('Jack'); $admin1 = new Administration(); $admin1-\u003esetClassLeader($jack); /** @var \\Administration $admin2 */ $admin2 = unserialize(serialize($admin1)); $admin2-\u003egetClassLeader()-\u003esetName('Lucy'); print_r([ $admin1-\u003egetClassLeader()-\u003egetName(), $admin2-\u003egetClassLeader()-\u003egetName(), ]); // 结果 Array ( [0] =\u003e Jack [1] =\u003e Lucy ) 当然，利用串行化的这种方案也可以封装到 __clone() 方法中： public function __clone() { foreach($this as $key =\u003e $val) { if (is_object($val) || (\\is_array($val))) { $this-\u003e{$key} = unserialize(serialize($val)); } } } 所以，深克隆把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。 ","date":"2018-04-27","objectID":"/posts/php-shallow-and-deep-clone/:2:2","tags":["PHP"],"title":"PHP 中的浅克隆和深克隆","uri":"/posts/php-shallow-and-deep-clone/"},{"categories":["PHP"],"content":"对浮点数进行比较运算是一个坑爹的事，由于栽在这个问题上的次数比较多，总是记吃不记打的，痛定思痛后打算整理一下，避免下次再犯。 ","date":"2018-04-18","objectID":"/posts/php-float-number/:0:0","tags":["PHP"],"title":"PHP 中的浮点数","uri":"/posts/php-float-number/"},{"categories":["PHP"],"content":"浮点数的陷阱实例 PHP 浮点数的一个常见问题的解答 IEEE 754 格式是什么？ ","date":"2018-04-18","objectID":"/posts/php-float-number/:1:0","tags":["PHP"],"title":"PHP 中的浮点数","uri":"/posts/php-float-number/"},{"categories":["PHP"],"content":"浮点数计算错误实例 \u003c?php $float = 0.58; var_dump($float * 100); var_dump(intval($float * 100)); double(58) int(57) // 居然是 57 ","date":"2018-04-18","objectID":"/posts/php-float-number/:1:1","tags":["PHP"],"title":"PHP 中的浮点数","uri":"/posts/php-float-number/"},{"categories":["PHP"],"content":"浮点数比较错误实例 \u003c?php $a = 0.1; $b = 0.2; var_dump($a); var_dump($b); var_dump($a + $b); var_dump($a + $b === 0.3); // 结果 double(0.1) double(0.2) double(0.3) bool(false) // 居然是 false ?\u003e 警告 浮点数的精度 浮点数的精度有限。尽管取决于系统，PHP 通常使用 IEEE 754 双精度格式，则由于取整而导致的最大相对误差为 1.11e-16。非基本数学运算可能会给出更大误差，并且要考虑到进行复合运算时的误差传递 此外，以十进制能够精确表示的有理数如 0.1 或 0.7，无论有多少尾数都不能被内部所使用的二进制精确表示，因此不能在不丢失一点点精度的情况下转换为二进制的格式。这就会造成混乱的结果，例如：floor((0.1+0.7)*10 通常会返回 7 而不是预期中的 8，因为该结果内部的表示其实是类似 7.9999999999999991118... 所以，永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。如果确实需要更高的精度，应该使用 任意精度数学函数 或者 gmp 函数 ","date":"2018-04-18","objectID":"/posts/php-float-number/:1:2","tags":["PHP"],"title":"PHP 中的浮点数","uri":"/posts/php-float-number/"},{"categories":["PHP"],"content":"精度数学函数 名称 说明 bcadd() 任意精度数字的加法计算 bccomp() 比较两个任意精度的数字 bcdiv() 两个任意精度的数字除法计算 bcmod() 对一个任意精度数字取模 bcmul() 两个任意精度数字乘法计算 bcpow() 任意精度数字的乘方 bcpowmod() 任意精度数字乘方求模 bcscale() 设置所有 bc 数学函数的默认小数点保留位数 bcsqrt() 任意精度数字的二次方根 bcsub() 两个任意精度数字的减法 警告 使用 bcscale() 设置的位数，超出部分是丢弃掉，而不是四舍五入 \u003c?php declare(strict_types=1); $a = '0.19'; $b = '0.81'; $array = [ 'bcadd' =\u003e bcadd($a, $b, 2), 'bccomp' =\u003e bccomp(bcadd($a, $b), '1', 1), // 两个数相等返回 0 'bcdiv' =\u003e bcdiv('100', '3', 4), 'bcmod' =\u003e bcmod(PHP_VERSION, '2'), 'bcmul' =\u003e bcmul($a, $b, 4), 'bcpow' =\u003e bcpow('2.2', '3', 3), 'bcpowmod' =\u003e bcpowmod('2', '2', '3'), 'bcscale' =\u003e bcscale(6), // 设置新的小数点保留位数 'bcsqrt' =\u003e bcsqrt('4'), 'bcsub' =\u003e bcsub($b, $a), ]; print_r($array); // 结果 Array ( [bcadd] =\u003e 1.00 [bccomp] =\u003e 0 [bcdiv] =\u003e 33.3333 [bcmod] =\u003e 0 [bcmul] =\u003e 0.1539 [bcpow] =\u003e 10.648 [bcpowmod] =\u003e 1 [bcscale] =\u003e 1 [bcsqrt] =\u003e 2.000000 [bcsub] =\u003e 0.620000 ) ","date":"2018-04-18","objectID":"/posts/php-float-number/:2:0","tags":["PHP"],"title":"PHP 中的浮点数","uri":"/posts/php-float-number/"},{"categories":["PHP"],"content":"正确的姿势 \u003c?php declare(strict_types=1); $a = '0.185'; $b = '0.804'; $c = 0.185; $d = 0.804; $e = 101.1988654321; $f = 101.1988456789; $g = 1.23456789; $h = 1.23456780; $epsilon = 0.00001; // 机器极小值（epsilon）或最小单元取整数，是计算中所能接受的最小的差别值 var_dump(bcadd($a, $b, 2) === '0.98'); var_dump(round($c + $d, 2) === 0.99); var_dump(bccomp((string)$e, (string)$f, 3) === 0); var_dump(abs($g - $h) \u003c $epsilon); // 误差小于这个值可以接受 // 结果 bool(true) bool(true) bool(true) bool(true) ","date":"2018-04-18","objectID":"/posts/php-float-number/:3:0","tags":["PHP"],"title":"PHP 中的浮点数","uri":"/posts/php-float-number/"},{"categories":["PHP"],"content":"选择排序分为简单选择排序、树形选择排序和堆排序三类，此三类中，简单选择排序是最简单，也是最好理解的。 ","date":"2018-04-18","objectID":"/posts/php-selection-sort/:0:0","tags":["PHP"],"title":"PHP 选择排序","uri":"/posts/php-selection-sort/"},{"categories":["PHP"],"content":"概念 选择排序 - Selection Sort：是一种简单直观的排序算法。顾名思意，就是直接从待排序数组里选择一个最小(或最大)的数字，每次都拿一个最小数字出来，顺序放入新数组，直到全部拿完 ","date":"2018-04-18","objectID":"/posts/php-selection-sort/:1:0","tags":["PHP"],"title":"PHP 选择排序","uri":"/posts/php-selection-sort/"},{"categories":["PHP"],"content":"步骤 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾 以此类推，直到所有元素均排序完毕 ","date":"2018-04-18","objectID":"/posts/php-selection-sort/:2:0","tags":["PHP"],"title":"PHP 选择排序","uri":"/posts/php-selection-sort/"},{"categories":["PHP"],"content":"实现 ","date":"2018-04-18","objectID":"/posts/php-selection-sort/:3:0","tags":["PHP"],"title":"PHP 选择排序","uri":"/posts/php-selection-sort/"},{"categories":["PHP"],"content":"方式一 \u003c?php class SelectionSort { /** * 主运行方法 * * @return void */ public static function main(): void { $random = self::random(); $array = self::sort($random); print_r($array); } /** * 选择排序 * * @param array $array * * @return array */ public static function sort(array \u0026$array): array { $count = count($array); for ($i = 0; $i \u003c $count; $i++) { $position = $i; for ($j = $i + 1; $j \u003c $count; $j++) { if (self::compare($array[$position], $array[$j]) \u003e 0) { $position = $j; } } if ($position !== $i) { self::swap($array[$position], $array[$i]); } } return $array; } /** * 比较大小 * * @param int $x * @param int $y * * @return int */ private static function compare(int $x, int $y): int { return $x \u003c=\u003e $y; } /** * 互换位置 * * @param int $x * @param int $y * * @return void */ private static function swap(int \u0026$x, int \u0026$y): void { if ($x !== $y) { $t = $x; $x = $y; $y = $t; } } /** * 生成随机数组 * * @param int $low * @param int $high * @param int $num * * @return array */ private static function random(int $low = 1, int $high = 9999, int $num = 10): array { $num = $num \u003e $high ? $high : $num; $range = range($low, $high); $array = array_rand(array_flip($range), $num); shuffle($array); return $array; } } SelectionSort::main(); // 结果 Array ( [0] =\u003e 312 [1] =\u003e 1124 [2] =\u003e 1267 [3] =\u003e 1884 [4] =\u003e 2609 [5] =\u003e 4177 [6] =\u003e 4773 [7] =\u003e 7728 [8] =\u003e 8237 [9] =\u003e 8963 ) ","date":"2018-04-18","objectID":"/posts/php-selection-sort/:3:1","tags":["PHP"],"title":"PHP 选择排序","uri":"/posts/php-selection-sort/"},{"categories":["PHP"],"content":"方式二 树形选择排序 - Tree Selection Sort：又名锦标赛排序，是一种按照锦标赛的思想进行选择排序的方法 \u003c?php // 这个算法目前搞不定，预留位置，待以后再实现 ","date":"2018-04-18","objectID":"/posts/php-selection-sort/:3:2","tags":["PHP"],"title":"PHP 选择排序","uri":"/posts/php-selection-sort/"},{"categories":["PHP"],"content":"方式三 堆排序 - Heap Sort：是指利用堆这种数据结构所设计的一种排序算法。它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶 \u003c?php // 这个算法目前搞不定，预留位置，待以后再实现 ","date":"2018-04-18","objectID":"/posts/php-selection-sort/:3:3","tags":["PHP"],"title":"PHP 选择排序","uri":"/posts/php-selection-sort/"},{"categories":["PHP"],"content":"曾经在一次面试中，面试官问过我这个算法，我当时一脸懵逼，就说它比较快，所以就是快速排序，至于怎么快的一问三不知。所谓吃一堑长一智嘛，不管你怎么理解，最终还不得反应到代码实现上么？不费话了，上代码。 ","date":"2018-04-17","objectID":"/posts/php-quick-sort/:0:0","tags":["PHP"],"title":"PHP 快速排序","uri":"/posts/php-quick-sort/"},{"categories":["PHP"],"content":"概念 快速排序 - Quick Sort：又称划分交换排序 - partition-exchange sort，简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 n 个项目要 O(n log n) 次比较。在最坏状况下则需要 O(n^2) 次比较，但这种状况并不常见。事实上，快速排序 O(n log n) 通常明显比其他算法更快，因为它的内部循环 （inner loop）可以在大部分的架构上很有效率地达成。 ","date":"2018-04-17","objectID":"/posts/php-quick-sort/:1:0","tags":["PHP"],"title":"PHP 快速排序","uri":"/posts/php-quick-sort/"},{"categories":["PHP"],"content":"步骤 从数列中挑出一个元素，称为『基准』- pivot 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序 ","date":"2018-04-17","objectID":"/posts/php-quick-sort/:2:0","tags":["PHP"],"title":"PHP 快速排序","uri":"/posts/php-quick-sort/"},{"categories":["PHP"],"content":"实现 ","date":"2018-04-17","objectID":"/posts/php-quick-sort/:3:0","tags":["PHP"],"title":"PHP 快速排序","uri":"/posts/php-quick-sort/"},{"categories":["PHP"],"content":"方案一 \u003c?php class QuickSort { /** * 主运行方法 * * @return void */ public static function main(): void { $random = self::random(); $array = self::sort($random); print_r($array); } /** * 快速排序 * * @param array $array * * @return array */ public static function sort(array \u0026$array): array { $count = count($array); if ($count \u003c= 1) { return $array; } $pivot = $array[0]; // 取数组第一个元素为基准值 $left = $right = []; for ($i = 1; $i \u003c $count; $i++) { $value = $array[$i]; if (self::compare($pivot, $value) \u003e 0) { $left[] = $array[$i]; } else { $right[] = $array[$i]; } } $left = self::sort($left); $right = self::sort($right); return array_merge($left, (array)$pivot, $right); } /** * 比较大小 * * @param int $x * @param int $y * * @return int */ private static function compare(int $x, int $y): int { return $x \u003c=\u003e $y; } /** * 互换位置 * * @param int $x * @param int $y * * @return void */ private static function swap(int \u0026$x, int \u0026$y): void { if ($x !== $y) { $t = $x; $x = $y; $y = $t; } } /** * 生成随机数组 * * @param int $low * @param int $high * @param int $num * * @return array */ private static function random(int $low = 1, int $high = 9999, int $num = 10): array { $num = $num \u003e $high ? $high : $num; $range = range($low, $high); $array = array_rand(array_flip($range), $num); shuffle($array); return $array; } } QuickSort::main(); // 结果 Array ( [0] =\u003e 1073 [1] =\u003e 1535 [2] =\u003e 3376 [3] =\u003e 3702 [4] =\u003e 3961 [5] =\u003e 4139 [6] =\u003e 4644 [7] =\u003e 5032 [8] =\u003e 5803 [9] =\u003e 6450 ) ","date":"2018-04-17","objectID":"/posts/php-quick-sort/:3:1","tags":["PHP"],"title":"PHP 快速排序","uri":"/posts/php-quick-sort/"},{"categories":["PHP"],"content":"方案二 使用 Lomuto partition scheme 方式 \u003c?php class QuickSort { /** * 主运行方法 * * @return void */ public static function main(): void { $random = self::random(); $array = self::sort($random, 0, count($random) - 1); print_r($array); } /** * 快速排序 * * @param array $array * @param int $low * @param int $high * * @return array */ public static function sort(array \u0026$array, int $low, int $high): array { if ($low \u003c $high) { $index = self::partition($array, $low, $high); self::sort($array, $low, $index - 1); self::sort($array, $index + 1, $high); } return $array; } /** * 原地分区 * * @param array $array * @param int $low * @param int $high * * @return int */ private static function partition(array \u0026$array, int $low, int $high): int { $pivot = $array[$high]; // 选取最右边的元素为基准 $i = $low - 1; for ($j = $low; $j \u003c $high; $j++) { if (self::compare($pivot, $array[$j]) \u003e 0) { $i++; self::swap($array[$i], $array[$j]); } } self::swap($array[$i + 1], $array[$high]); return $i + 1; } /** * 比较大小 * * @param int $x * @param int $y * * @return int */ private static function compare(int $x, int $y): int { return $x \u003c=\u003e $y; } /** * 互换位置 * * @param int $x * @param int $y * * @return void */ private static function swap(int \u0026$x, int \u0026$y): void { if ($x !== $y) { $t = $x; $x = $y; $y = $t; } } /** * 生成随机数组 * * @param int $low * @param int $high * @param int $num * * @return array */ private static function random(int $low = 1, int $high = 9999, int $num = 10): array { $num = $num \u003e $high ? $high : $num; $range = range($low, $high); $array = array_rand(array_flip($range), $num); shuffle($array); return $array; } } QuickSort::main(); // 结果 Array ( [0] =\u003e 1411 [1] =\u003e 3434 [2] =\u003e 3776 [3] =\u003e 6020 [4] =\u003e 6047 [5] =\u003e 6367 [6] =\u003e 7107 [7] =\u003e 7783 [8] =\u003e 9135 [9] =\u003e 9248 ) ","date":"2018-04-17","objectID":"/posts/php-quick-sort/:3:2","tags":["PHP"],"title":"PHP 快速排序","uri":"/posts/php-quick-sort/"},{"categories":["PHP"],"content":"方案三 使用 Hoare partition scheme 方式 未完待续… ","date":"2018-04-17","objectID":"/posts/php-quick-sort/:3:3","tags":["PHP"],"title":"PHP 快速排序","uri":"/posts/php-quick-sort/"},{"categories":["MySQL"],"content":"前段时间在 Vagrant 中安装了 CentOS 7.2 系统，然后部署了一套 lnmp 环境，数据库安装了 MariaDB 10.3.4，安装完成后，随机生成了一个 MariaDB 密码，后来就把这事给忘了。今天闲来无事，准备导入一些数据时悲剧了。密码早就忘的一干二净了，唉，郁闷呀，于是就想起来重置一下密码。 MySQL 数据类型 MySQL 用户管理 MySQL 关键字查询 MySQL 字符串函数 MySQL 字符串连接函数 MySQL 忘记 root 密码后重置 MySQL 最值查询 MySQL 日期时间函数 MySQL 联合查询 MySQL 查询当前年、季、月、周的第一天和最后一天 MySQL 支持 emoji 图标的设置 MySQL 存储引擎 MySQL 隔离级别及其脏读不可重复读幻读 ","date":"2018-04-15","objectID":"/posts/mysql-reset-root-password/:0:0","tags":["MySQL"],"title":"MySQL 忘记 root 密码后进行重置","uri":"/posts/mysql-reset-root-password/"},{"categories":["MySQL"],"content":"具体操作 ","date":"2018-04-15","objectID":"/posts/mysql-reset-root-password/:1:0","tags":["MySQL"],"title":"MySQL 忘记 root 密码后进行重置","uri":"/posts/mysql-reset-root-password/"},{"categories":["MySQL"],"content":"停止服务 // 停止 MariaDB 服务 $ sudo systemctl stop mariadb.service ","date":"2018-04-15","objectID":"/posts/mysql-reset-root-password/:1:1","tags":["MySQL"],"title":"MySQL 忘记 root 密码后进行重置","uri":"/posts/mysql-reset-root-password/"},{"categories":["MySQL"],"content":"添加配置 在 MariaDB 的配置文件中 [mysqld] 后面添加如下两项配置： $ sudo vim /etc/my.cnf.d/server.cnf [mysqld] ... skip-grant-tables skip-networking 信息 skip-grant-tables: 此选项允许任何人不需密码登陆 MariaDB 数据库并且拥有所有特权，但是它禁止了账户管理命令如：ALTER USER，SET PASSWORD skip-networking: 此选项不允许远程客户端连接数据库 ","date":"2018-04-15","objectID":"/posts/mysql-reset-root-password/:1:2","tags":["MySQL"],"title":"MySQL 忘记 root 密码后进行重置","uri":"/posts/mysql-reset-root-password/"},{"categories":["MySQL"],"content":"启动服务 // 启动 MariaDB 服务 $ sudo systemctl start mariadb.service ","date":"2018-04-15","objectID":"/posts/mysql-reset-root-password/:1:3","tags":["MySQL"],"title":"MySQL 忘记 root 密码后进行重置","uri":"/posts/mysql-reset-root-password/"},{"categories":["MySQL"],"content":"使用客户端连接数据库服务器 $ mysql -uroot Welcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 8 Server version: 10.3.4-MariaDB MariaDB Server Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. MariaDB [(none)]\u003e ","date":"2018-04-15","objectID":"/posts/mysql-reset-root-password/:1:4","tags":["MySQL"],"title":"MySQL 忘记 root 密码后进行重置","uri":"/posts/mysql-reset-root-password/"},{"categories":["MySQL"],"content":"修改密码 MariaDB [(none)]\u003e USE mysql; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed MariaDB [mysql]\u003e UPDATE user SET password=PASSWORD('your password') \\ -\u003e WHERE User='root'; Query OK, 0 rows affected (0.000 sec) Rows matched: 3 Changed: 0 Warnings: 0 MariaDB [mysql]\u003e FLUSH PRIVILEGES; Query OK, 0 rows affected (0.000 sec) MariaDB [mysql]\u003e exit; ","date":"2018-04-15","objectID":"/posts/mysql-reset-root-password/:1:5","tags":["MySQL"],"title":"MySQL 忘记 root 密码后进行重置","uri":"/posts/mysql-reset-root-password/"},{"categories":["MySQL"],"content":"移除配置并重启服务 将刚才添加的配置从配置文件移除掉 $ sudo systemctl restart mariadb.service ","date":"2018-04-15","objectID":"/posts/mysql-reset-root-password/:1:6","tags":["MySQL"],"title":"MySQL 忘记 root 密码后进行重置","uri":"/posts/mysql-reset-root-password/"},{"categories":["MySQL"],"content":"测试登录 $ mysql -uroot -p Enter password: Welcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 10 Server version: 10.3.4-MariaDB MariaDB Server Copyright (c) 2000, 2017, Oracle, MariaDB Corporation Ab and others. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. MariaDB [(none)]\u003e ","date":"2018-04-15","objectID":"/posts/mysql-reset-root-password/:1:7","tags":["MySQL"],"title":"MySQL 忘记 root 密码后进行重置","uri":"/posts/mysql-reset-root-password/"},{"categories":["MySQL"],"content":"参考 How to Reset the Root Password SET PASSWORD ","date":"2018-04-15","objectID":"/posts/mysql-reset-root-password/:2:0","tags":["MySQL"],"title":"MySQL 忘记 root 密码后进行重置","uri":"/posts/mysql-reset-root-password/"},{"categories":["PHP"],"content":"插入排序是一种较为简单的排序算法，它的基本思想是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。为此有人形象的把插入排序比拟为打扑克抓牌的过程，通常我们右手抓牌，没抓一张牌，就放到左手，抓下一张牌后，会把这张牌依次与左手上的牌比较，并把它插入到一个合适的位置（按牌面大小），这个比拟实在是太牛逼了。 ","date":"2018-04-14","objectID":"/posts/php-insertion-sort/:0:0","tags":["PHP"],"title":"PHP 插入排序","uri":"/posts/php-insertion-sort/"},{"categories":["PHP"],"content":"概念 插入排序 - Insertion Sort：是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 O(1) 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 ","date":"2018-04-14","objectID":"/posts/php-insertion-sort/:1:0","tags":["PHP"],"title":"PHP 插入排序","uri":"/posts/php-insertion-sort/"},{"categories":["PHP"],"content":"步骤 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤 2~5 ","date":"2018-04-14","objectID":"/posts/php-insertion-sort/:2:0","tags":["PHP"],"title":"PHP 插入排序","uri":"/posts/php-insertion-sort/"},{"categories":["PHP"],"content":"实现 ","date":"2018-04-14","objectID":"/posts/php-insertion-sort/:3:0","tags":["PHP"],"title":"PHP 插入排序","uri":"/posts/php-insertion-sort/"},{"categories":["PHP"],"content":"方案一 \u003c?php class InsertionSort { /** * 主运行方法 * * @return void */ public static function main(): void { $random = self::random(); $array = self::sort($random); print_r($array); } /** * 插入排序 * * @param array $array * * @return array */ public static function sort(array \u0026$array): array { $count = count($array) - 1; for ($i = 0; $i \u003c $count; $i++) { for ($j = $i; $j \u003e= 0; $j--) { if (self::compare($array[$j], $array[$j + 1]) \u003e 0) { self::swap($array[$j], $array[$j + 1]); } else { break; } } } return $array; } /** * 比较大小 * * @param int $x * @param int $y * * @return int */ private static function compare(int $x, int $y): int { return $x \u003c=\u003e $y; } /** * 互换位置 * * @param int $x * @param int $y * * @return void */ private static function swap(int \u0026$x, int \u0026$y): void { if ($x !== $y) { $t = $x; $x = $y; $y = $t; } } /** * 生成随机数组 * * @param int $low * @param int $high * @param int $num * * @return array */ private static function random(int $low = 1, int $high = 9999, int $num = 10): array { $num = $num \u003e $high ? $high : $num; $range = range($low, $high); $array = array_rand(array_flip($range), $num); shuffle($array); return $array; } } InsertionSort::main(); // 结果 Array ( [0] =\u003e 84 [1] =\u003e 1841 [2] =\u003e 3900 [3] =\u003e 4762 [4] =\u003e 5708 [5] =\u003e 5938 [6] =\u003e 6136 [7] =\u003e 6148 [8] =\u003e 6228 [9] =\u003e 9207 ) ","date":"2018-04-14","objectID":"/posts/php-insertion-sort/:3:1","tags":["PHP"],"title":"PHP 插入排序","uri":"/posts/php-insertion-sort/"},{"categories":["PHP"],"content":"方案二 \u003c?php class InsertionSort { /** * 主运行方法 * * @return void */ public static function main(): void { $random = self::random(); $array = self::sort($random); print_r($array); } /** * 插入排序 * * @param array $array * * @return array */ public static function sort(array \u0026$array): array { $count = count($array) - 1; for ($i = 0; $i \u003c $count; $i++) { if (self::compare($array[$i], $array[$i + 1]) \u003e 0) { $pivot = $array[$i + 1]; for ($j = $i; $j \u003e= 0 \u0026\u0026 $array[$j] \u003e $pivot; $j--) { $array[$j + 1] = $array[$j]; } $array[$j + 1] = $pivot; } } return $array; } /** * 比较大小 * * @param int $x * @param int $y * * @return int */ private static function compare(int $x, int $y): int { return $x \u003c=\u003e $y; } /** * 互换位置 * * @param int $x * @param int $y * * @return void */ private static function swap(int \u0026$x, int \u0026$y): void { if ($x !== $y) { $t = $x; $x = $y; $y = $t; } } /** * 生成随机数组 * * @param int $low * @param int $high * @param int $num * * @return array */ private static function random(int $low = 1, int $high = 9999, int $num = 10): array { $num = $num \u003e $high ? $high : $num; $range = range($low, $high); $array = array_rand(array_flip($range), $num); shuffle($array); return $array; } } InsertionSort::main(); // 结果 Array ( [0] =\u003e 133 [1] =\u003e 161 [2] =\u003e 393 [3] =\u003e 1273 [4] =\u003e 1274 [5] =\u003e 2041 [6] =\u003e 5046 [7] =\u003e 7325 [8] =\u003e 7950 [9] =\u003e 9988 ) ","date":"2018-04-14","objectID":"/posts/php-insertion-sort/:3:2","tags":["PHP"],"title":"PHP 插入排序","uri":"/posts/php-insertion-sort/"},{"categories":["PHP"],"content":"方案三 \u003c?php class InsertionSort { /** * 主运行方法 * * @return void */ public static function main(): void { $random = self::random(); $array = self::sort($random); print_r($array); } /** * 插入排序 * * @param array $array * * @return array */ public static function sort(array \u0026$array): array { $count = count($array) - 1; for ($i = 0; $i \u003c $count; $i++) { for ($j = $i; $j \u003e= 0 \u0026\u0026 self::compare($array[$j], $array[$j + 1]) \u003e 0; $j--) { self::swap($array[$j], $array[$j + 1]); } } return $array; } /** * 比较大小 * * @param int $x * @param int $y * * @return int */ private static function compare(int $x, int $y): int { return $x \u003c=\u003e $y; } /** * 互换位置 * * @param int $x * @param int $y * * @return void */ private static function swap(int \u0026$x, int \u0026$y): void { if ($x !== $y) { $t = $x; $x = $y; $y = $t; } } /** * 生成随机数组 * * @param int $low * @param int $high * @param int $num * * @return array */ private static function random(int $low = 1, int $high = 9999, int $num = 10): array { $num = $num \u003e $high ? $high : $num; $range = range($low, $high); $array = array_rand(array_flip($range), $num); shuffle($array); return $array; } } InsertionSort::main(); // 结果 Array ( [0] =\u003e 57 [1] =\u003e 896 [2] =\u003e 2172 [3] =\u003e 3428 [4] =\u003e 4236 [5] =\u003e 4844 [6] =\u003e 6524 [7] =\u003e 7586 [8] =\u003e 8172 [9] =\u003e 8650 ) ","date":"2018-04-14","objectID":"/posts/php-insertion-sort/:3:3","tags":["PHP"],"title":"PHP 插入排序","uri":"/posts/php-insertion-sort/"},{"categories":["PHP"],"content":"冒泡排序是几乎是面试和稍懂点算法以及资深人士的口头禅，身为程序员，你要是不知道这个排序，就会被严重鄙视的。笔者以前也不会这个排序，更不知道这个排序有什么卵用，但听那么多高手和大牛说这些基础很重要，也就硬着头皮啃了，毕竟多学习一丁点东西，总归没什么害处。 ","date":"2018-04-14","objectID":"/posts/php-bubble-sort/:0:0","tags":["PHP"],"title":"PHP - 冒泡排序","uri":"/posts/php-bubble-sort/"},{"categories":["PHP"],"content":"概念 冒泡排序 - Bubble Sort：是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢『浮』到数列的顶端。 ","date":"2018-04-14","objectID":"/posts/php-bubble-sort/:1:0","tags":["PHP"],"title":"PHP - 冒泡排序","uri":"/posts/php-bubble-sort/"},{"categories":["PHP"],"content":"步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数 针对所有的元素重复以上的步骤，除了最后一个 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较 ","date":"2018-04-14","objectID":"/posts/php-bubble-sort/:2:0","tags":["PHP"],"title":"PHP - 冒泡排序","uri":"/posts/php-bubble-sort/"},{"categories":["PHP"],"content":"实现 ","date":"2018-04-14","objectID":"/posts/php-bubble-sort/:3:0","tags":["PHP"],"title":"PHP - 冒泡排序","uri":"/posts/php-bubble-sort/"},{"categories":["PHP"],"content":"方案一 \u003c?php class BubbleSort { /** * 主运行方法 * * @return void */ public static function main(): void { $random = self::random(); $array = self::sort($random); print_r($array); } /** * 冒泡排序 * * @param array $array * * @return array */ public static function sort(array \u0026$array): array { $count = count($array); for ($i = 0; $i \u003c $count; $i++) { for ($j = 0; $j \u003c $count - $i - 1; $j++) { if (self::compare($array[$j], $array[$j + 1]) \u003e 0) { self::swap($array[$j], $array[$j + 1]); } } } return $array; } /** * 比较大小 * * @param int $x * @param int $y * * @return int */ private static function compare(int $x, int $y): int { return $x \u003c=\u003e $y; } /** * 互换位置 * * @param int $x * @param int $y * * @return void */ private static function swap(int \u0026$x, int \u0026$y): void { if ($x !== $y) { $x ^= $y; $y ^= $x; $x ^= $y; } } /** * 生成随机数组 * * @param int $low * @param int $high * @param int $num * * @return array */ private static function random(int $low = 1, int $high = 9999, int $num = 10): array { $num = $num \u003e $high ? $high : $num; $range = range($low, $high); $array = array_rand(array_flip($range), $num); shuffle($array); return $array; } } BubbleSort::main(); // 结果 Array ( [0] =\u003e 9 [1] =\u003e 656 [2] =\u003e 755 [3] =\u003e 879 [4] =\u003e 3578 [5] =\u003e 3812 [6] =\u003e 5139 [7] =\u003e 6412 [8] =\u003e 8804 [9] =\u003e 9458 ) ","date":"2018-04-14","objectID":"/posts/php-bubble-sort/:3:1","tags":["PHP"],"title":"PHP - 冒泡排序","uri":"/posts/php-bubble-sort/"},{"categories":["PHP"],"content":"方案二 标志变量用于记录每趟冒泡排序是否发生数据元素位置交换。如果没有发生交换，说明序列已经有序了，不必继续进行下去了 \u003c?php class BubbleSort { /** * 主运行方法 * * @return void */ public static function main(): void { $random = self::random(100, 200); $array = self::sort($random); print_r($array); } /** * 冒泡排序 * * @param array $array * * @return array */ public static function sort(array \u0026$array): array { $count = count($array); $isSwapped = true; for ($i = 0; $i \u003c $count \u0026\u0026 $isSwapped === true; $i++) { $isSwapped = false; for ($j = 0; $j \u003c $count - $i - 1; $j++) { if (self::compare($array[$j], $array[$j + 1]) \u003e 0) { self::swap($array[$j], $array[$j + 1]); $isSwapped = true; } } } return $array; } /** * 比较大小 * * @param int $x * @param int $y * * @return int */ private static function compare(int $x, int $y): int { return $x \u003c=\u003e $y; } /** * 互换位置 * * @param int $x * @param int $y * * @return void */ private static function swap(int \u0026$x, int \u0026$y): void { if ($x !== $y) { $t = $x; $x = $y; $y = $t; } } /** * 生成随机数组 * * @param int $low * @param int $high * @param int $num * * @return array */ private static function random(int $low = 1, int $high = 9999, int $num = 10): array { $num = $num \u003e $high ? $high : $num; $range = range($low, $high); $array = array_rand(array_flip($range), $num); shuffle($array); return $array; } } BubbleSort::main(); // 结果 Array ( [0] =\u003e 129 [1] =\u003e 140 [2] =\u003e 141 [3] =\u003e 150 [4] =\u003e 152 [5] =\u003e 159 [6] =\u003e 165 [7] =\u003e 175 [8] =\u003e 191 [9] =\u003e 199 ) ","date":"2018-04-14","objectID":"/posts/php-bubble-sort/:3:2","tags":["PHP"],"title":"PHP - 冒泡排序","uri":"/posts/php-bubble-sort/"},{"categories":["PHP"],"content":"方案三 技巧 鸡尾酒排序 - Cocktail Sort：也就是定向冒泡排序，鸡尾酒搅拌排序，搅拌排序（也可以视作选择排序的一种变形），涟漪排序，来回排序或快乐小时排序，是冒泡排序的一种变形。此算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。 \u003c?php class CocktailSort { /** * 主运行方法 * * @return void */ public static function main(): void { $random = self::random(); $array = self::sort($random); print_r($array); } /** * 鸡尾酒排序 * * @param array $array * * @return array */ public static function sort(array \u0026$array): array { $left = 0; $right = count($array) - 1; while ($left \u003c $right) { for ($j = $left; $j \u003c $right; $j++) { if (self::compare($array[$j], $array[$j + 1]) \u003e 0) { self::swap($array[$j], $array[$j + 1]); } } $right--; for ($j = $right; $j \u003e $left; $j--) { if (self::compare($array[$j], $array[$j + 1]) \u003e 0) { self::swap($array[$j], $array[$j + 1]); } } $left++; } return $array; } /** * 比较大小 * * @param int $x * @param int $y * * @return int */ private static function compare(int $x, int $y): int { return $x \u003c=\u003e $y; } /** * 互换位置 * * @param int $x * @param int $y * * @return void */ private static function swap(int \u0026$x, int \u0026$y): void { if ($x !== $y) { $t = $x; $x = $y; $y = $t; } } /** * 生成随机数组 * * @param int $low * @param int $high * @param int $num * * @return array */ private static function random(int $low = 1, int $high = 9999, int $num = 10): array { $num = $num \u003e $high ? $high : $num; $range = range($low, $high); $array = array_rand(array_flip($range), $num); shuffle($array); return $array; } } CocktailSort::main(); // 结果 Array ( [0] =\u003e 4596 [1] =\u003e 2439 [2] =\u003e 3177 [3] =\u003e 3424 [4] =\u003e 6605 [5] =\u003e 6629 [6] =\u003e 7526 [7] =\u003e 8666 [8] =\u003e 8854 [9] =\u003e 9986 ) ","date":"2018-04-14","objectID":"/posts/php-bubble-sort/:3:3","tags":["PHP"],"title":"PHP - 冒泡排序","uri":"/posts/php-bubble-sort/"},{"categories":["PHP"],"content":"日期函数在平时的开发中用的比较广泛，尤其是 date() 函数，强大到让人窒息，其格式之多让人目眩。这里我也只能管中窥豹了，更多的用法请参看官方文档。 函数 date 可识别的格式 这里我无耻的抄了一遍手册，不为别的，就是加强一下自己的记忆，见笑了。 ","date":"2018-04-13","objectID":"/posts/php-date-calculation/:0:0","tags":["PHP"],"title":"PHP - 日期相关计算","uri":"/posts/php-date-calculation/"},{"categories":["PHP"],"content":"时间格式 格式 说明 返回值 a 小写的上午和下午值 am 或 pm A 大写的上午和下午值 AM 或 PM B Swatch Internet 标准时 000 到 999 g 小时，12 小时格式，没有前导零 1 到 12 G 小时，24 小时格式，没有前导零 0 到 23 h 小时，12 小时格式，有前导零 01 到 12 H 小时，24 小时格式，有前导零 00 到 23 i 有前导零的分钟数 00 到 59\u003e s 秒数，有前导零 00 到 59\u003e u 毫秒（PHP 5.2.2 新加）。需要注意的是 date() 函数总是返回 000000 因为它只接受 integer 参数，而 DateTime::format() 才支持毫秒 示例: 654321 \u003c?php $time = strtotime('2020-06-01 12:59:59'); $array = [ 'a' =\u003e date('a', $time), 'A' =\u003e date('A', $time), 'B' =\u003e date('B', $time), 'g' =\u003e date('g', $time), 'G' =\u003e date('G', $time), 'h' =\u003e date('h', $time), 'H' =\u003e date('H', $time), 'i' =\u003e date('i', $time), 's' =\u003e date('s', $time), 'u' =\u003e date('u', $time), ]; print_r($array); // 结果 Array ( [a] =\u003e pm [A] =\u003e PM [B] =\u003e 249 [g] =\u003e 12 [G] =\u003e 12 [h] =\u003e 12 [H] =\u003e 12 [i] =\u003e 59 [s] =\u003e 59 [u] =\u003e 000000 ) ","date":"2018-04-13","objectID":"/posts/php-date-calculation/:1:0","tags":["PHP"],"title":"PHP - 日期相关计算","uri":"/posts/php-date-calculation/"},{"categories":["PHP"],"content":"时区格式 格式 说明 返回值 e 时区标识（PHP 5.1.0 新加） 例如：UTC，GMT，Atlantic/Azores I 是否为夏令时 如果是夏令时为 1，否则为 0 O 与格林威治时间相差的小时数 例如：+0200 P 与格林威治时间（GMT）的差别，小时和分钟之间有冒号分隔（PHP 5.1.3 新加） 例如：+02:00 T 本机所在的时区 例如：EST，MDT（在 Windows 下为完整文本格式，例如：Eastern Standard Time，中文版会显示『中国标准时间』） Z 时差偏移量的秒数。UTC 西边的时区偏移量总是负的，UTC 东边的时区偏移量总是正的 -43200 到 43200 \u003c?php $time = strtotime('2020-06-01 12:59:59'); $array = [ 'e' =\u003e date('e', $time), 'I' =\u003e date('I', $time), 'O' =\u003e date('O', $time), 'P' =\u003e date('P', $time), 'T' =\u003e date('T', $time), ]; print_r($array); // 结果 Array ( [e] =\u003e PRC [I] =\u003e 0 [O] =\u003e +0800 [P] =\u003e +08:00 [T] =\u003e CST ) ","date":"2018-04-13","objectID":"/posts/php-date-calculation/:2:0","tags":["PHP"],"title":"PHP - 日期相关计算","uri":"/posts/php-date-calculation/"},{"categories":["PHP"],"content":"日期时间格式 格式 说明 返回值 c ISO 8601 格式的日期（PHP 5 新加） 2004-02-12T15:19:21+00:00 r RFC 822 格式的日期 例如：Thu, 21 Dec 2000 16:01:07 +0200 U 从 Unix 纪元（January 1 1970 00:00:00 GMT）开始至今的秒数 参见 time() \u003c?php $time = strtotime('2020-06-01 12:59:59'); $array = [ 'c' =\u003e date('c', $time), 'r' =\u003e date('r', $time), 'U' =\u003e date('U', $time), ]; print_r($array); // 结果 Array ( [c] =\u003e 2020-06-01T12:59:59+08:00 [r] =\u003e Mon, 01 Jun 2020 12:59:59 +0800 [U] =\u003e 1590987599 ) ","date":"2018-04-13","objectID":"/posts/php-date-calculation/:3:0","tags":["PHP"],"title":"PHP - 日期相关计算","uri":"/posts/php-date-calculation/"},{"categories":["PHP"],"content":"日格式 格式 说明 返回值 d 月份中的第几天，有前导零的 2 位数字 01 到 31 D 星期中的第几天，文本表示，3 个字母 Mon 到 Sun j 月份中的第几天，没有前导零 1 到 31 l 星期几，完整的文本格式 Sunday 到 Saturday N ISO-8601 格式数字表示的星期中的第几天（PHP 5.1.0 新加） 1（表示星期一）到 7（表示星期天） S 每月天数后面的英文后缀，2 个字符 st，nd，rd 或者 th。可以和 j 一起用 w 星期中的第几天，数字表示 0（表示星期天）到 6（表示星期六） z 年份中的第几天 0 到 365 \u003c?php $time = strtotime('2020-06-01 12:59:59'); $array = [ 'd' =\u003e date('d', $time), 'D' =\u003e date('D', $time), 'j' =\u003e date('j', $time), 'l' =\u003e date('l', $time), 'N' =\u003e date('N', $time), 'S' =\u003e date('S', $time), 'w' =\u003e date('w', $time), 'z' =\u003e date('z', $time), ]; print_r($array); // 结果 Array ( [d] =\u003e 01 [D] =\u003e Mon [j] =\u003e 1 [l] =\u003e Monday [N] =\u003e 1 [S] =\u003e st [w] =\u003e 1 [z] =\u003e 152 ) ","date":"2018-04-13","objectID":"/posts/php-date-calculation/:4:0","tags":["PHP"],"title":"PHP - 日期相关计算","uri":"/posts/php-date-calculation/"},{"categories":["PHP"],"content":"星期格式 格式 说明 返回值 W ISO-8601 格式年份中的第几周，每周从星期一开始（PHP 4.1.0 新加的） 例如：42（当年的第 42 周） \u003c?php $time = strtotime('2020-06-01 12:59:59'); $array = [ 'W' =\u003e date('W', $time), ]; print_r($array); // 结果 Array ( [W] =\u003e 23 ) ","date":"2018-04-13","objectID":"/posts/php-date-calculation/:5:0","tags":["PHP"],"title":"PHP - 日期相关计算","uri":"/posts/php-date-calculation/"},{"categories":["PHP"],"content":"月格式 格式 说明 返回值 F 月份，完整的文本格式，例如 January 或者 March January 到 December m 数字表示的月份，有前导零 01 到 12 M 三个字母缩写表示的月份 Jan 到 Dec n 数字表示的月份，没有前导零 1 到 12 t 指定的月份有几天 28 到 31 \u003c?php $time = strtotime('2020-06-01 12:59:59'); $array = [ 'F' =\u003e date('F', $time), 'm' =\u003e date('m', $time), 'M' =\u003e date('M', $time), 'n' =\u003e date('n', $time), 't' =\u003e date('t', $time), ]; print_r($array); // 结果 Array ( [F] =\u003e June [m] =\u003e 06 [M] =\u003e Jun [n] =\u003e 6 [t] =\u003e 30 ) ","date":"2018-04-13","objectID":"/posts/php-date-calculation/:6:0","tags":["PHP"],"title":"PHP - 日期相关计算","uri":"/posts/php-date-calculation/"},{"categories":["PHP"],"content":"年格式 格式 说明 返回值 L 是否为闰年 如果是闰年为 1，否则为 0 o ISO-8601 格式年份数字。这和 Y 的值相同，只除了如果 ISO 的星期数（W）属于前一年或下一年，则用那一年。（PHP 5.1.0 新加） 例如：1999 or 2003 Y 4 位数字完整表示的年份 例如：1999 或 2003 y 2 位数字表示的年份 例如：99 或 03 \u003c?php $time = strtotime('2020-06-01 12:59:59'); $array = [ 'L' =\u003e date('L', $time), 'o' =\u003e date('o', $time), 'Y' =\u003e date('Y', $time), 'y' =\u003e date('y', $time), ]; print_r($array); // 结果 Array ( [L] =\u003e 1 [o] =\u003e 2020 [Y] =\u003e 2020 [y] =\u003e 20 ) 计算指定日期时间 ","date":"2018-04-13","objectID":"/posts/php-date-calculation/:7:0","tags":["PHP"],"title":"PHP - 日期相关计算","uri":"/posts/php-date-calculation/"},{"categories":["PHP"],"content":"当前日期时间的相对计算 \u003c?php date_default_timezone_set('PRC'); $array = [ '当前日期时间' =\u003e date('Y-m-d H:i:s'), '前一天的此时日期时间' =\u003e date('Y-m-d H:i:s', strtotime('-1 day')), '后一天的此时日期时间' =\u003e date('Y-m-d H:i:s', strtotime('+1 day')), '上一个月的此时日期时间' =\u003e date('Y-m-d H:i:s', strtotime('-1 month')), '下一个月的此时日期时间' =\u003e date('Y-m-d H:i:s', strtotime('+1 month')), '加 1 月 2 周 3 天 4 时 5 分 6 秒的此时日期时间' =\u003e date('Y-m-d H:i:s', strtotime('+1 month +2 weeks +3 days +4 hours +5 minutes +6 seconds')), ]; print_r($array); // 结果 Array ( [当前日期时间] =\u003e 2018-04-13 21:24:30 [前一天的此时日期时间] =\u003e 2018-04-12 21:24:30 [后一天的此时日期时间] =\u003e 2018-04-14 21:24:30 [上一个月的此时日期时间] =\u003e 2018-03-13 21:24:30 [下一个月的此时日期时间] =\u003e 2018-05-13 21:24:30 [加 1 月 2 周 3 天 4 时 5 分 6 秒的此时日期时间] =\u003e 2018-05-31 01:29:36 ) ","date":"2018-04-13","objectID":"/posts/php-date-calculation/:8:0","tags":["PHP"],"title":"PHP - 日期相关计算","uri":"/posts/php-date-calculation/"},{"categories":["PHP"],"content":"起始结束日期时间的计算 \u003c?php date_default_timezone_set('PRC'); $array = [ '本周起始日期时间' =\u003e date('Y-m-d H:i:s', mktime(0, 0, 0, date('m'), date('d') - date('w') + 1 - 5, date('Y'))), '本周结束日期时间' =\u003e date('Y-m-d H:i:s', mktime(23, 59, 59, date('m'), date('d') - date('w') + 7 - 5, date('Y'))), '上月起始日期时间' =\u003e date('Y-m-d H:i:s', mktime(0, 0, 0, date('m') - 1, 1, date('Y'))), '上月结束日期时间' =\u003e date('Y-m-d H:i:s', mktime(23, 59, 59, date('m'), 0, date('Y'))), '本月起始日期时间' =\u003e date('Y-m-d H:i:s', mktime(0, 0, 0, date('m'), 1, date('Y'))), '本月结束日期时间' =\u003e date('Y-m-d H:i:s', mktime(23, 59, 59, date('m'), date('t'), date('Y'))), '下月起始日期时间' =\u003e date('Y-m-d H:i:s', mktime(0, 0, 0, date('m') + 1, 1, date('Y'))), '下月结束日期时间' =\u003e date('Y-m-d H:i:s', mktime(23, 59, 59, date('m') + 1, date('t') + 1, date('Y'))), ]; print_r($array); // 结果 Array ( [本周起始日期时间] =\u003e 2018-04-04 00:00:00 [本周结束日期时间] =\u003e 2018-04-10 23:59:59 [上月起始日期时间] =\u003e 2018-03-01 00:00:00 [上月结束日期时间] =\u003e 2018-03-31 23:59:59 [本月起始日期时间] =\u003e 2018-04-01 00:00:00 [本月结束日期时间] =\u003e 2018-04-30 23:59:59 [下月起始日期时间] =\u003e 2018-05-01 00:00:00 [下月结束日期时间] =\u003e 2018-05-31 23:59:59 ) ","date":"2018-04-13","objectID":"/posts/php-date-calculation/:9:0","tags":["PHP"],"title":"PHP - 日期相关计算","uri":"/posts/php-date-calculation/"},{"categories":["PHP"],"content":"PHP 当然也有自己的异常处理，不过那已经是 PHP5 以后的事了。就我自己这些年写程序的现状看，我基本上就没有真正明白什么是异常处理，经常把异常和错误处理混为一谈，关于代码中的那些写法，不是写错了，就是写的太特么烂了。恰好最近在写一些类时用到异常处理了，顺便就把这个整理下，但是这个仅代表我个人的一些理解和使用，也可能是错误的，还请谨慎阅读。 ","date":"2018-04-05","objectID":"/posts/php-error-exception-handler/:0:0","tags":["PHP"],"title":"PHP 中的错误和异常处理","uri":"/posts/php-error-exception-handler/"},{"categories":["PHP"],"content":"概述 ","date":"2018-04-05","objectID":"/posts/php-error-exception-handler/:1:0","tags":["PHP"],"title":"PHP 中的错误和异常处理","uri":"/posts/php-error-exception-handler/"},{"categories":["PHP"],"content":"错误处理定义 错误是指导致系统不能按照用户意图工作的一切原因、事件。在程序设计过程中，由于某些错误的存在，致使程序无法正常运行，处理这些错误以使程序正确运行就称为错误处理。错误处理功能是衡量编译器性能的重要方面，它在帮助程序员尽快修改程序方面起到了非常重要的作用。 错误类型： 语法错误 语义错误 逻辑错误 ","date":"2018-04-05","objectID":"/posts/php-error-exception-handler/:1:1","tags":["PHP"],"title":"PHP 中的错误和异常处理","uri":"/posts/php-error-exception-handler/"},{"categories":["PHP"],"content":"异常处理定义 编程语言或计算机硬件里的一种机制，用于处理软件或信息系统中出现的异常状况（即超出程序正常执行流程的某些特殊条件） ","date":"2018-04-05","objectID":"/posts/php-error-exception-handler/:1:2","tags":["PHP"],"title":"PHP 中的错误和异常处理","uri":"/posts/php-error-exception-handler/"},{"categories":["PHP"],"content":"预定义的错误代码 当然你也可以参见官网的手册 预定义常量，我抄一遍纯粹是为了加深记忆。至于每种错误在什么情况下产生，你可以参看 PHP的错误机制总结。 常量 取值 说明 备注 E_ERROR 1 致命的运行时错误。这类错误一般是不可恢复的情况，例如内存分配导致的问题。后果是导致脚本终止不再继续运行 E_WARNING 2 运行时警告（非致命错误）。仅给出提示信息，但是脚本不会终止运行 E_PARSE 4 编译时语法解析错误。解析错误仅仅由分析器产生 E_NOTICE 8 运行时通知。表示脚本遇到可能会表现为错误的情况，但是在可以正常运行的脚本里面也可能会有类似的通知 E_CORE_ERROR 16 在 PHP 初始化启动过程中发生的致命错误。该错误类似 E_ERROR，但是是由 PHP 引擎核心产生的 since PHP 4 E_CORE_WARNING 32 PHP 初始化启动过程中发生的警告（非致命错误）。类似 E_WARNING，但是是由 PHP 引擎核心产生的 since PHP 4 E_COMPILE_ERROR 64 致命编译时错误。类似 E_ERROR，但是是由 Zend 脚本引擎产生的 since PHP 4 E_COMPILE_WARNING 128 编译时警告（非致命错误）。类似 E_WARNING，但是是由 Zend 脚本引擎产生的 since PHP 4 E_USER_ERROR 256 用户产生的错误信息。类似 E_ERROR，但是是由用户自己在代码中使用 PHP 函数 trigger_error() 来产生的 since PHP 4 E_USER_WARNING 512 用户产生的警告信息。类似 E_WARNING，但是是由用户自己在代码中使用 PHP 函数 trigger_error() 来产生的 since PHP 4 E_USER_NOTICE 1024 用户产生的通知信息。类似 E_NOTICE，但是是由用户自己在代码中使用 PHP 函数 trigger_error() 来产生的 since PHP 4 E_STRICT 2048 启用 PHP 对代码的修改建议，以确保代码具有最佳的互操作性和向前兼容性 since PHP 5 E_RECOVERABLE_ERROR 4096 可被捕捉的致命错误。它表示发生了一个可能非常危险的错误，但是还没有导致 PHP 引擎处于不稳定的状态。如果该错误没有被用户自定义句柄捕获（参见 set_error_handler()），将成为一个 E_ERROR　从而脚本会终止运行 since PHP 5.2.0 E_DEPRECATED 8192 运行时通知。启用后将会对在未来版本中可能无法正常工作的代码给出警告 since PHP 5.3.0 E_USER_DEPRECATED 16384 用户产少的警告信息。类似 E_DEPRECATED，但是是由用户自己在代码中使用 PHP 函数 trigger_error() 来产生的 since PHP 5.3.0 E_ALL 30719 E_STRICT 出外的所有错误和警告信息 30719 in PHP 5.3.x, 6143 in PHP 5.2.x, 2047 previously 警告 可以使用按位运算符来组合这些值或者屏蔽某些类型的错误。在 php.ini 之中，仅 |, ~, !, ^, \u0026 这些操作符会被正确解析 以下级别的错误不能由用户定义的函数来处理：E_ERROR、E_PARSE、E_CORE_ERROR、E_CORE_WARNING、E_COMPILE_ERROR、E_COMPILE_WARNING 和在调用 set_error_handler() 函数所在文件中产生的大多数 E_STRICT ","date":"2018-04-05","objectID":"/posts/php-error-exception-handler/:1:3","tags":["PHP"],"title":"PHP 中的错误和异常处理","uri":"/posts/php-error-exception-handler/"},{"categories":["PHP"],"content":"相关文章 深入理解PHP原理之异常机制 我们什么时候应该使用异常 PHP 最佳实践之异常和错误 Throwable Exceptions and Errors in PHP 7 早有人把 PHP 各个版本的错误和异常处理类树整理出来供我等参观。如果在本地执行此代码，依据本地对 PHP 安装的扩展的不同，会把扩展中的相关异常处理类一并打印出来 打印错误和异常处理类树代码 打印输出结果 ","date":"2018-04-05","objectID":"/posts/php-error-exception-handler/:1:4","tags":["PHP"],"title":"PHP 中的错误和异常处理","uri":"/posts/php-error-exception-handler/"},{"categories":["PHP"],"content":"错误处理 Note that other types of errors such as warnings and notices remain unchanged in PHP 7. Only fatal and recoverable errors throw exceptions. Prior to PHP 7 alpha-2, the exception hierarchy in PHP 7 was different. Fatal and recoverable errors threw instances of EngineException, which did not inherit from Exception. Both Exception and EngineException inherited from BaseException. The hierarchy was revised with the RFC I authored, Throwable Interface. I felt switching to Throwable and Error was important to avoid confusion from classes using the suffix Exception that did not extend Exception, as well as being more concise and appealing names. E_ERROR 和 E_RECOVERABLE_ERROR 级别的错误在 PHP7 之前是不能被捕获到的，也就是说，你无法使用 try...catch... 这样的语句捕获到这种级别的错误，但不管是 PHP7 还是 PHP5 对于未捕获的异常依然是一个致命错误 在 PHP5 中 \u003c?php $object = null; $object-\u003emethod(); // 结果 Fatal error: Call to a member function method() on null in 在 PHP7 中： \u003c?php $object = null; try { $object-\u003emethod(); } catch (Error $error) { echo $error-\u003egetMessage(); } // 结果 Call to a member function method() on null 是的，PHP7 内置了一个名为 Error 的类来捕获一些致命错误和异常了，其中 Error 和 Exception 类实现了 Throwable 接口。 // Throwable 接口 Throwable { /* Methods */ abstract public string getMessage ( void ) abstract public int getCode ( void ) abstract public string getFile ( void ) abstract public int getLine ( void ) abstract public array getTrace ( void ) abstract public string getTraceAsString ( void ) abstract public Throwable getPrevious ( void ) abstract public string __toString ( void ) } 警告 开发者不能直接实现 Throwable 接口，必须通过 Error 或者 Exception 等类去扩展 也可以用以下的方式去扩展自己的错误和异常类。 \u003c?php interface TestThrowable extends \\Throwable { } class TestException extends \\Exception implements TestThrowable { } class DemoError extends \\Error implements TestThrowable { } ","date":"2018-04-05","objectID":"/posts/php-error-exception-handler/:1:5","tags":["PHP"],"title":"PHP 中的错误和异常处理","uri":"/posts/php-error-exception-handler/"},{"categories":["PHP"],"content":"异常处理 由于 Error 和 Exception 都实现了 Throwable 接口，那么问题就来了，在程序中我们究竟要用哪个？通过一些最佳实践我们知道，错误一般是去约束程序员和代码语法、语义及逻辑方面的，而异常是程序在运行过程出现的一些不合期望的情况。因此，在代码中我们应当使用异常而不是错误。 PHP 7.2.0 - 7.2.3 版本中提供的内置异常： Exception ClosedGeneratorException DOMException ErrorException IntlException LogicException BadFunctionCallException BadMethodCallException DomainException InvalidArgumentException LengthException OutOfRangeException PharException ReflectionException RuntimeException OutOfBoundsException OverflowException PDOException RangeException UnderflowException UnexpectedValueException SodiumException 兼容 PHP5 和 PHP7 的异常处理 \u003c?php try { // Code that may throw an Exception or Error. } catch (Throwable $t) { // Executed only in PHP 7, will not match in PHP 5.x. } catch (Exception $e) { // Executed only in PHP 5.x, will not be reached in PHP 7. } ","date":"2018-04-05","objectID":"/posts/php-error-exception-handler/:2:0","tags":["PHP"],"title":"PHP 中的错误和异常处理","uri":"/posts/php-error-exception-handler/"},{"categories":["PHP"],"content":"自定义捕获错误和异常 未捕获的 Error 和 Exception 通过 set_exception_handler() 做后续清理和日志记录 其他错误仍然通过 set_error_handler() 来处理，在处理的时候使用更加明确的 E_* 类型，并抛出 ErrorException 记录调用栈 以下实例中使用 set_error_handler() 函数去捕获错误，设置一个用户自定义的错误处理函数，这里我就粗暴的抛出 了 ErrorException 异常，当然官方文档也明确说了这个函数不能捕获 E_ERROR、E_PARSE、E_CORE_ERROR、E_CORE_WARNING、E_COMPILE_ERROR、E_COMPILE_WARNING 和在调用 set_error_handler() 函数所在文件中产生的大多数 E_STRICT 异常，言外之语也就是仅能捕获用户定义的错误和异常。使用 set_exception_handler() 函数去设置默认的异常处理程序，用在没有用 try/catch 块来捕获的异常，也就是说不管你抛出的异常有没有人捕获，如果没有人捕获就会进入到该方法中，并且在回调函数调用后异常会中止。使用 register_shutdown_function() 函数去捕获 PHP 的错误：Fatal or Parse Error 等，正由于这个函数是 PHP 脚本执行结束前的最后一个有效调用，所以我们才用它来完成一些不可思议的事情。一般情况下，都会在这个函数的回调函数中使用 error_get_last() 函数来获取执行产生的错误，顺便说一下，像语法这样的错误是捕获不到的 正常情况时的异常捕获 \u003c?php class ErrorHandler { public static function register() { error_reporting(E_ALL); set_error_handler([__CLASS__, 'handleError']); set_exception_handler([__CLASS__, 'handleException']); register_shutdown_function([__CLASS__, 'handleShutdown']); } public static function handleError($code, $message, $file, $line) { throw new \\ErrorException($message, $code, 1, $file, $line); } public static function handleException($e) { self::handle($e); } public static function handleShutdown() { $error = error_get_last(); if (null !== $error \u0026\u0026 self::isFatal($error['type'])) { self::handleException($error); } } /** * @param \\Exception|\\Throwable $e */ public static function handle($e) { $message = $e-\u003egetMessage() . PHP_EOL; echo $message; error_log($message, 3, __DIR__ . '/run.log'); } protected static function isFatal($type): bool { $types = [E_ERROR, E_CORE_ERROR, E_COMPILE_ERROR, E_PARSE]; return in_array($type, $types, true); } } ErrorHandler::register(); $object = null; $object-\u003etoArray(); // 结果 Call to a member function toArray() on null 此时错误已经记录到日志文件中 写错语法时的异常捕获 \u003c?php // 此处略去 ErrorHandler 类代码，详见上面 ErrorHandler::register(); $object = null; // 这儿故意不写分号 $object-\u003etoArray() // 结果 PHP Parse error: syntax error, unexpected end of file in ... PHP PHP Dump $_SERVER PHP Parse error: syntax error, unexpected end of file in ... 事情进展到这里，按理来说，我应该就此停笔收尾，弄个总结之类的一忽悠一下正在阅读的你。但是呢，我又忽然想起来 PHP 那么多的框架是如何处理这个事情的，我想你也好奇，不妨我们去看看 ","date":"2018-04-05","objectID":"/posts/php-error-exception-handler/:2:1","tags":["PHP"],"title":"PHP 中的错误和异常处理","uri":"/posts/php-error-exception-handler/"},{"categories":["PHP"],"content":"框架中的错误异常处理 很遗憾的告诉你，我不会剖析框架源码，我只想做个 demo 得瑟一下，剩下全交给你。此处我以 symfony debug 为例 Symfony debug GitHub Symfony debug Docs // 安装 symfony/debug $ composer require symfony/debug \u003c?php require __DIR__ . '/vendor/autoload.php'; \\Symfony\\Component\\Debug\\Debug::enable(); \\Symfony\\Component\\Debug\\ErrorHandler::register(); $object = null; $object-\u003etoArray(); ","date":"2018-04-05","objectID":"/posts/php-error-exception-handler/:2:2","tags":["PHP"],"title":"PHP 中的错误和异常处理","uri":"/posts/php-error-exception-handler/"},{"categories":["PHP"],"content":"代码高亮一直以来是程序员的一项基本诉求，已成为各大编辑器、IDE 的标配。当然这个范围可以再扩大些，现在基本上有代码的地方就有代码高亮了，无论你在哪条船上。啥？不支持代码高亮，这不扯犊子吗？作为一个有点扯谈的程序员，我对没有代码语法高亮的这件事是坚决不能忍受的。 ","date":"2018-03-18","objectID":"/posts/php-highlight/:0:0","tags":["PHP"],"title":"PHP - 输出中的代码语法高亮","uri":"/posts/php-highlight/"},{"categories":["PHP"],"content":"内置的高亮函数 ","date":"2018-03-18","objectID":"/posts/php-highlight/:1:0","tags":["PHP"],"title":"PHP - 输出中的代码语法高亮","uri":"/posts/php-highlight/"},{"categories":["PHP"],"content":"字符串的语法高亮 语法高亮的相关配置： Name Default Range ignore_user_abort \"0\" PHP_INI_ALL highlight.string \"#DD0000\" PHP_INI_ALL highlight.comment \"#FF8000\" PHP_INI_ALL highlight.keyword \"#007700\" PHP_INI_ALL highlight.bg - Removed in PHP-5.4.0 \"#FFFFFF\" PHP_INI_ALL highlight.default #000000\" PHP_INI_ALL highlight.html \"#0000BB\" PHP_INI_ALL browscap NULL PHP_INI_SYSTEM 实例一： \u003c?php $string = ''; $string .= \"\u003c?php \\r\\n\\r\\n\"; $string .= \"echo 'hello world, hello highlight.';\\r\\n\\r\\n\"; $string .= \"\\$array = ['a', 'b', 'c', 'd', 'e'];\\r\\n\"; $string .= \"function pr(\\$vars)\\r\\n\"; $string .= \"{\\r\\n\"; $string .= \"\\tforeach (\\$vars as \\$key =\u003e \\$var) {\\r\\n\"; $string .= \"\\t\\tif (\\$key % 2 === 0) {\\r\\n\"; $string .= \"\\t\\t\\t\\$array[\\$key] = \\$var . '_test';\\r\\n\"; $string .= \"\\t\\t}\\r\\n\"; $string .= \"\\t}\\r\\n\"; $string .= \"}\\r\\n\"; $string .= 'pr($array);'; echo highlight_string($string, true); 实例二： \u003c?php echo highlight_text(file_get_contents('date.php')); function highlight_text($text) { ini_set('highlight.comment', '#546E78'); ini_set('highlight.default', '#DD7455'); ini_set('highlight.html', '#D56162; font-family: Courier; font-weight: bold'); ini_set('highlight.keyword', '#5083E6'); ini_set('highlight.string', '#C3E88D'); $text = trim($text); $text = highlight_string('\u003c?php ' . $text, true); $text = trim($text); // remove custom added \"\u003c?php \" $pattern = '|\u003cspan style=\"color: \\#[a-zA-Z0-9]{0,6}\"\u003e\u0026lt;\\?php\u0026nbsp;\u003c/span\u003e|'; $text = preg_replace($pattern, '', $text); return $text; } 实例三： \u003c?php highlight(); ?\u003e $string = '[ PHP 语法高亮大法好 ]'; \u003c?php highlight(); ?\u003e \u003c?php function highlight() { static $on = false; if (! $on) { ob_start(); } else { $buffer = \"\u003c?php\\n\" . ob_get_contents() . '?\u003e'; ob_end_clean(); highlight_string($buffer); } $on = ! $on; } `3` 行输出，我就懒的截图了。 ?\u003e ","date":"2018-03-18","objectID":"/posts/php-highlight/:1:1","tags":["PHP"],"title":"PHP - 输出中的代码语法高亮","uri":"/posts/php-highlight/"},{"categories":["PHP"],"content":"文件的语法高亮 \u003c?php highlight_file('date.php'); ","date":"2018-03-18","objectID":"/posts/php-highlight/:1:2","tags":["PHP"],"title":"PHP - 输出中的代码语法高亮","uri":"/posts/php-highlight/"},{"categories":["PHP"],"content":"扩展高亮支持 Syntax Highlighter supporting multiple languages, themes, fonts, highlighting from a URL, local file or post text A port of highlight.js by Ivan Sagalaev to PHP 这种插件比较多，这儿我选择 highlight.php，这款插件支持很多语言的代码高亮，按官方的说法，支持达 176 种语言，无论如何已经够用了。 ","date":"2018-03-18","objectID":"/posts/php-highlight/:2:0","tags":["PHP"],"title":"PHP - 输出中的代码语法高亮","uri":"/posts/php-highlight/"},{"categories":["PHP"],"content":"安装 // 安装 scrivo/highlight.php $ composer require scrivo/highlight.php ","date":"2018-03-18","objectID":"/posts/php-highlight/:2:1","tags":["PHP"],"title":"PHP - 输出中的代码语法高亮","uri":"/posts/php-highlight/"},{"categories":["PHP"],"content":"实例 \u003c?php require './vendor/autoload.php'; $highlight = new \\Highlight\\Highlighter(); $code = file_get_contents('date.php'); $object = $highlight-\u003ehighlight('php', $code); ?\u003e \u003chtml\u003e \u003chead\u003e \u003clink rel=\"stylesheet\" href=\"\u003c?= './vendor/scrivo/highlight.php/styles/monokai.css' ?\u003e\"\u003e \u003c/head\u003e \u003cbody\u003e \u003cpre class=\"hljs \u003c?= $object-\u003elanguage ?\u003e\"\u003e\u003c?= $object-\u003evalue ?\u003e\u003c/pre\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2018-03-18","objectID":"/posts/php-highlight/:2:2","tags":["PHP"],"title":"PHP - 输出中的代码语法高亮","uri":"/posts/php-highlight/"},{"categories":["PHP"],"content":"这年头哪个框架要是不提供命令行交互接口和脚手架，就不好意思自称是框架。事实上，一个优秀的框架总会面面俱到的，框架本来就是让开发者减轻负担，避免重复造轮子的，让开发者专注业务本身，而不是把时间精力消耗在磨刀上面。当然这是柄双刃剑，理想的状态理应是业务技术并驾齐驱。无论是建造钢铁大厦的 Symfony，还是创造艺术家园 Laravel，其命令行强大的令人望而却步。回过头来看一看主打速度的 Phalcon 吧。 ","date":"2018-03-07","objectID":"/posts/php-phalcon-command/:0:0","tags":["PHP"],"title":"Phalcon 框架之命令行","uri":"/posts/php-phalcon-command/"},{"categories":["PHP"],"content":"安装命令 Phalcon Developer Tools for Offical Website Phalcon Developer Tools for Official GitHub ","date":"2018-03-07","objectID":"/posts/php-phalcon-command/:1:0","tags":["PHP"],"title":"Phalcon 框架之命令行","uri":"/posts/php-phalcon-command/"},{"categories":["PHP"],"content":"指定的目录 将 phalcon 命令加入到系统 PATH 变量中 $ cd ~ $ git clone https://github.com/phalcon/phalcon-devtools.git .phalcon-devtools $ cd .phalcon-devtools $ ln -s ~/phalcon-devtools/phalcon.php /usr/local/bin/phalcon $ chmod a+x /usr/local/bin/phalcon 或者 $ cd ~ $ composer global require phalcon/devtools $ vim ~/.zshrc # vim ~/.bashrc $ export PATH=\"$PATH:$HOME/.composer/vendor/bin/phalcon\" ","date":"2018-03-07","objectID":"/posts/php-phalcon-command/:1:1","tags":["PHP"],"title":"Phalcon 框架之命令行","uri":"/posts/php-phalcon-command/"},{"categories":["PHP"],"content":"创建项目 支持的项目类型：cli，micro，simple - 默认，modules，共 4 种类型的项目 ","date":"2018-03-07","objectID":"/posts/php-phalcon-command/:2:0","tags":["PHP"],"title":"Phalcon 框架之命令行","uri":"/posts/php-phalcon-command/"},{"categories":["PHP"],"content":"可用命令一览 $ phalcon Phalcon DevTools (3.2.12) Available commands: info (alias of: i) commands (alias of: list, enumerate) controller (alias of: create-controller) module (alias of: create-module) model (alias of: create-model) all-models (alias of: create-all-models) project (alias of: create-project) scaffold (alias of: create-scaffold) migration (alias of: create-migration) webtools (alias of: create-webtools) serve (alias of: server) console (alias of: shell, psysh) ","date":"2018-03-07","objectID":"/posts/php-phalcon-command/:2:1","tags":["PHP"],"title":"Phalcon 框架之命令行","uri":"/posts/php-phalcon-command/"},{"categories":["PHP"],"content":"创建默认项目 // 创建一个 `cli` 类型的项目 $ phalcon project cli // 创建一个 `micro` 类型的项目 $ phalcon project micro // 创建一个 `simple` 类型的项目 $ phalcon project simple // 创建一个 `modules` 类型的项目 $ phalcon project modules ","date":"2018-03-07","objectID":"/posts/php-phalcon-command/:2:2","tags":["PHP"],"title":"Phalcon 框架之命令行","uri":"/posts/php-phalcon-command/"},{"categories":["PHP"],"content":"创建定制项目 $ phalcon project --name example --enable-webtools --directory ./ --type simple --use-config-ini --trace ","date":"2018-03-07","objectID":"/posts/php-phalcon-command/:2:3","tags":["PHP"],"title":"Phalcon 框架之命令行","uri":"/posts/php-phalcon-command/"},{"categories":["PHP"],"content":"创建控制器和模型 ","date":"2018-03-07","objectID":"/posts/php-phalcon-command/:3:0","tags":["PHP"],"title":"Phalcon 框架之命令行","uri":"/posts/php-phalcon-command/"},{"categories":["PHP"],"content":"在创建控制器和模型时，先注册命名空间 // loader.php $loader = new \\Phalcon\\Loader(); $loader-\u003eregisterNamespaces([ 'App\\\\Controller' =\u003e '../app/controllers', 'App\\\\Model' =\u003e '../app/models', ])-\u003eregister(); /** * We're a registering a set of directories taken from the configuration file. */ $loader-\u003eregisterDirs([ $config-\u003eapplication-\u003econtrollersDir, $config-\u003eapplication-\u003emodelsDir, ])-\u003eregister(); ","date":"2018-03-07","objectID":"/posts/php-phalcon-command/:3:1","tags":["PHP"],"title":"Phalcon 框架之命令行","uri":"/posts/php-phalcon-command/"},{"categories":["PHP"],"content":"创建控制器 $ phalcon controller --name article --base-class ControllerBase --force 或者 $ phalcon controller --name article --namespace App\\\\Controller --base-class ControllerBase --force ","date":"2018-03-07","objectID":"/posts/php-phalcon-command/:3:2","tags":["PHP"],"title":"Phalcon 框架之命令行","uri":"/posts/php-phalcon-command/"},{"categories":["PHP"],"content":"创建模型 $ phalcon model --name user 或者 $ phalcon model --name users --namespace App\\\\Model --get-set --doc --force --camelize --trace --mapcolumn --annotate ","date":"2018-03-07","objectID":"/posts/php-phalcon-command/:3:3","tags":["PHP"],"title":"Phalcon 框架之命令行","uri":"/posts/php-phalcon-command/"},{"categories":["PHP"],"content":"创建迁移 $ phalcon migration --action=generate --config=./app/config/config.php --version=1.0.0 --descr=init --force ","date":"2018-03-07","objectID":"/posts/php-phalcon-command/:3:4","tags":["PHP"],"title":"Phalcon 框架之命令行","uri":"/posts/php-phalcon-command/"},{"categories":["PHP"],"content":"创建脚手架 $ phalcon scaffold --table-name=user --get-set --force --trace ","date":"2018-03-07","objectID":"/posts/php-phalcon-command/:3:5","tags":["PHP"],"title":"Phalcon 框架之命令行","uri":"/posts/php-phalcon-command/"},{"categories":["PHP"],"content":"运行内置服务器 $ phalcon serve --hostname=127.0.0.1 --port=8080 --basepath=.htrouter.php --rootpath=public ","date":"2018-03-07","objectID":"/posts/php-phalcon-command/:3:6","tags":["PHP"],"title":"Phalcon 框架之命令行","uri":"/posts/php-phalcon-command/"},{"categories":["PHP"],"content":"问题 Error: SQLSTATE[HY000] [2002] No such file or directory // 编辑 php.ini 文件中的 PDO 默认 socket $ pdo_mysql.default_socket=/usr/local/var/run/mysql/mysql.sock // 查询 socket 变量 $ SHOW VARIABLES LIKE '%socket%'; ","date":"2018-03-07","objectID":"/posts/php-phalcon-command/:4:0","tags":["PHP"],"title":"Phalcon 框架之命令行","uri":"/posts/php-phalcon-command/"},{"categories":["PHP"],"content":"稀里糊涂的使用 Phalcon 一年多了，对于其运行的的流程也知道个大概，本来计划尽早梳理一下，整理下学习心得，但是，由于种种原因还是没好好整理记录。好记性不如烂笔头，再经过来来回回翻文档过程中愈加痛恨自己的记忆力了，文档上找起来也不见得容易，还是老老实实记录一下常用的一些东西吧，这样在一个地方找总胜过在一个庞大的手册跳来跳去吧。顺便提一下，Phalcon 的官方文档越来越好用了。 ","date":"2018-03-06","objectID":"/posts/php-phalcon-bootstrap/:0:0","tags":["PHP"],"title":"Phalcon 框架之启动流程","uri":"/posts/php-phalcon-bootstrap/"},{"categories":["PHP"],"content":"创建项目 执行以下的命令创建一个标准的 Phalcon Micro Project $ phalcon project --name example --enable-webtools --directory ./ --type micro --use-config-ini --trace 入口文件 \u003c?php use Phalcon\\Di\\FactoryDefault; use Phalcon\\Mvc\\Micro; error_reporting(E_ALL); define('BASE_PATH', dirname(__DIR__)); define('APP_PATH', BASE_PATH . '/app'); try { /** * The FactoryDefault Dependency Injector automatically registers the services that * provide a full stack framework. These default services can be overidden with custom ones. */ $di = new FactoryDefault(); /** * Include Services */ include APP_PATH . '/config/services.php'; /** * Get config service for use in inline setup below */ $config = $di-\u003egetConfig(); /** * Include Autoloader */ include APP_PATH . '/config/loader.php'; /** * Starting the application * Assign service locator to the application */ $app = new Micro($di); /** * Include Application */ include APP_PATH . '/app.php'; /** * Handle the request */ $app-\u003ehandle(); } catch (\\Exception $e) { echo $e-\u003egetMessage() . '\u003cbr\u003e'; echo '\u003cpre\u003e' . $e-\u003egetTraceAsString() . '\u003c/pre\u003e'; } 简单来说，就是 创建依赖注入容器 引入服务，将依赖及服务收集到容器中 自动加载 将容器注入给应用程序 请求处理并响应 ","date":"2018-03-06","objectID":"/posts/php-phalcon-bootstrap/:1:0","tags":["PHP"],"title":"Phalcon 框架之启动流程","uri":"/posts/php-phalcon-bootstrap/"},{"categories":["PHP"],"content":"依赖注册 ","date":"2018-03-06","objectID":"/posts/php-phalcon-bootstrap/:2:0","tags":["PHP"],"title":"Phalcon 框架之启动流程","uri":"/posts/php-phalcon-bootstrap/"},{"categories":["PHP"],"content":"系统默认注册 /** * Include Services */ include APP_PATH . '/config/services.php'; services.php 默认注册了 配置 - \\Phalcon\\Config\\Adapter\\Ini(ConfigFile), 视图 - Phalcon\\Mvc\\View\\Simple, URL - Phalcon\\Mvc\\Url 和 Phalcon\\Db\\Adapter\\Pdo\\XxxAdapter 这四个组件，同时当应用程序启动时，DI 中默认注册了其它服务 $services = $app-\u003egetDI()-\u003egetServices(); foreach ($services as $key =\u003e $service) { var_dump($key); var_dump(get_class($app-\u003egetDI()-\u003eget($key))); } 输出后的 Phalcon 注册服务如下： 其中 url、config、view、db、application 是没有对应的依赖服务的 router - Phalcon\\Mvc\\Router: 路由 dispatcher - Phalcon\\Mvc\\Dispatcher: 调度，将路由命中的结果分发到对应的处理单元上 url - Phalcon\\Mvc\\Url: 解析生成 URL modelsManager - Phalcon\\Mvc\\Model\\Manager: 模型管理器 modelsMetadata - Phalcon\\Mvc\\Model\\MetaData\\Memory: ORM 映射 response - Phalcon\\Http\\Response: 响应 cookies - Phalcon\\Http\\Response\\Cookies: Cookies request - Phalcon\\Http\\Request: 请求 filter - Phalcon\\Filter: 过滤器 escaper - Phalcon\\Escaper: 转义工具 security - Phalcon\\Security: 安全工具(密码 Hash、CRSF 保护) crypt - Phalcon\\Crypt: 密码工具 annotations - Phalcon\\Annotations\\Adapter\\Memory: 注释分析 flash - Phalcon\\Flash\\Direct: 提示信息输出 flashSession - Phalcon\\Flash\\Session: 提示信息通过 Session 延迟输出 tag - Phalcon\\Tag: 视图助手 session - Phalcon\\Session\\Adapter\\Files: Session sessionBag - Phalcon\\Session\\Bag: Session 包 eventsManager - Phalcon\\Events\\Manager: 事件 transactionManager - Phalcon\\Mvc\\Model\\Transaction\\Manager: 事务 assets - Phalcon\\Assets\\Manager: 资产 config - \\Phalcon\\Config\\Adapter\\Ini(ConfigFile): 配置 view - Phalcon\\Mvc\\View\\Simple: 视图 db - Phalcon\\Db\\Adapter\\Pdo\\Mysql: 数据库，可选(MySQL、Postgresql 等) application - Phalcon\\Mvc\\Micro: 应用 ","date":"2018-03-06","objectID":"/posts/php-phalcon-bootstrap/:2:1","tags":["PHP"],"title":"Phalcon 框架之启动流程","uri":"/posts/php-phalcon-bootstrap/"},{"categories":["PHP"],"content":"依赖注册属性的改变 /** * Set routing capabilities */ $router = $app-\u003egetDI()-\u003eget('router'); $router-\u003esetUriSource(\\Phalcon\\Mvc\\Router::URI_SOURCE_SERVER_REQUEST_URI); ","date":"2018-03-06","objectID":"/posts/php-phalcon-bootstrap/:2:2","tags":["PHP"],"title":"Phalcon 框架之启动流程","uri":"/posts/php-phalcon-bootstrap/"},{"categories":["PHP"],"content":"模块注册 /** * Composer autoloader */ require BASE_PATH . '/vendor/autoload.php'; /** * Registering an autoloader */ $loader = new \\Phalcon\\Loader(); $loader-\u003eregisterNamespaces([ 'App\\\\Model' =\u003e '../app/models', 'App\\\\Component' =\u003e '../app/components', 'App\\\\Util' =\u003e '../app/utils', ])-\u003eregister(); $loader-\u003eregisterDirs([ $config-\u003eapplication-\u003emodelsDir, ])-\u003eregister(); 模块注册，其实就是告诉应用程序需要引导的模块路径和类名 ","date":"2018-03-06","objectID":"/posts/php-phalcon-bootstrap/:3:0","tags":["PHP"],"title":"Phalcon 框架之启动流程","uri":"/posts/php-phalcon-bootstrap/"},{"categories":["PHP"],"content":"MVC 分层 此处的 $app 指的就是创建的 Micro 对象，一开始我们创建的应用类型为 Phalcon Micro Project $app-\u003ehandle(); 是整个 MVC 的核心，这个方法处理了 MVC 的全部流程，它获得所有请求后，在处理过程中通过事件驱动触发一系列的 app 事件，最终返回一个完整的 Phalcon\\Http\\Response 对象 ","date":"2018-03-06","objectID":"/posts/php-phalcon-bootstrap/:4:0","tags":["PHP"],"title":"Phalcon 框架之启动流程","uri":"/posts/php-phalcon-bootstrap/"},{"categories":["PHP"],"content":"自检 这个阶段，主要检查 DI，确保必要的服务注册进来 // 如果将 `db` 服务注释掉，会抛出下面的异常 /** * Database connection is created based in the parameters defined in the configuration file */ // $di-\u003esetShared('db', function () { // $config = $this-\u003egetConfig(); // // $class = 'Phalcon\\Db\\Adapter\\Pdo\\\\' . $config-\u003edatabase-\u003eadapter; // $params = [ // 'host' =\u003e $config-\u003edatabase-\u003ehost, // 'username' =\u003e $config-\u003edatabase-\u003eusername, // 'password' =\u003e $config-\u003edatabase-\u003epassword, // 'dbname' =\u003e $config-\u003edatabase-\u003edbname, // 'charset' =\u003e $config-\u003edatabase-\u003echarset, // ]; // // if ($config-\u003edatabase-\u003eadapter == 'Postgresql') { // unset($params['charset']); // } // // $connection = new $class($params); // // return $connection; // }); Service 'db' wasn't found in the dependency injection container 接下来，app 可以把事件绑定到 Phalcon\\Events\\Manager 上 事件名称 触发点 备注 boot 当应用处理它首个请求时被执行 beforeStartModule 初始化模块之前，仅当模块被注册时 afterStartModule 初始化模块之后，仅当模块被注册时 beforeHandleRequest 调度分发循环之前 afterHandleRequest 调度分发循环之后 将一个事件绑定到事件管理器上 \u003c?php use Phalcon\\Events\\Event; use Phalcon\\Events\\Manager as EventsManager; $eventsManager = new EventsManager(); $application-\u003esetEventsManager($eventsManager); $eventsManager-\u003eattach( \"application\", function (Event $event, $application) { // ... } ); 做完这些自检后，就顺得地进入了路由阶段 ","date":"2018-03-06","objectID":"/posts/php-phalcon-bootstrap/:4:1","tags":["PHP"],"title":"Phalcon 框架之启动流程","uri":"/posts/php-phalcon-bootstrap/"},{"categories":["PHP"],"content":"路由 从 DI 中容器中通过键名 router 获取路由服务，将 uri 传入路由并调用路由的 handle() 方法 路由的 handle() 方法也是好脾气，负责把将请求中的原始 uri 检查(路由是否命中)解析后，转换为对应的 Module，Controller，Action 等，并通过 $router-\u003egetModuleName() 获取模块名，判断模块是否存在，如果存在就加载相应的模块启动模块，否则，就直接进入到路由的分发阶段 ","date":"2018-03-06","objectID":"/posts/php-phalcon-bootstrap/:4:2","tags":["PHP"],"title":"Phalcon 框架之启动流程","uri":"/posts/php-phalcon-bootstrap/"},{"categories":["PHP"],"content":"模块 之前绑定到事件管理器上事件就会因为指定的路由而触发，事件触发后检查模块的正确性，根据模块文件中定义的 className，path 等，将模块引导文件加载进来，并调用模块引导文件中必须存在的方法. 也就是说，自定义的模块必须实现 ModuleDefinitionInterface 定义的 registerAutoloaders(\\Phalcon\\DiInterface $dependencyInjector = null) 和 registerServices(\\Phalcon\\DiInterface $dependencyInjector) 方法 \u003c?php namespace Phalcon\\Mvc; /** * Phalcon\\Mvc\\ModuleDefinitionInterface * * This interface must be implemented by class module definitions */ interface ModuleDefinitionInterface { /** * Registers an autoloader related to the module * * @param \\Phalcon\\DiInterface $dependencyInjector */ public function registerAutoloaders(\\Phalcon\\DiInterface $dependencyInjector = null); /** * Registers services related to the module * * @param \\Phalcon\\DiInterface $dependencyInjector */ public function registerServices(\\Phalcon\\DiInterface $dependencyInjector); } 模块启动完成后触发 afterStartModule 事件，标志着正式进入路由的调度分发阶段 ","date":"2018-03-06","objectID":"/posts/php-phalcon-bootstrap/:4:3","tags":["PHP"],"title":"Phalcon 框架之启动流程","uri":"/posts/php-phalcon-bootstrap/"},{"categories":["PHP"],"content":"分发 Phalcon 的路由调度分发是由 Phalcon\\Mvc\\Dispatcher 来完成. 所谓分发，就是 Phalcon 根据请求的原始 uri，将其匹配到的地址解析到对应的 Controller 及 Action，并返回 Action 结果 \u003c?php namespace Phalcon\\Mvc; /** * Phalcon\\Mvc\\Dispatcher * * Dispatching is the process of taking the request object, extracting the module name, * controller name, action name, and optional parameters contained in it, and then * instantiating a controller and calling an action of that controller. * * \u003ccode\u003e * $di = new \\Phalcon\\Di(); * * $dispatcher = new \\Phalcon\\Mvc\\Dispatcher(); * * $dispatcher-\u003esetDI($di); * * $dispatcher-\u003esetControllerName(\"posts\"); * $dispatcher-\u003esetActionName(\"index\"); * $dispatcher-\u003esetParams([]); * * $controller = $dispatcher-\u003edispatch(); * \u003c/code\u003e */ class Dispatcher extends \\Phalcon\\Dispatcher implements \\Phalcon\\Mvc\\DispatcherInterface { protected $_handlerSuffix = \"Controller\"; protected $_defaultHandler = \"index\"; protected $_defaultAction = \"index\"; /** * Sets the default controller suffix * * @param string $controllerSuffix */ public function setControllerSuffix($controllerSuffix) {} /** * Sets the default controller name * * @param string $controllerName */ public function setDefaultController($controllerName) {} /** * Sets the controller name to be dispatched * * @param string $controllerName */ public function setControllerName($controllerName) {} /** * Gets last dispatched controller name * * @return string */ public function getControllerName() {} /** * Gets previous dispatched namespace name * * @return string */ public function getPreviousNamespaceName() {} /** * Gets previous dispatched controller name * * @return string */ public function getPreviousControllerName() {} /** * Gets previous dispatched action name * * @return string */ public function getPreviousActionName() {} /** * Throws an internal exception * * @param string $message * @param int $exceptionCode */ protected function _throwDispatchException($message, $exceptionCode = 0) {} /** * Handles a user exception * * @param \\Exception $exception */ protected function _handleException(\\Exception $exception) {} /** * Possible controller class name that will be located to dispatch the request * * @return string */ public function getControllerClass() {} /** * Returns the latest dispatched controller * * @return \\Phalcon\\Mvc\\ControllerInterface */ public function getLastController() {} /** * Returns the active controller in the dispatcher * * @return \\Phalcon\\Mvc\\ControllerInterface */ public function getActiveController() {} } 由于这里我创建的是 Phalcon Micro Project，主要用来写接口 API 用的，所以这个过程中就没有提及 View。当然 View 模块并不是在这个阶段启动的，它也是先于调度分发前启动的。如果调度分发阶段出现任何错误，都需要 View 将问题显示出来的 调度器也是从 DI 容器中通过键名 dispatcher 获取的，路由的分发需要调度器分派，因此调度器需要取得路由的详情信息，如：命名空间\\模块名\\类名\\动作名\\参数 ","date":"2018-03-06","objectID":"/posts/php-phalcon-bootstrap/:4:4","tags":["PHP"],"title":"Phalcon 框架之启动流程","uri":"/posts/php-phalcon-bootstrap/"},{"categories":["PHP"],"content":"渲染 ","date":"2018-03-06","objectID":"/posts/php-phalcon-bootstrap/:4:5","tags":["PHP"],"title":"Phalcon 框架之启动流程","uri":"/posts/php-phalcon-bootstrap/"},{"categories":["PHP"],"content":"响应 走到这里，需要汇总一个唯一的响应一致对外。此时会触发 beforeSendResponse，并调用 Phalcon\\Http\\Response-\u003esendHeaders() 和 Phalcon\\Http\\Response-\u003esendCookies()，当然也可以去设置，然后对外返回一个 Phalcon\\Http\\Response 响应 未完待续…… ","date":"2018-03-06","objectID":"/posts/php-phalcon-bootstrap/:4:6","tags":["PHP"],"title":"Phalcon 框架之启动流程","uri":"/posts/php-phalcon-bootstrap/"},{"categories":["PHP"],"content":"以前总以为 echo，print 之类的输出工具背后没什么了不起的逻辑，不就是给个字符串让终端显示一下吗？其实不然，每一个精心设计的语言特性，函数，方法…背后都可谓独具匠心，你看，PHP 语言从来都不会设计一个一无是处的工具出来，那些雕琢出来的特性都是那么的恰到好处。 ","date":"2018-03-05","objectID":"/posts/php-output-buffer/:0:0","tags":["PHP"],"title":"PHP 中的输出缓冲区","uri":"/posts/php-output-buffer/"},{"categories":["PHP"],"content":"缓冲区的一些说明 正常情况下，任何会输出内容的函数都会用到输出缓冲区 输出缓冲区不是唯一用于缓冲输出的层，它实际上是很多层中的一个 SAPI 中的输出缓冲区 数据写入顺序：echo/print =\u003e PHP 输出缓冲区 =\u003e SAPI 缓冲区 =\u003e TCP 缓冲区 =\u003e 浏览器 ","date":"2018-03-05","objectID":"/posts/php-output-buffer/:1:0","tags":["PHP"],"title":"PHP 中的输出缓冲区","uri":"/posts/php-output-buffer/"},{"categories":["PHP"],"content":"默认的输出缓冲区 在 PHP-FPM 中，与缓冲区相关的配置。 这些值通过 ini_set() 设置后也不起作用，换句话说就是设置的太迟了，因为输出缓冲区层在 PHP 程序启动时，还没有运行任何脚本解析之前就已经启动了。这些值需要在 php.ini 或者在执行程序时使用 -d 选项才有效 ","date":"2018-03-05","objectID":"/posts/php-output-buffer/:2:0","tags":["PHP"],"title":"PHP 中的输出缓冲区","uri":"/posts/php-output-buffer/"},{"categories":["PHP"],"content":"output_buffering 默认值为 4096，设置为 Off 或者 0，表示禁用输出缓冲区；设置为 On，表示输出缓冲区不受限制，慎用； ","date":"2018-03-05","objectID":"/posts/php-output-buffer/:2:1","tags":["PHP"],"title":"PHP 中的输出缓冲区","uri":"/posts/php-output-buffer/"},{"categories":["PHP"],"content":"implicit_flush 默认值为 Off，设置为 On，表示一旦有任何输出写到 SAPI 缓冲区层，它都会立即刷新，也就是把数据写到更低层，并且缓冲区会被清空 ","date":"2018-03-05","objectID":"/posts/php-output-buffer/:2:2","tags":["PHP"],"title":"PHP 中的输出缓冲区","uri":"/posts/php-output-buffer/"},{"categories":["PHP"],"content":"output_handler 回调函数，它可以在缓冲区刷新之前修改缓冲中的内容。PHP 的扩展提供了很多回调函数： ob_gzhandler：使用 ext/zlib 压缩输出 mb_output_handler：使用 ext/mbstring 转换字符编码 ob_iconv_handler：使用 ext/iconv 转换字符编码 ob_tidyhandler：使用 ext/tidy 整理输出的 HTML 文本 ob_[inflate/deflate]_handler：使用 ext/http 压缩输出 ob_etaghandler：使用 ext/http 自动生成 HTTP 的 Etag ","date":"2018-03-05","objectID":"/posts/php-output-buffer/:2:3","tags":["PHP"],"title":"PHP 中的输出缓冲区","uri":"/posts/php-output-buffer/"},{"categories":["PHP"],"content":"实例 设置缓冲区大小为 16 字节，使用 PHP 内置的 Web 服务器 SAPI。 $ php -d output_buffering=16 -d implicit_flush=1 -S 127.0.0.1:8080 -t ~/Downloads/test 浏览器访问脚本 \u003c?php // 程序脚本运行的后向缓冲区写入 15 个字节 echo str_repeat('Hello', 3); // 进入 2 秒休眠状态 sleep(2); // 此时这个字节填满了缓冲区，缓冲区会立即刷新自身，把数据传递给 SAPI 层的缓冲区 // 由于 implicit_flush=1，SAPI 层的缓冲区也会立即刷新到下一层 // 浏览器输出 HelloHelloHelloW echo 'W'; // 进入 2 秒休眠状态 sleep(2); // 此时将这 2 个字节写入到缓冲区，由于还不够填满缓冲区，这时还不会输出到浏览器 echo 'or'; // 进入 2 秒休眠状态 sleep(2); // 此时脚本执行完毕，在执行完毕之前，将这 2 个字节写入到缓冲区，还是不够填满缓冲区 // 但这时脚本已经执行完毕，缓冲区将已有的数据全部输出浏览器 echo 'ld'; ","date":"2018-03-05","objectID":"/posts/php-output-buffer/:2:4","tags":["PHP"],"title":"PHP 中的输出缓冲区","uri":"/posts/php-output-buffer/"},{"categories":["PHP"],"content":"消息头和消息体 如果使用了输出缓冲区层，那么 PHP 会接管这些消息头和消息体的发送。 PHP 中有关与消息头的函数都使用了内部的 sapi_header_op() 函数，这个函数负责把内容写入到消息头缓冲区中，所以我们才能优雅的使用 header()，setcookie() 诸如此类的方法。 在输出内容时，内容会先被写入到输出缓冲区（可能是多个），当缓冲区中的内容需要被发送时，PHP 会先发送消息头，再发送消息体，你看，所有的这些都不费吹灰之力，PHP 为我们搞定了所有的事情。 ","date":"2018-03-05","objectID":"/posts/php-output-buffer/:3:0","tags":["PHP"],"title":"PHP 中的输出缓冲区","uri":"/posts/php-output-buffer/"},{"categories":["PHP"],"content":"用户的输出缓冲区 多个缓冲区会组成一个堆栈结构，每个新建的缓冲区都会堆叠到之前的缓冲区上，每当它被填满或者溢出，都会执行刷新操作，然后把其中的数据传递给下一个缓冲区。 \u003c?php ob_start(function ($parameter) { static $index = 0; return $index++ . ': ' . $parameter . \"\\n\"; }, 6); ob_start('handle', 3); function handle($parameter) { return ucfirst($parameter); } // 此时字符串被写入到第二个缓冲区，缓冲区的长度不够设定值，不会刷新这个缓冲区 echo 'fo'; // 休眠 2 秒 sleep(2); // 1. 此时字符串写入到第二个缓冲区后，由于 chunk_size 为 3，所以第二个缓冲区会刷新 // 2. 并且将返回的字符串 Foo 写入到第一个缓冲区 // 3. 此刻第一个缓冲区未被填满 echo 'o'; // 休眠 2 秒 sleep(2); // 1. 此时字符串写入到第二个缓冲区后，立即刷新缓冲区 // 2. 并且将返回的字符串 HelloWorld 写入到第一个缓冲区 // 3. 上一次缓冲区的 Foo 与 本次的 HelloWorld 合并 // 4. 由于第一个缓冲区 chunk_size 为 10，这时缓冲已经被填满，所以第一个缓冲区会刷新输出到浏览器 echo 'helloWorld'; // 休眠 2 秒 sleep(2); // 1. 此时字符串写入到第二个缓冲区后，立即刷新缓冲区 // 2. 并且将返回的字符串 Enough 写入到第一个缓冲区 // 3. 由于上一次的缓冲被填满刷新输出了，正好本次的缓冲区也刚好被填满，所有第一个缓冲区会刷新输出到浏览器 echo 'enough'; sleep(2); // 重复此前的步骤，由于脚本已经执行结果，被迫刷新输出到浏览器 echo 'exit'; // 结果 0: FooHelloWorld 1: Enough 2: Exit ","date":"2018-03-05","objectID":"/posts/php-output-buffer/:4:0","tags":["PHP"],"title":"PHP 中的输出缓冲区","uri":"/posts/php-output-buffer/"},{"categories":["PHP"],"content":"输出缓冲区实例 ","date":"2018-03-05","objectID":"/posts/php-output-buffer/:5:0","tags":["PHP"],"title":"PHP 中的输出缓冲区","uri":"/posts/php-output-buffer/"},{"categories":["PHP"],"content":"默认的缓冲区输出 在脚本处理结束之前，浏览器端不会输出，由于数据量太小，输出缓冲区没有写满。写入数据的顺序：PHP 缓冲区、TCP 缓冲区、浏览器 \u003c?php $i = 0; while ($i \u003c 10) { echo $i . '\u003cbr\u003e'; $i++; sleep($i); } ","date":"2018-03-05","objectID":"/posts/php-output-buffer/:5:1","tags":["PHP"],"title":"PHP 中的输出缓冲区","uri":"/posts/php-output-buffer/"},{"categories":["PHP"],"content":"关闭后的缓冲区输出 将 output_buffering 的值改为 0，执行脚本后，因应缓冲区的容量设置为 0，即禁用了 PHP 缓冲区机制。这时浏览器端会按程序定义的时间间隔不断输出，不会出现浏览器界面空白等待的情况。写入数据的顺序：TCP 缓冲区、浏览器 \u003c?php $i = 0; while ($i \u003c 10) { echo $i . '\u003cbr\u003e'; flush(); sleep(1); $i++; } ","date":"2018-03-05","objectID":"/posts/php-output-buffer/:5:2","tags":["PHP"],"title":"PHP 中的输出缓冲区","uri":"/posts/php-output-buffer/"},{"categories":["PHP"],"content":"自定义的缓冲区输出 将 output_buffing 值改为默认的 4096 使用 dd 命令准备一个大小为 4096 文件 $ dd if=/dev/zero of=file4096 bs=4096 count=1 $ ll file4096 -rw-r--r-- 1 majinyun staff 4.0K Mar 16 11:16 file4096 脚本在每次执行时，由于读取的文件内容大小正好等于缓冲区的大小，所以会立即刷新缓冲区，输出到客户端浏览器，在此过程中浏览器不会出现空白等待期，而会持续输出程序中指定的内容 \u003c?php $filename = dirname(dirname(__DIR__)) . '/../Downloads/test/file4096'; for ($i = 0; $i \u003c 10; $i++) { echo file_get_contents($filename) . $i . '\u003cbr\u003e'; sleep(1); } ","date":"2018-03-05","objectID":"/posts/php-output-buffer/:5:3","tags":["PHP"],"title":"PHP 中的输出缓冲区","uri":"/posts/php-output-buffer/"},{"categories":["PHP"],"content":"使用 ob_start 后的缓冲区输出 使用 ob_start() 后，PHP 的缓冲区会被扩展到足够大，直到 ob_end_flush() 函数调用或者脚本运行结束后，才发送缓冲区中的数据到客户端浏览器 \u003c?php ob_start(); $filename = dirname(__DIR__, 3) . '/Downloads/test/f4096'; for ($i = 0; $i \u003c 10; $i++) { echo file_get_contents($filename) . $i . '\u003cbr\u003e'; sleep(1); } ob_end_flush(); 执行脚本后，ob_get_contents() 会获取一分缓冲区中的副本，结果中有两次输出 \u003c?php ob_start(); echo 'hello world' . '\u003cbr\u003e'; $contents = ob_get_contents(); ob_end_flush(); echo $contents; // 结果 hello world hello world 执行脚本结束后，由于使用了 ob_end_clean() 函数，将 PHP 缓冲区中的内容给删除了，所以结果中仅有一次输出 \u003c?php ob_start(); echo 'hello world' . '\u003cbr\u003e'; $contents = ob_get_contents(); ob_end_clean(); echo $contents; // 结果 hello world ","date":"2018-03-05","objectID":"/posts/php-output-buffer/:5:4","tags":["PHP"],"title":"PHP 中的输出缓冲区","uri":"/posts/php-output-buffer/"},{"categories":["PHP"],"content":"PHP 中一共提供了 3 种方法检测函数，分别是：function_exists / method_exists / is_callable，这三个函数分别适用于不同的场景，现将其用法做一说明。 ","date":"2018-03-04","objectID":"/posts/php-method-detection-function/:0:0","tags":["PHP"],"title":"PHP 方法检测函数","uri":"/posts/php-method-detection-function/"},{"categories":["PHP"],"content":"检测函数是否存在 这类函数一般指 PHP 内核提供的一些工具函数或者用户自定义的函数 \u003c?php if (! function_exists('dd')) { function dd(...$vars) { foreach ($vars as $var) { print_r($var); echo PHP_EOL; } die(1); } } dd('test', 'hello', 'world'); // 结果 test hello world ","date":"2018-03-04","objectID":"/posts/php-method-detection-function/:1:0","tags":["PHP"],"title":"PHP 方法检测函数","uri":"/posts/php-method-detection-function/"},{"categories":["PHP"],"content":"检测类的方法是否存在 ","date":"2018-03-04","objectID":"/posts/php-method-detection-function/:2:0","tags":["PHP"],"title":"PHP 方法检测函数","uri":"/posts/php-method-detection-function/"},{"categories":["PHP"],"content":"能检测出的方法 method_exists() 能检测出对象中的 static, final, abstract 方法，还能检测出 public, protected, private 修饰的方法 \u003c?php abstract class Foo { public function __construct() { if (method_exists($this, 'publicMethod')) { $this-\u003epublicMethod(); } } abstract public function abstractMethod(); final public function finalMethod() { } } class Bar extends Foo { public function publicMethod() { } protected function protectedMethod() { } private function privateMethod() { } public function abstractMethod() { } public static function staticMethod() { } } $result = [ method_exists(Bar::class, '__construct'), method_exists(Bar::class, 'publicMethod'), method_exists(Bar::class, 'protectedMethod'), method_exists(Bar::class, 'privateMethod'), method_exists(Bar::class, 'abstractMethod'), method_exists(Bar::class, 'staticMethod'), method_exists(Bar::class, 'finalMethod'), ]; var_dump($result); // 结果 array(7) { [0] =\u003e bool(true) [1] =\u003e bool(true) [2] =\u003e bool(true) [3] =\u003e bool(true) [4] =\u003e bool(true) [5] =\u003e bool(true) [6] =\u003e bool(true) } ","date":"2018-03-04","objectID":"/posts/php-method-detection-function/:2:1","tags":["PHP"],"title":"PHP 方法检测函数","uri":"/posts/php-method-detection-function/"},{"categories":["PHP"],"content":"不能检测出的方法 method_exists() 无法检测出使用魔法方法 __call 调用的函数 \u003c?php class Foo { public function getName() { return __METHOD__; } public function __call($method, $arguments) { if (method_exists($this, $method)) { return call_user_func_array([$this, $method], $arguments); } return null; } } $foo = new Foo(); var_dump($foo-\u003egetName()); var_dump($foo-\u003egetDescription()); var_dump(method_exists($foo, 'getName')); var_dump(method_exists($foo, 'getDescription')); // 结果 string(12) \"Foo::getName\" NULL bool(true) bool(false) ","date":"2018-03-04","objectID":"/posts/php-method-detection-function/:3:0","tags":["PHP"],"title":"PHP 方法检测函数","uri":"/posts/php-method-detection-function/"},{"categories":["PHP"],"content":"检测参数是否为合法的可调用结构 ","date":"2018-03-04","objectID":"/posts/php-method-detection-function/:4:0","tags":["PHP"],"title":"PHP 方法检测函数","uri":"/posts/php-method-detection-function/"},{"categories":["PHP"],"content":"默认调用 is_callable() 可以判断出是否能够进行调用。默认第二个参数为 false，表示该回调操作有权限能够被调用，如果为 true 的话，仅仅验证传递的可能是函数或方法，表示只检测其存在具有可回调的格式 \u003c?php abstract class Foo { public function __construct() { if (method_exists($this, 'publicMethod')) { $this-\u003epublicMethod(); } } abstract public function abstractMethod(); final public function finalMethod() { } } class Bar extends Foo { public function publicMethod() { } protected function protectedMethod() { } private function privateMethod() { } public function abstractMethod() { } public static function staticMethod() { } } $bar = new Bar(); $callables = [ is_callable([$bar, '__construct'], false, $a), is_callable([$bar, 'publicMethod'], false, $b), is_callable([$bar, 'protectedMethod'], false, $c), is_callable([$bar, 'privateMethod'], false, $d), is_callable([$bar, 'abstractMethod'], false, $e), is_callable([$bar, 'staticMethod'], false, $f), is_callable([$bar, 'finalMethod'], false, $g), ]; $names = [$a, $b, $c, $d, $e, $f, $g]; var_dump($callables); var_dump($names); // 结果 array(7) { [0] =\u003e bool(true) [1] =\u003e bool(true) [2] =\u003e bool(false) [3] =\u003e bool(false) [4] =\u003e bool(true) [5] =\u003e bool(true) [6] =\u003e bool(true) } array(7) { [0] =\u003e string(16) \"Bar::__construct\" [1] =\u003e string(17) \"Bar::publicMethod\" [2] =\u003e string(20) \"Bar::protectedMethod\" [3] =\u003e string(18) \"Bar::privateMethod\" [4] =\u003e string(19) \"Bar::abstractMethod\" [5] =\u003e string(17) \"Bar::staticMethod\" [6] =\u003e string(16) \"Bar::finalMethod\" } ","date":"2018-03-04","objectID":"/posts/php-method-detection-function/:4:1","tags":["PHP"],"title":"PHP 方法检测函数","uri":"/posts/php-method-detection-function/"},{"categories":["PHP"],"content":"魔术方法中调用 如果设置了 __call() 方法的话，那么检测出来的任何方法都是返回 true \u003c?php abstract class Foo { public function __construct() { if (method_exists($this, 'publicMethod')) { $this-\u003epublicMethod(); } } abstract public function abstractMethod(); final public function finalMethod() { } } class Bar extends Foo { public function publicMethod() { } protected function protectedMethod() { } private function privateMethod() { } public function abstractMethod() { } public static function staticMethod() { } public function __call($method, $arguments) { } } $bar = new Bar(); $callables = [ is_callable([$bar, '__construct'], false, $a), is_callable([$bar, 'publicMethod'], false, $b), is_callable([$bar, 'protectedMethod'], false, $c), is_callable([$bar, 'privateMethod'], false, $d), is_callable([$bar, 'abstractMethod'], false, $e), is_callable([$bar, 'staticMethod'], false, $f), is_callable([$bar, 'finalMethod'], false, $g), is_callable([$bar, 'notExistMethod'], true, $h), ]; $names = [$a, $b, $c, $d, $e, $f, $g, $h]; var_dump($callables); var_dump($names); // 结果 array(8) { [0] =\u003e bool(true) [1] =\u003e bool(true) [2] =\u003e bool(true) [3] =\u003e bool(true) [4] =\u003e bool(true) [5] =\u003e bool(true) [6] =\u003e bool(true) [7] =\u003e bool(true) } array(8) { [0] =\u003e string(16) \"Bar::__construct\" [1] =\u003e string(17) \"Bar::publicMethod\" [2] =\u003e string(20) \"Bar::protectedMethod\" [3] =\u003e string(18) \"Bar::privateMethod\" [4] =\u003e string(19) \"Bar::abstractMethod\" [5] =\u003e string(17) \"Bar::staticMethod\" [6] =\u003e string(16) \"Bar::finalMethod\" [7] =\u003e string(19) \"Bar::notExistMethod\" } ","date":"2018-03-04","objectID":"/posts/php-method-detection-function/:4:2","tags":["PHP"],"title":"PHP 方法检测函数","uri":"/posts/php-method-detection-function/"},{"categories":["PHP"],"content":"结论 如果 is_callable() 的第一个参数是 string，那么和 function_exists() 相似；如果是数组则和 method_exists() 相似，但又有不同 method_exists() 不会考虑类方法的定义范围 public、protected、private，只要存在就返回 true；而 is_callable() 会在方法是被 protected、private 时返回 false is_callable() 会去调用 __call() 魔术方法来判断，而 method_exists() 不会 ","date":"2018-03-04","objectID":"/posts/php-method-detection-function/:5:0","tags":["PHP"],"title":"PHP 方法检测函数","uri":"/posts/php-method-detection-function/"},{"categories":["PHP"],"content":"在 PHP-5.4 之前定义数组只能用 array()，但在 PHP0-5.4 之后可以用 []，这个真是方便了太多，顺便还省了 5 个字符。像 array() 一样，list() 不是真正的函数，而是语言结构。list() 可以在单次操作内就为一组变量赋值。 ","date":"2018-03-01","objectID":"/posts/php-php7-list/:0:0","tags":["PHP"],"title":"PHP7 中的 list","uri":"/posts/php-php7-list/"},{"categories":["PHP"],"content":"变量赋值 PHP 5 里，list() 从最右边的参数开始赋值；PHP 7 里，list() 从最左边的参数开始赋值 出现在左值中的 [] 并不是数组的简写，是 list() 的简写 赋值操作的顺序发生了变化 list() 表达式不再可以完全为空 字符串无法再被拆包（unpack） \u003c?php list($hello, $world) = ['hello', 'world']; var_dump($hello, $world); [$new, $old] = ['new', 'old']; var_dump($new, $old); // 结果 string(5) \"hello\" string(5) \"world\" string(3) \"new\" string(3) \"old\" ","date":"2018-03-01","objectID":"/posts/php-php7-list/:1:0","tags":["PHP"],"title":"PHP7 中的 list","uri":"/posts/php-php7-list/"},{"categories":["PHP"],"content":"数组索引 \u003c?php [$a[0], $a[1], $a[2]] = ['hello', 'world', '!']; var_dump($a); // 结果 array(3) { [0] =\u003e string(5) \"hello\" [1] =\u003e string(5) \"world\" [2] =\u003e string(1) \"!\" } ","date":"2018-03-01","objectID":"/posts/php-php7-list/:2:0","tags":["PHP"],"title":"PHP7 中的 list","uri":"/posts/php-php7-list/"},{"categories":["PHP"],"content":"互相嵌套 \u003c?php // 不合法 list([$a, $b], [$c, $d]) = [[1, 2], [3, 4]]; // 不合法 [list($a, $b), list($c, $d)] = [[1, 2], [3, 4]]; // 合法 [[$a, $b], [$c, $d]] = [[1, 2], [3, 4]]; ","date":"2018-03-01","objectID":"/posts/php-php7-list/:3:0","tags":["PHP"],"title":"PHP7 中的 list","uri":"/posts/php-php7-list/"},{"categories":["PHP"],"content":"循环中使用 ","date":"2018-03-01","objectID":"/posts/php-php7-list/:4:0","tags":["PHP"],"title":"PHP7 中的 list","uri":"/posts/php-php7-list/"},{"categories":["PHP"],"content":"顺序索引 \u003c?php $array = [['a', 'b'], ['c', 'd'], ['e', 'f']]; foreach ($array as $key =\u003e [$x, $y]) { echo sprintf('第 %d 次循环的值：', $key + 1); echo $x, '-\u003e', $y . PHP_EOL; } // 结果 第 1 次循环的值：a-\u003eb 第 2 次循环的值：c-\u003ed 第 3 次循环的值：e-\u003ef ","date":"2018-03-01","objectID":"/posts/php-php7-list/:4:1","tags":["PHP"],"title":"PHP7 中的 list","uri":"/posts/php-php7-list/"},{"categories":["PHP"],"content":"指定索引 \u003c?php $array = [ ['x' =\u003e 'a', 'y' =\u003e 'b'], ['x' =\u003e 'c', 'y' =\u003e 'd'], ['x' =\u003e 'e', 'y' =\u003e 'f'], ]; foreach ($array as $key =\u003e ['x' =\u003e $x, 'y' =\u003e $y]) { echo sprintf('第 %d 次循环的值：', $key + 1); echo $x, '-\u003e', $y . PHP_EOL; } // 结果 第 1 次循环的值：a-\u003eb 第 2 次循环的值：c-\u003ed 第 3 次循环的值：e-\u003ef ","date":"2018-03-01","objectID":"/posts/php-php7-list/:4:2","tags":["PHP"],"title":"PHP7 中的 list","uri":"/posts/php-php7-list/"},{"categories":["PHP"],"content":"允许指定键 \u003c?php $array = ['x' =\u003e 1, 'y' =\u003e 2, 'z' =\u003e 3]; ['x' =\u003e $x, 'y' =\u003e $y, 'z' =\u003e $z] = $array; var_dump($x, $y, $z); // 相当于 $x = $array['x']; $y = $array['y']; $z = $array['z']; // 结果 int(1) int(2) int(3) ","date":"2018-03-01","objectID":"/posts/php-php7-list/:5:0","tags":["PHP"],"title":"PHP7 中的 list","uri":"/posts/php-php7-list/"},{"categories":["PHP"],"content":"调整顺序 \u003c?php // PHP 5 会报 PHP Notice: Undefined offset: 0... list($a, $b) = [1 =\u003e 'a', 2 =\u003e 'b']; // PHP 7 处理起来不费吹灰之力 [10 =\u003e $a, 11 =\u003e $b, 12 =\u003e $c] = [10 =\u003e 'a', 11 =\u003e 'b', 12 =\u003e 'c']; var_dump($a, $b, $c); // 结果 string(1) \"a\" string(1) \"b\" string(1) \"c\" ","date":"2018-03-01","objectID":"/posts/php-php7-list/:6:0","tags":["PHP"],"title":"PHP7 中的 list","uri":"/posts/php-php7-list/"},{"categories":["PHP"],"content":"混合键 PHP 7 中 list() 支持混合形式的 key \u003c?php // PHP 5 会报 PHP Notice: Undefined offset: 0... list($a, $b, $c) = [1 =\u003e 'a', 'x' =\u003e 'b', 2 =\u003e 'c']; // PHP 7 处理起来毫无压力 [10 =\u003e $a, 'x' =\u003e $b, 12 =\u003e $c] = [10 =\u003e 'a', 'x' =\u003e 'b', 12 =\u003e 'c']; var_dump($a, $b, $c); // 结果 string(1) \"a\" string(1) \"b\" string(1) \"c\" ","date":"2018-03-01","objectID":"/posts/php-php7-list/:7:0","tags":["PHP"],"title":"PHP7 中的 list","uri":"/posts/php-php7-list/"},{"categories":["PHP"],"content":"复合形式 ","date":"2018-03-01","objectID":"/posts/php-php7-list/:8:0","tags":["PHP"],"title":"PHP7 中的 list","uri":"/posts/php-php7-list/"},{"categories":["PHP"],"content":"键名一致 \u003c?php $array = [ ['m' =\u003e 11, 'n' =\u003e 22], ['m' =\u003e 'hello', 'n' =\u003e 'world'], ['m' =\u003e true, 'n' =\u003e false], ]; [ ['m' =\u003e $m1, 'n' =\u003e $n1], ['m' =\u003e $m2, 'n' =\u003e $n2], ['m' =\u003e $m3, 'n' =\u003e $n3], ] = $array; var_dump(\"$m1 $n1\", \"$m2 $n2\", \"$m3 $n3\"); // 结果 string(6) \"11 22\" string(12) \"hello world\" string(3) \"1 \" ","date":"2018-03-01","objectID":"/posts/php-php7-list/:8:1","tags":["PHP"],"title":"PHP7 中的 list","uri":"/posts/php-php7-list/"},{"categories":["PHP"],"content":"键名不同 \u003c?php $array = [ 'x' =\u003e ['a', 'b'], 'y' =\u003e [1, 2], 'z' =\u003e [true, false], ]; ['x' =\u003e [$a, $b], 'y' =\u003e [$c, $d], 'z' =\u003e [$e, $f]] = $array; var_dump(\"$a $b\", \"$c $d\", \"$e $f\"); // 结果 string(3) \"a b\" string(3) \"1 2\" string(2) \"1 \" ","date":"2018-03-01","objectID":"/posts/php-php7-list/:8:2","tags":["PHP"],"title":"PHP7 中的 list","uri":"/posts/php-php7-list/"},{"categories":["PHP"],"content":"收集整理一下 PHP 的一些快速开发工具包。 ","date":"2018-02-28","objectID":"/posts/php-toolkit/:0:0","tags":["PHP"],"title":"PHP - 开发工具包","uri":"/posts/php-toolkit/"},{"categories":["PHP"],"content":"开发包 Composer - Dependency Management for PHP Guzzle - Guzzle is a PHP HTTP client that makes it easy to send HTTP requests and trivial to integrate with web services Zephir is a compiled high level language aimed to the creation of C-extensions for PHP Swoole - Event-driven asynchronous \u0026 concurrent \u0026 coroutine networking engine with high performance for PHP Sami - An API documentation generator Intervention Image - Intervention Image is a PHP image handling and manipulation library providing an easier and expressive way to create, edit, and compose images. Monolog - Sends your logs to files, sockets, inboxes, databases and various web services PHP dotenv - Loads environment variables from .env to getenv() ","date":"2018-02-28","objectID":"/posts/php-toolkit/:1:0","tags":["PHP"],"title":"PHP - 开发工具包","uri":"/posts/php-toolkit/"},{"categories":["PHP"],"content":"微框架 Lumen - The stunningly fast micro-framework by Laravel Slim - Slim is a PHP micro-framework that helps you quickly write simple yet powerful web applications and APIs Silex - The PHP micro-framework based on the Symfony Components Bullet - Bullet is a resource-oriented micro PHP framework built around HTTP URIs Proton - Proton is a StackPHP compatible micro framework Fat-Free - A powerful yet easy-to-use PHP micro-framework designed to help you build dynamic and robust Web applications - fast ","date":"2018-02-28","objectID":"/posts/php-toolkit/:2:0","tags":["PHP"],"title":"PHP - 开发工具包","uri":"/posts/php-toolkit/"},{"categories":["PHP"],"content":"Web 框架 Laravel - A PHP framework for web artisans Symfony - The Symfony PHP framework CakePHP - The Rapid Development Framework for PHP Yii 2 - The Fast, Secure and Professional PHP Framework Zend Framework - PHP Official Framework CodeIgniter - CodeIgniter is an Application Development Framework Phalcon - High performance, full-stack PHP framework delivered as a C extension PHPixie - A lightweight MVC PHP framework designed for speed and simplicty FuelPHP - FuelPHP is a fast, lightweight PHP 5.4 framework ThinkPHP - 为 API 开发而设计的高性能 PHP 框架 ","date":"2018-02-28","objectID":"/posts/php-toolkit/:3:0","tags":["PHP"],"title":"PHP - 开发工具包","uri":"/posts/php-toolkit/"},{"categories":["PHP"],"content":"代码质量 PHP CodeSniffer - PHP_CodeSniffer tokenizes PHP, JavaScript and CSS files and detects violations of a defined set of coding standards PHP CS Fixer - The PHP Coding Standards Fixer (PHP CS Fixer) tool fixes your code to follow standards PHPMD - PHPMD is a spin-off project of PHP Depend and aims to be a PHP equivalent of the well known Java tool PMD. PHPMD can be seen as an user friendly frontend application for the raw metrics stream measured by PHP Depend ","date":"2018-02-28","objectID":"/posts/php-toolkit/:4:0","tags":["PHP"],"title":"PHP - 开发工具包","uri":"/posts/php-toolkit/"},{"categories":["Linux"],"content":"books The Linux Kernel Module Programming Guide ","date":"2018-02-13","objectID":"/posts/linux-awesome/:0:0","tags":["Linux"],"title":"Linux - Awesome","uri":"/posts/linux-awesome/"},{"categories":["Linux"],"content":"旨在收集一些常用的 Linux 命令于此，方便以后快速查询及使用。其中有些命令在 CentOS 7 及以上的版本中并不能正常使用，需要安装相应的包才能工作。 ","date":"2018-02-13","objectID":"/posts/linux-common-command/:0:0","tags":["Linux"],"title":"Linux - 常用命令","uri":"/posts/linux-common-command/"},{"categories":["Linux"],"content":"命令技巧 ","date":"2018-02-13","objectID":"/posts/linux-common-command/:1:0","tags":["Linux"],"title":"Linux - 常用命令","uri":"/posts/linux-common-command/"},{"categories":["Linux"],"content":"命令帮助 记得关键字的情况下，通过 man -k \u003ccommand keyword\u003e 来搜索 命令简要说明使用 whatis \u003ccommand\u003e；命令详细说明使用 info \u003ccommand\u003e 查看命令位置使用 which \u003ccommand\u003e 命令的具体参数和使用方法使用 man \u003ccommand\u003e ","date":"2018-02-13","objectID":"/posts/linux-common-command/:1:1","tags":["Linux"],"title":"Linux - 常用命令","uri":"/posts/linux-common-command/"},{"categories":["Linux"],"content":"Bash 快捷键 名称 描述 Ctrl-U 删除光标到行首的所有字符，在某些设置下，删除全行 Ctrl-W 删除当前光标到前边的最近一个空格之间的字符 Ctrl-H 删除光标前边的字符 Ctrl-R 匹配最相近的一个文件，然后输出 ","date":"2018-02-13","objectID":"/posts/linux-common-command/:1:2","tags":["Linux"],"title":"Linux - 常用命令","uri":"/posts/linux-common-command/"},{"categories":["Linux"],"content":"系统命令 命令 描述 lspci -tv 列出所有 PCI 设备 lsusb -tv 列出所有 USB 设备 lsmod 列出加载的内核模块 uname -a 查看内核，操作系统，CPU 信息 head -n 1 /etc/issue 查看操作系统版本 cat /proc/cpuinfo 查看 CPU 信息 grep “model name” /proc/cpuinfo | wc -l 查看 CPU 数量 hostname 查看计算机名 env 查看环境变量 free -m 查看内存使用量和交换区使用量 df -h 查看各分区使用情况 grep MemTotal /proc/meminfo 查看内存总量 grep MemFree /proc/meminfo 查看空闲内存量 uptime 查看系统运行时间，用户数，负载 cat /proc/loadavg 查看系统负载 lsof -i:3306 查看端口占用的进程状态 kill -9 \u003cpid\u003e 强行中止进程 ps -ef | grep name | awk ‘{print $2}’ | xargs kill -9 查询指定的进程并进行中止 ps -aux 显示所有（包含其他用户）的进程 ps -ef | grep name 查看指定进程 ps -x -o pid,rss,vsz,command 查看进程占用内存信息 ","date":"2018-02-13","objectID":"/posts/linux-common-command/:2:0","tags":["Linux"],"title":"Linux - 常用命令","uri":"/posts/linux-common-command/"},{"categories":["Linux"],"content":"磁盘命令 命令 描述 mount 输出系统目前的挂载信息 mount /dev/sda1 /mnt 将 sda1 挂载到 /mnt 中 mount | column -t 查看挂接的分区状态 umount /mnt 卸载 /mnt 这个挂载点的文件系统 umount -a 卸载所有已挂载的文件系统 fdisk -l 查看所有分区 swapon -s 查看所有交换分区 dmesg | grep IDE 查看启动时 IDE 设备检测状况 iptables -L 查看防火墙设置 du -sh \u003cdirectory\u003e 查看指定目录的大小 du -sh ls | sort 查看当前目录下所有子文件夹排序后的大小 ","date":"2018-02-13","objectID":"/posts/linux-common-command/:3:0","tags":["Linux"],"title":"Linux - 常用命令","uri":"/posts/linux-common-command/"},{"categories":["Linux"],"content":"网络命令 命令 描述 ifconfig 查看所有网络接口的属性 ip addr show 查看所有网络接口的属性 route -n 查看路由表 netstat -lntp 查看所有监听的端口 netstat -antp 查看所有已经建立的连接 netstat -s 查看网络统计信息 netstat -nap | grep 将会显示使用该端口的应用程序的进程 ID netstat -all 或 netstat -a 将会显示包括 TCP 和 UDP 的所有连接 netstat --tcp 或 netstat -t 将会显示 TCP 连接 netstat --udp 或 netstat -u 将会显示 UDP 连接 netstat -g 将会显示该主机订阅的所有多播网络 netstat -anpt | grep ‘:’ 找出运行在指定端口的进程 netstat -an awk ‘/^tcp/{+S[$NF]} END {for(a in S) print a,S[a]}’ ping -c 3 \u003cdomain\u003e 指定次数后 Ping 域名 ","date":"2018-02-13","objectID":"/posts/linux-common-command/:4:0","tags":["Linux"],"title":"Linux - 常用命令","uri":"/posts/linux-common-command/"},{"categories":["Linux"],"content":"curl cURL 是一个利用 URL 语法在命令行下工作的文件传输工具。 cURL 支持的通信协议有：FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP 和 RTSP。 # 查询 curl 支持的协议 curl-config --protocols # 将文件保存为指定的文件中 curl -o google.html https://google.com/ # 使用 URL 中默认的文件名保存文件到本地 curl -O https://google.com/ # 多个文件下载保存 curl -o a.html https://a.com/a.html -o b.html https://b.com/b.html curl -O https://a.co/a.html -O https://b.com/b.html # 有的网址是自动跳转的，使用 -L 参数，curl 就会跳转到新的网址 curl -L http://www.g.cn # 断点续传 curl -O http://www.gnu.org/software/gettext/manual/gettext.html curl -C - -O http://www.gnu.org/software/gettext/manual/gettext.html # 限制数据传输速率 curl --limit-rate 1000B -O http://www.gnu.org/software/gettext/manual/gettext.html # 下载给定日期时间之前修改的文件 curl -z -06-Nov-15 https://a.com/a.html # 下载给定日期时间之后修改的文件 curl -z 06-Nov-15 https://b.com/b.html # 通过 HTTP 认证 curl --user username:password https://a.com/test # 从 FTP 服务器下载文件 curl -u ftpuser:ftppass -O ftp://domain/public/xxx.php # 使用范围查看和下载 curl ftp://ftp.domain.com/test/[a-z]/ # 上传单个文件 curl -u ftpuser:ftppass -T file.txt ftp://domain # 上传多个文件 curl -u ftpuser:ftppass -T \"{file1,file2}\" ftp://domain # 保存标准输入到远程服务器指定文件中 curl -u ftpuser:ftppass -T - ftp://domain/test.txt # -v 显示通信过程，包括端口连接和 http request 头信息 curl -v https://www.baidu.com # --trace 将通信过程保存到指定文件 curl --trace a.txt https://a.com/ # 使用代理下载文件 curl -x proxysever.test.com:8081 https://www.google.com/ ","date":"2018-02-13","objectID":"/posts/linux-common-command/:4:1","tags":["Linux"],"title":"Linux - 常用命令","uri":"/posts/linux-common-command/"},{"categories":["Linux"],"content":"wget The Ultimate Wget Download Guide With 15 Awesome Examples # 下载单个文件 wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm # 下载文件重命名 wget -O baidu.html http://www.baidu.com/index.html # 限制下载速率 wget --limit-rate=200k http://www.openss7.org/repos/tarballs/strx25-0.9.2.1.tar.bz2 # 断点续传 wget -c http://www.openss7.org/repos/tarballs/strx25-0.9.2.1.tar.bz2 # 后台下载 wget -b http://www.openss7.org/repos/tarballs/strx25-0.9.2.1.tar.bz2 # 查看下载进度 tail -f wget-log ","date":"2018-02-13","objectID":"/posts/linux-common-command/:4:2","tags":["Linux"],"title":"Linux - 常用命令","uri":"/posts/linux-common-command/"},{"categories":["Linux"],"content":"scp // 本地文件复制到远程服务器 $ scp -r test.sql user@ip:/home/user // 远程服务器文件复制到本地 $ scp -r user@ip:/home/user/test.sql ./ ","date":"2018-02-13","objectID":"/posts/linux-common-command/:4:3","tags":["Linux"],"title":"Linux - 常用命令","uri":"/posts/linux-common-command/"},{"categories":["Linux"],"content":"用户命令 命令 描述 w 查看活动用户 id \u003cusername\u003e 查看指定用户信息 last 查看用户登录日志 cut -d: -f1 /etc/passwd 查看系统所有用户 cut -d: -f1 /etc/group 查看系统所有组 crontab -l 查看当前用户的计划任务 ","date":"2018-02-13","objectID":"/posts/linux-common-command/:5:0","tags":["Linux"],"title":"Linux - 常用命令","uri":"/posts/linux-common-command/"},{"categories":["Linux"],"content":"文件命令 命令 描述 ln source dest 为 source 创建一个名为 dest 的硬链接 ln -s source dest 为 source 创建一个名为 dest 的软链接 tar -cvf filename.tar . 将当前目录所有文件归档，但不压缩 tar -xvf filename.tar 解压 filename.tar 到当前文件夹 tar -cvjf filename.tar.bz2 . 使用 bzip2 压缩当前目录 tar -xvjf filename.tar.bz2 解压 filename.tar.bz2 到当前目录 tar -cvzf filename.tar.gz . 使用 gzip 压缩当前目录 tar -xvzf filename.tar.gz 解压 filename.tar.gz 到当前文件夹 tar -tf filename 只查看 filename 归档中的文件，不解压 chown user filename 改变 filename 的所有者为 user chown user:group filename 改变 filename 的所有者为 user，组为 group chown -R root folder 改变 folder 文件夹及其子文件的所有者为 root chmod +x filename 为 user，group，other 添加执行权限 chmod -x filename 取消 user，group，other 的执行权限 chmod +w filename 为 user 添加写入权限 chmod ugo=rwx filename 设置 user，group，other 具有读取、写入、执行权限 chmod ug=rw filename 设置 user，group 添加读取、写入权限 chmod ugo=--- filename 取消所有权限 find . -name \u003cpattern\u003e 从当前目录查找符合 pattern 的文件 find \u003cdirectory\u003e -name PATTERN -exec ls -l {} \\; 从指定文件查找所有符合 pattern 的文件，并交由 ls 输出详细信息 find ./ -name \"*.txt\" -exec rm {} \\; 递归当前目录及子目录删除所有 .txt 文件 find . \\( -name \"*.txt\" -o -name \"*.pdf\" \\) -print 在当前目录下递归查找 .txt 和 .pdf 文件 find . -type d -print 递归列出当前目录下的所有目录 find . -type f -size +5k 查找大于指定大小的文件 find . -type f -name “*.php” -print0 | xargs -0 wc -l 统计指定目录下的程序行数 locate php.ini 更快的查询指定的文件，需要定期执行更新命令 updatedb 来更新索引库 grep -r \"string\" /home/user/ 以递归方式在指定的文件中搜索给定的字符串 grep -i \"the\" /home/user/.zshrc 在指定的文件中搜索给定的字符串 grep \"Controller\" . -R -n 在多级目录中对指定的文本递归搜索 diff -w ~/a.txt ~/b.txt 忽略空白后比较两个文件的差异 ","date":"2018-02-13","objectID":"/posts/linux-common-command/:6:0","tags":["Linux"],"title":"Linux - 常用命令","uri":"/posts/linux-common-command/"},{"categories":["Linux"],"content":"sed // 将 a.txt 文件中的 php 字符串替换成 javascript 字符串 $ sed -i \"s/php/javascript/g\" `grep php -rl ./a.txt` // 以相反的顺序打印文件内容 $ sed -n '1!G;h;$p' /home/user/.zshrc ","date":"2018-02-13","objectID":"/posts/linux-common-command/:6:1","tags":["Linux"],"title":"Linux - 常用命令","uri":"/posts/linux-common-command/"},{"categories":["Linux"],"content":"awk AWK 程序设计语言 命令 描述 $0 当前记录(这个变量中存放着整个行的内容) $1-$n 当前记录的第 n 个字段，字段间由 FS 分隔 FS 输入字段分隔符，默认是空格或 Tab NF 当前记录中的字段个数，就是有多少列 NR 已经读出的记录数，就是行号，从 1 开始，如果有多个文件话，这个值也是不断累加中 FNR 当前记录数，与 NR 不同的是，这个值会是各个文件自己的行号 RS 输入的记录分隔符，默认为换行符 OFS 输出字段分隔符，默认为空格 ORS 输出的记录分隔符，默认为换行符 FILENAME 当前输入文件的名字 // 移除指定文件中重复的行并显示出来 $ awk '!($0 in array) { array[$0]; print }' a.txt // 将 uid 和 gid 相同的行显示出来 $ awk -F ':' '$3==$4' /etc/passwd // 准备要操作的数据 $ netstat -atlnpe \u003e netstat.log // 输出三列（1，4，9） $ awk '{print $1, $4, $9}' netstat.log // 格式化输出 $ awk '{printf \"%-8s %-8s %-8s %-25s %-25s %-15s\\n\",$1,$2,$3,$4,$5,$6}' netstat.log // 仅显示第 3 列的值为 0 \u0026\u0026 第 6 列的值为 LISTE $ awk '$3==0 \u0026\u0026 $6==\"LISTEN\"' netstat.log // 仅显示第 3 列的值为 0 \u0026\u0026 第 6 列的值为 LISTE, 同时把表头也显示出来 $ awk '$3==0 \u0026\u0026 $6==\"LISTEN\" || NR==2' netstat.log // 仅显示第 3 列的值为 0 \u0026\u0026 第 6 列的值为 LISTE, 同时把表头也显示出来, 并且格式化输出三列(4, 5, 6) $ awk '$3==0 \u0026\u0026 $6==\"LISTEN\" || NR==2 {printf \"%-20s %-20s %s\\n\", $4 , $5, $6}' netstat.log // 仅显示第 3 列的值为 0 \u0026\u0026 第 6 列的值为 ESTABLISHED, 同时把表头也显示出来, 并且格式化输出三列(4, 5, 6) $ awk '$3==0 \u0026\u0026 $6==\"ESTABLISHED\" || NR==2 {printf \"%02s %s %-20s %-20s %s\\n\", NR, FNR, $4, $5, $6}' netstat.log // 指定分隔符 $ awk 'BEGIN{FS=\":\"} {print $1, $3, $6}' /etc/passwd 或者 $ awk -F: '{print $1, $3, $6}' /etc/passwd // -t 作为分隔符 $ awk -F: '{print $1, $3, $6}' OFS=\"\\t\" /etc/passwd // 匹配 LISTEN $ awk '$6 ~ /LISTEN/ || NR==2 {print NR, $4, $5, $6}' OFS=\"\\t\" netstat.log 或者 $ awk '/LISTEN/' netstat.log // 匹配 ESTABLISHED $ awk '$6 ~ /ESTABLISHED/ || NR==2 {print NR, $4, $5, $6}' OFS=\"\\t\" netstat.log // 匹配 ESTABLISHED 取反 $ awk '$6 !~ /ESTABLISHED/ || NR==2 {print NR, $4, $5, $6}' OFS=\"\\t\" netstat.log 或者 $ awk '!/ESTABLISHED/' netstat.log // 拆分文件 $ awk 'NR!=1 \u0026\u0026 NR!=2 {print \u003e $6}' netstat.log // 判断匹配拆分文件 $ awk 'NR!=1 { if ($6 ~ /TIME|ESTABLISHED/) print \u003e \"1.log\"; else if ($6 ~ /LISTEN/) print \u003e \"2.log\"; else print \u003e \"3.log\" }' netstat.log // 求 *.php *.js 文件大小总和 $ ls -l *.php *.js | awk '{sum+=$5} END {print sum}' // 统计每个用户的进程的占了多少内存 $ ps aux | awk 'NR!=1 {a[$1]+=$6;} END { for(i in a) print i \": \" a[i]\" KB\"; }' // 从文件中找出长度大于 80 的行 $ awk 'length\u003e80' /etc/php.ini // 按连接数查看客户端 IP $ netstat -ntu | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -nr // 打印九九乘法表 $ seq 9 | sed 'H;g' | awk -v RS='' '{ for(i=1;i\u003c=NF;i++)printf(\"%dx%d=%d%s\", i, NR, i*NR, i==NR?\"\\n\":\"\\t\") }' ","date":"2018-02-13","objectID":"/posts/linux-common-command/:6:2","tags":["Linux"],"title":"Linux - 常用命令","uri":"/posts/linux-common-command/"},{"categories":["Linux"],"content":"wc // 统计一个文件的行数，字数，字节数，文件名称 $ wc filename // 统计一个文件的字符数 $ wc -c filename // 统计一个文件的字符数 $ wc -m filename // 统计一个文件的行数 $ wc -l filename // 统计一个文件的单词数 $ wc -w filename // 统计目录下的文件个数 $ ll \u003cdirectory\u003e | wc -l ","date":"2018-02-13","objectID":"/posts/linux-common-command/:6:3","tags":["Linux"],"title":"Linux - 常用命令","uri":"/posts/linux-common-command/"},{"categories":["Linux"],"content":"date Format Description %D 显示日期为月日年 (mm/dd/yy) %d 显示天的日期 (01~31) %a 显示周的缩写名称 (Sun~Sat) %A 显示周的全部名称 (Sunday~Saturday) %h 显示月份的缩写名称 (Jan~Dec) %b 显示月份的缩写名称 (Jan~Dec) %B 显示完整的月份名称 (January~December) %y 显示年份的最后两位 (00~99) %Y 显示完整的年份名称 %T 显示时间以 24 小时格式的 HH:MM:SS %H 显示小时 (00~23) %M 显示分钟 (00~59) %S 显示秒数 (00~59) // 显示系统本地日期时间 $ date Thu Jul 14 13:46:13 CST 2022 $ date +%c Thu 14 Jul 2022 02:10:31 PM CST // 显示系统 UTC 日期时间 $ date -u Thu Jul 14 05:46:41 UTC 2022 $ date -u +%Y-%m-%dT%H:%M:%SZ 2022-07-14T06:10:11Z // 以日期时间格式显示给定的日期字符串 $ date --date=\"2/02/2012\" Thu Feb 2 00:00:00 CST 2012 $ date --date=\"12/12/2022T12:30:30\" Mon Dec 12 13:30:30 CST 2022 $ date --date=\"Feb 2 2022 12\" Wed Feb 2 12:00:00 CST 2022 // 显示过去的日期 $ date --date=\"2 year ago\" Tue Jul 14 13:51:32 CST 2020 $ date --date=\"10 day ago\" Mon Jul 4 13:52:45 CST 2022 $ date --date=\"5 min ago\" Thu Jul 14 13:46:46 CST 2022 $ date --date=\"5 sec ago\" Thu Jul 14 13:51:46 CST 2022 $ date --date=\"yesterday\" Wed Jul 13 13:52:20 CST 2022 // 显示未来的日期 $ date --date=\"next tue\" Tue Jul 19 00:00:00 CST 2022 $ date --date=\"2 day\" Sat Jul 16 13:53:31 CST 2022 $ date --date=\"10 sec\" Thu Jul 14 13:53:46 CST 2022 $ date --date=\"next year\" Fri Jul 14 13:53:46 CST 2023 $ date --date=\"tomorrow\" Fri Jul 15 13:54:21 CST 2022 // 格式化显示 $ date '+%D' 07/14/22 $ date '+%D %T' 07/14/22 14:05:59 $ date '+%Y-%m-%d %H:%M:%S' 2022-07-14 14:06:23 $ date '+%A %B %d %T %Y' Thursday July 14 14:06:45 2022 // 显示当前日期的时间戳 $ date +%s 1657779074 // 显示文件的最后修改时间 $ date -r /etc/hosts Fri Jun 11 23:13:54 CST 2021 // 显示自定义输出 $ date +\"Week: %V; Year: %Y\" Week: 28; Year: 2022 // 将时间戳转换为日期时间格式 $ date -d @`date +%s` Thu Jul 14 14:16:38 CST 2022 $ date +'%Y-%m-%d %H:%M:%S' -d @`date +%s` 2022-07-14 14:17:53 ","date":"2018-02-13","objectID":"/posts/linux-common-command/:6:4","tags":["Linux"],"title":"Linux - 常用命令","uri":"/posts/linux-common-command/"},{"categories":["PHP"],"content":"无规矩不成方圆，无规范不能协作。每门编程语言几乎都有一套合乎自有章法的规矩，当然了，PHP 也不例外。即使是你独立撸码，也自有一套自己的章法，可惜，你不是一个人在战斗，在这个讲究编程效率的兵团作战时代，没有人愿意忍受别人糟糕的代码风格。是的，代码的的确确是机器去执行的，但是因更改需求而维护的代码可不是机器人干的。为了让代码可维护，看起来像那么回事，还是尽力码好吧，不然，下一个遭吐槽可能就是你了，我已经不至一次听过『这特么谁写的』这句话了，反正听起来不像是在夸谁。 ","date":"2018-02-07","objectID":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/:0:0","tags":["PHP"],"title":"PHP 编码标准插件","uri":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/"},{"categories":["PHP"],"content":"PHP CodeSniffer PHP_CodeSniffer Pear PHP_CodeSniffer GitHub PHP_CodeSniffer Documentation ","date":"2018-02-07","objectID":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/:1:0","tags":["PHP"],"title":"PHP 编码标准插件","uri":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/"},{"categories":["PHP"],"content":"CodeSniffer 安装 PHP CodeSniffer 有两个脚本，phpcs 脚本用来检测违反定义的编码标准，phpcbf 脚本用来自动纠正编码标准违规。 Curl 安装 CodeSniffer // 下载 phpcs 和 phpcbf 文件并移动到相应目录 $ cd ~ $ curl -OL https://squizlabs.github.io/PHP_CodeSniffer/phpcs.phar $ sudo mv phpcs.phar /usr/local/bin/phpcs $ sudo chmod +x /usr/local/bin/phpcs $ curl -OL https://squizlabs.github.io/PHP_CodeSniffer/phpcbf.phar $ sudo mv phpcbf.phar /usr/local/bin/phpcbf $ sudo chmod +x /usr/local/bin/phpcbf Composer 安装 CodeSniffer 安装完成后，将 $HOME/.composer/vendor/bin 添加到系统 PATH 中。 全局安装 // 安装 squizlabs/php_codesniffer $ composer global require \"squizlabs/php_codesniffer=*\" 项目安装 $ vim composer.json { \"require-dev\": { \"squizlabs/php_codesniffer\": \"3.*\" } } $ composer install ","date":"2018-02-07","objectID":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/:1:1","tags":["PHP"],"title":"PHP 编码标准插件","uri":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/"},{"categories":["PHP"],"content":"工具设置 设置编码标准 支持的编码标准：PEAR, Zend, PSR2, MySource, Squiz, PSR1，默认：PEAR。 // 设置编码标准为 PSR2 $ phpcs --config-set default_standard PSR2 设置报告格式 支持的报告格式：full, xml, checkstyle, csv, json, junit, emacs, source, summary, diff, svnblame, gitblame, hgblame, notifysend，默认：full // 设置报告格式为 full $ phpcs --config-set report_format full 设置警告隐藏 // 默认值为 1 $ phpcs --config-set show_warnings 0 设置运行进度 // 默认值为 0 $ phpcs --config-set show_progress 1 设置输出时使用润色 // 默认值为 0 $ phpcs --config-set colors 1 设置报告的宽度 // 设置报告的宽度为 120 $ phpcs --config-set report_width 120 设置文本字符编码 // 设置文本字符编码为 UTF-8 $ phpcs --config-set encoding UTF-8 设置制表符宽度 默认情况下，PHP_CodeSniffer 不会将检查文件中的制表符转换为空格，指定一个制表符宽度将使 PHP_CodeSniffer 用空格替换制表符。也可以通过设置 tab_width 配置选项来强制 PHP_CodeSniffer 将制表符替换为空格。 // 设置制表符宽度为 4 个空格 $ phpcs --config-set tab_width 4 设置 PHP 版本 // 使用 PHP_VERSION_ID 获取后再设置 $ phpcs --config-set php_version 70114 设置 PHP 路径 // 使用 which 命令获取后再设置 $ phpcs --config-set php_path /usr/local/bin/php 查看设置 // 查看刚才的一些设置 $ phpcs --config-show Using config file: /Users/user/.composer/vendor/squizlabs/php_codesniffer/CodeSniffer.conf colors: 1 default_standard: PSR2 encoding: UTF-8 php_path: /usr/local/bin/php php_version: 70114 report_format: full report_width: 120 show_progress: 1 show_warnings: 1 tab_width: 4 ","date":"2018-02-07","objectID":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/:1:2","tags":["PHP"],"title":"PHP 编码标准插件","uri":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/"},{"categories":["PHP"],"content":"工具使用 指定编码标准 也可以自定义编码标准，然后加入到检查标准中。 $ phpcs --standard=PEAR /path/to/code/Demo.php 或 $ phpcs --standard=/path/to/MyStandard /path/to/code/Demo.php 或 $ phpcs --standard=PEAR,Squiz,/path/to/MyStandard /path/to/code/Demo.php 打印安装编码标准的列表 $ phpcs -i The installed coding standards are PEAR, Zend, PSR2, MySource, Squiz and PSR1 编码标准内的嗅探列表 $ phpcs --standard=PSR2 -e The PSR2 standard contains 42 sniffs Generic (12 sniffs) ------------------- Generic.ControlStructures.InlineControlStructure Generic.Files.ByteOrderMark Generic.Files.LineEndings Generic.Files.LineLength Generic.Formatting.DisallowMultipleStatements Generic.Functions.FunctionCallArgumentSpacing Generic.NamingConventions.UpperCaseConstantName Generic.PHP.DisallowShortOpenTag Generic.PHP.LowerCaseConstant Generic.PHP.LowerCaseKeyword Generic.WhiteSpace.DisallowTabIndent Generic.WhiteSpace.ScopeIndent PEAR (1 sniff) --------------- PEAR.Functions.ValidDefaultValue PSR1 (3 sniffs) --------------- PSR1.Classes.ClassDeclaration PSR1.Files.SideEffects PSR1.Methods.CamelCapsMethodName PSR2 (12 sniffs) ---------------- PSR2.Classes.ClassDeclaration PSR2.Classes.PropertyDeclaration PSR2.ControlStructures.ControlStructureSpacing PSR2.ControlStructures.ElseIfDeclaration PSR2.ControlStructures.SwitchDeclaration PSR2.Files.ClosingTag PSR2.Files.EndFileNewline PSR2.Methods.FunctionCallSignature PSR2.Methods.FunctionClosingBrace PSR2.Methods.MethodDeclaration PSR2.Namespaces.NamespaceDeclaration PSR2.Namespaces.UseDeclaration Squiz (14 sniffs) ----------------- Squiz.Classes.ValidClassName Squiz.ControlStructures.ControlSignature Squiz.ControlStructures.ForEachLoopDeclaration Squiz.ControlStructures.ForLoopDeclaration Squiz.ControlStructures.LowercaseDeclaration Squiz.Functions.FunctionDeclaration Squiz.Functions.FunctionDeclarationArgumentSpacing Squiz.Functions.LowercaseFunctionKeywords Squiz.Functions.MultiLineFunctionDeclaration Squiz.Scope.MethodScope Squiz.WhiteSpace.ControlStructureSpacing Squiz.WhiteSpace.ScopeClosingBrace Squiz.WhiteSpace.ScopeKeywordSpacing Squiz.WhiteSpace.SuperfluousWhitespace ","date":"2018-02-07","objectID":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/:1:3","tags":["PHP"],"title":"PHP 编码标准插件","uri":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/"},{"categories":["PHP"],"content":"使用 CodeSniffer 格式化代码 请自行创建工程去测试。 CodeSniffer 格式化前的不规范代码 \u003c?php namespace Nilnice\\Acme; class Finder{ public const IGNORE_VCS_FILES =1; public const IGNORE_DOT_FILES=2; private $ignore = 0; public function __construct(){ $this-\u003e ignore=static::IGNORE_VCS_FILES|static::IGNORE_DOT_FILES ; } public function getIterator() { if (0===count($this-\u003edirs)\u0026\u00260===count($this-\u003eiterators)){ throw new \\LogicException('You must call one of in() or append() methods before iterating over a Finder.'); } if(1===count( $this-\u003edirs ) \u0026\u00260 ===count($this-\u003eiterators)){ return $this -\u003esearchInDirectory( $this-\u003edirs[0]); } $iterator=new \\AppendIterator (); foreach ($this-\u003e dirs as $dir) { $iterator-\u003eappend($this-\u003esearchInDirectory( $dir )) ; } foreach ( $this-\u003eiterators as $it) { $iterator-\u003eappend( $it); } return$iterator; }} 经过 phpcs 检查后的报告 怎么样，这个检查结果明码标价，童叟无欺矣！ 使用 phpcbf 修理代码 // 指定文件修理 $ phpcbf ./src/Test.php 修理后的代码样式 \u003c?php namespace Nilnice\\Acme; class Finder { public const IGNORE_VCS_FILES = 1; public const IGNORE_DOT_FILES = 2; private $ignore = 0; public function __construct() { $this-\u003e ignore = static::IGNORE_VCS_FILES | static::IGNORE_DOT_FILES ; }//end __construct() public function getIterator() { if (0 === count($this-\u003edirs)\u0026\u00260 === count($this-\u003eiterators)) { throw new \\LogicException('You must call one of in() or append() methods before iterating over a Finder.'); } if (1 === count($this-\u003edirs) \u0026\u00260 === count($this-\u003eiterators)) { return $this -\u003esearchInDirectory($this-\u003edirs[0]); } $iterator = new \\AppendIterator(); foreach ($this-\u003e dirs as $dir) { $iterator-\u003eappend($this-\u003esearchInDirectory($dir)); } foreach ($this-\u003eiterators as $it) { $iterator-\u003eappend($it); } return$iterator; }//end getIterator() }//end class // 此处多一空行 ","date":"2018-02-07","objectID":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/:1:4","tags":["PHP"],"title":"PHP 编码标准插件","uri":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/"},{"categories":["PHP"],"content":"PHP Coding Standards Fixer PHP Coding Standards Fixer Website PHP Coding Standards Fixer GitHub ","date":"2018-02-07","objectID":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/:2:0","tags":["PHP"],"title":"PHP 编码标准插件","uri":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/"},{"categories":["PHP"],"content":"Fixer 安装 Curl 或 Wget 方式安装 $ wget http://cs.sensiolabs.org/download/php-cs-fixer-v2.phar -O php-cs-fixer 或 $ wget https://github.com/FriendsOfPHP/PHP-CS-Fixer/releases/download/v2.10.2/php-cs-fixer.phar -O php-cs-fixer 或 $ curl -L http://cs.sensiolabs.org/download/php-cs-fixer-v2.phar -o php-cs-fixer $ sudo chmod +x php-cs-fixer $ sudo mv php-cs-fixer /usr/local/bin/php-cs-fixer Composer 安装 Fixer $ composer global require friendsofphp/php-cs-fixer // 如果之前设置过，就不需要 $ export PATH=\"$PATH:$HOME/.composer/vendor/bin\" Homebrew 安装 Fixer // 先搜索 fixer 以确定名称后再安装 $ brew install homebrew/php/php-cs-fixer ","date":"2018-02-07","objectID":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/:2:1","tags":["PHP"],"title":"PHP 编码标准插件","uri":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/"},{"categories":["PHP"],"content":"使用 Fixer 格式化代码 使用 Fixer 格式化前的不规范代码 \u003c?php declare(strict_types=1); namespace A ; use SebastianBergmann\\CodeCoverage\\InvalidArgumentException ; abstract class Foo extends FooBaseClass implements Bar1 , Bar2 , Bar3{ protected const FIRST='first'; protected const SECOND=0; protected const Z = -1; public const E_FOO = 200; public const E_BAR = 400; private $isNull = null ; protected $hello, $world; public $numbers=array('one','two','three','four','five','six'); public $v = 0; public $path = 'root'; public function bar( $v, $w = 'a' ) { $y = $w; $result = foo( 'arg1', 'arg2', 10 ); switch ($v) { case 0: return 1; case 1 : echo '1'; break; case 2: break; default: $result = 10; } return$result; } static public function fOne( $argA, $argB, $argC, $argD, $argE, $argF, $argG, $argH){ $x = $argA + $argB + $argC + $argD + $argE + $argF + $argG + $argH; list($field1, $field2, $field3, $filed4, $field5, $field6) = explode(',', $x); fTwo( $argA, $argB, $argC, fThree( $argD, $argE, $argF, $argG, $argH ) ); $z = $argA === 'Some string' ? 'yes' : 'no'; $colors = [ 'red', 'green', 'blue', 'black' , 'white', 'gray' , ]; $count=count($colors); for ($i = 0; $i \u003c $count; $i++) { $colorString = $colors[$i]; } } public function fTwo( $strA, $strB, $strC, $strD ){ if ($strA === 'one' || $strB === 'two' || $strC === 'three') { return $strA + $strB + $strC; } if ($strA==='hello'){$strB = 'world';} if($strB==='second') { $strA=null; throw new \\InvalidArgumentException('Invalid argument.'); } $x = $foo-\u003eone('a', 'b') -\u003etwo('c', 'd', 'e') -\u003ethree('fg')-\u003e four(); $y = a() -\u003e b() -\u003ec (); return $strD; } public function fThree( $strA, $strB, $strC, $strD, $strE ) { try { } catch (Exception $e) { foo(); } finally { // do something } return $strA + $strB + $strC + $strD + $strE;} abstract protected function fFour(); } final class Bar{ public final function foo($x,$z){ global $k, $s1; $obj-\u003efoo()-\u003ebar(); $arr =array(0 =\u003e 'zero', 1 =\u003e 'one'); call_func(function () { return 0; }); for ($i = 0; $i \u003c $x; $i++) { $y+= ($y^0x123) \u003c\u003c 2; } $k = $x \u003e 15 ? 1 : 2; $k = $x ?: 0; $k = $x ?? $z; $k = $x\u003c=\u003e$z; do { try { if (!0 \u003e $x \u0026\u0026 ! $x \u003c 10){ while ($x !== $y){ $x = f($x * 3 + 5); } $z += 2; } elseif ($x \u003e 20) { $z = $x \u003c\u003c1; } else { $z = $x|2; } $j = intval($z); switch ($j) { case 0: $s1=strval('100'); break; case 2: $s1 = 'two'; break; default: $s1 = 'other'; } } catch (\\Exception $e) { $t = $one[0]; $u = $one['str']; $v = $one[$x[1]]; echo $val{foo . $num}[$cell{$a}]; }finally{// do something } }while ($x \u003c0); } } function foo() { return 0; } function bar( $x, $y, int $z = 1 ){ $x = 0; // $x = 1 do{$y += 1;} while ($y \u003c 10); if(true){$x = 10;}elseif ($y \u003c 10) {$x=5;}elseif (true) {$x= 5 ;} for ($i = 0; $i \u003c 10; $i++){$yy=$x\u003e2?1:2;} while( true ) {$x=0;} do{$x += 1;}while( true ) ; foreach ([ 'a' =\u003e 0, 'b' =\u003e 1, 'c'=\u003e2, ] as $e1) {echo$e1;} $count = 10; $x = [ 'x','y', [ 1 =\u003e 'abc', 2 =\u003e 'def', 3 =\u003e 'ghi' ], ]; $zz = [ 0.1, 0.2, 0.3, 0.4, ]; $x = [ 0 =\u003e 'zero', 123 =\u003e 'one two three', 25 =\u003e 'two five' ]; bar(0, bar( 1, 'b' )); } function foobar( $a ):Bar { $a=null ===$a?$a:new $a; include('a.php'); } function emptyreturn() { return; } $map = array_map (function( $value ) { return$value + 10; }, $array ); ?\u003e \u003cdiv\u003e\u003c?= foo() ?\u003e\u003c/div\u003e 自定义代码修复格式 创建 .php_cs 文件，并写入以下内容。 \u003c?php require __DIR__ . '/vendor/autoload.php'; use PhpCsFixer\\Config; use PhpCsFixer\\Finder; $finder = Finder::create()-\u003ein(__DIR__ . '/src'); return Config::create() -\u003esetRiskyAllowed(true) -\u003esetCacheFile(__DIR__ . '/.php_cs.cache') -\u003esetRules([ '@PSR2' =\u003e true, // 使用 PSR2 标准 'array_syntax' =\u003e [ 'syntax' =\u003e 'short', // 数组使用短语法 ], 'binary_operator_spaces' =\u003e [ 'align_double_arrow' =\u003e false, // 不对齐双箭头操作符 'align_equals' =\u003e false, // 不对齐赋值操作符 ], 'blank_line_after_namespace' =\u003e true, // 命名空间之后有一个空行 'blank_line_after_opening_tag' =\u003e true, // PHP 打开标记之后有一个空行 'blank_line_before_return' =\u003e true, // return 语句之前有一个空行 'blank_line_before_statement' =\u003e [ 'statements' =\u003e [ 'break', 'continue', 'declare', 'return', 'throw', 't","date":"2018-02-07","objectID":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/:2:2","tags":["PHP"],"title":"PHP 编码标准插件","uri":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/"},{"categories":["PHP"],"content":"结论 ","date":"2018-02-07","objectID":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/:3:0","tags":["PHP"],"title":"PHP 编码标准插件","uri":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/"},{"categories":["PHP"],"content":"原始代码 \u003c?php $result = []; $array = [ 'x' =\u003e 0 , 'a' =\u003e 1 , 'b' =\u003e 2 , 'c' =\u003e 3 , 'd' =\u003e 4 , 'e' =\u003e 5 , 'f' =\u003e 6 , 'g' =\u003e 7 , 'y' =\u003e 8 , 'z' =\u003e 9, ]; foreach ($array as $key =\u003e $val) { if (in_array($key, ['a', 'b', 'c'], true)) { continue; } $result[$key] = $val; } ","date":"2018-02-07","objectID":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/:3:1","tags":["PHP"],"title":"PHP 编码标准插件","uri":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/"},{"categories":["PHP"],"content":"PHP_CodeSniffer 格式化 执行 phpcbf ./src/Test.php 后： \u003c?php $result = []; $array = [ 'x' =\u003e 0 , 'a' =\u003e 1 , 'b' =\u003e 2 , 'c' =\u003e 3 , 'd' =\u003e 4 , 'e' =\u003e 5 , 'f' =\u003e 6 , 'g' =\u003e 7 , 'y' =\u003e 8 , 'z' =\u003e 9, ]; foreach ($array as $key =\u003e $val) { if (in_array($key, ['a', 'b', 'c'], true)) { continue; } $result[$key] = $val; } ","date":"2018-02-07","objectID":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/:3:2","tags":["PHP"],"title":"PHP 编码标准插件","uri":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/"},{"categories":["PHP"],"content":"PHP-CS-Fixer 格式化 执行 php-cs-fixer fix ./src/Test.php 后： \u003c?php $result = []; $array = [ 'x' =\u003e 0 , 'a' =\u003e 1 , 'b' =\u003e 2 , 'c' =\u003e 3 , 'd' =\u003e 4 , 'e' =\u003e 5 , 'f' =\u003e 6 , 'g' =\u003e 7 , 'y' =\u003e 8 , 'z' =\u003e 9, ]; foreach ($array as $key =\u003e $val) { if (in_array($key, ['a', 'b', 'c'], true)) { continue; } $result[$key] = $val; } 经过对两个工具的使用，发现各有所长，PHP_CodeSniffer 囊括代码质量检测和自动修复，而 PHP-CS-Fixer 则只有自动修复功能，无论哪种工具，在我测试的过程中，都没法把用户主动添加的一些空格给利索的去掉，略有点失望。 ","date":"2018-02-07","objectID":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/:3:3","tags":["PHP"],"title":"PHP 编码标准插件","uri":"/posts/php-%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%E6%8F%92%E4%BB%B6/"},{"categories":["Mac"],"content":"一行命令搞定你要安装的软件，省掉了自己去下载、解压、拖拽这些操作，Cask 你值得拥有 ","date":"2018-02-05","objectID":"/posts/mac-homebrew-cask/:0:0","tags":["Mac"],"title":"Mac Homebrew Cask","uri":"/posts/mac-homebrew-cask/"},{"categories":["Mac"],"content":"简介 Homebrew Cask Website Homebrew Cask GitHub Homebrew Cask Documentation Homebrew Cask Package Search A CLI workflow for the administration of macOS applications distributed as binaries. ","date":"2018-02-05","objectID":"/posts/mac-homebrew-cask/:1:0","tags":["Mac"],"title":"Mac Homebrew Cask","uri":"/posts/mac-homebrew-cask/"},{"categories":["Mac"],"content":"安装 $ brew tap caskroom/cask ","date":"2018-02-05","objectID":"/posts/mac-homebrew-cask/:2:0","tags":["Mac"],"title":"Mac Homebrew Cask","uri":"/posts/mac-homebrew-cask/"},{"categories":["Mac"],"content":"操作 // 安装应用软件 $ brew cask install package-name // 卸载应用软件 $ brew cask uninstall package-name // 更新应用软件 $ brew cask reinstall package-name // 搜索应用软件 $ brew cask search package-name // 查看应用软件详情 $ brew cask info package-name // 查看安装软件列表 $ brew cask list // 检查配置问题 $ brew cask doctor // 清理缓存下载和跟踪符号链接 $ brew cask cleanup // 转到主页 $ brew cask home // 查看版本 $ brew cask --version // 查看帮助命令 $ brew cask help ","date":"2018-02-05","objectID":"/posts/mac-homebrew-cask/:3:0","tags":["Mac"],"title":"Mac Homebrew Cask","uri":"/posts/mac-homebrew-cask/"},{"categories":["Mac"],"content":"参考 brew 和 brew cask 有什么区别？ Homebrew cask 让 macOS 锦上添花 ","date":"2018-02-05","objectID":"/posts/mac-homebrew-cask/:4:0","tags":["Mac"],"title":"Mac Homebrew Cask","uri":"/posts/mac-homebrew-cask/"},{"categories":["Mac"],"content":"以前用 Windows 的时候几乎不怎么关注效率，什么什么软件有多牛逼呀这种事情（当然我不是说 Windows 不牛逼，他们都特么牛逼），基本上是以完成任务为目标，除了开发工具其它的都不怎么折腾，自从有了 Mac 后我也折腾了一翻。 ","date":"2018-02-04","objectID":"/posts/mac-necessary-tools/:0:0","tags":["Mac"],"title":"Mac 那些居家必备的工具","uri":"/posts/mac-necessary-tools/"},{"categories":["Mac"],"content":"命令行工具 ","date":"2018-02-04","objectID":"/posts/mac-necessary-tools/:1:0","tags":["Mac"],"title":"Mac 那些居家必备的工具","uri":"/posts/mac-necessary-tools/"},{"categories":["Mac"],"content":"效率工具 Homebrew Homebrew Website Homebrew GitHub Homebrew Documentation Homebrew Formulae The missing package manager for macOS. 可能是 macOS 最好用的包管理器，我不管，我就是这么认为的 // 安装 $ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" // 卸载 $ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\" Oh My Zsh Oh My Zsh Website Oh My Zsh GitHub Oh My Zsh Documentation 为什么说 zsh 是 shell 中的极品？ Your terminal never felt this good before. 池老说过，这是终极 shell，很多人都认为它是 shell 中的极品 // 安装：curl 或者 wget 方式 $ sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" 或 sh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\" // 卸载 $ uninstall_oh_my_zsh zsh-autosuggestions zsh-autosuggestions GitHub zsh-autosuggestions Documentation 强大 Zsh 的命令提示。 $ brew install zsh-autosuggestions $ vim ~/.zshrc source /usr/local/share/zsh-autosuggestions/zsh-autosuggestions.zsh $ source ~/.zshrc iTerm2 iTerm2 Website iTerm2 GitHub iTerm2 Documentation iTerm2 Downloads iTerm2 is a terminal emulator for macOS that does amazing things. 不能没有的仿真终端，而且还是免费的，良心软件呀！ Vim Ultimate Vim Website Ultimate Vim GitHub Ultimate Vim Documentation // 安装 $ curl http://j.mp/spf13-vim3 -L -o - | sh 或者 $ curl https://j.mp/spf13-vim3 -L \u003e spf13-vim.sh \u0026\u0026 sh spf13-vim.sh // 卸载 $ sh ~/.spf13-vim-3/uninstall.sh The Ultimate Vim Distribution. 用过 Vim，但想用终级 Vim，你就试试。 ","date":"2018-02-04","objectID":"/posts/mac-necessary-tools/:1:1","tags":["Mac"],"title":"Mac 那些居家必备的工具","uri":"/posts/mac-necessary-tools/"},{"categories":["Mac"],"content":"开发工具 Git Git - Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. Git is easy to learn and has a tiny footprint with lightning fast performance. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like cheap local branching, convenient staging areas, and multiple workflows. 这个年头你要是不会用 git，出门会被人嘲笑的，尤其是程序员。 {% note warning %} 一般情况下，不需要安装，因为 Xcode Command Line Tools 就自带。 {% endnote %} // 安装 $ brew install git // 卸载 $ brew uninstall git Curl Curl - Command line tool and library for transferring data with URLs. curl is used in command lines or scripts to transfer data. It is also used in cars, television sets, routers, printers, audio equipment, mobile phones, tablets, settop boxes, media players and is the internet transfer backbone for thousands of software applications affecting billions of humans daily. 不会使用这个工具，你也配谈互联网，别回头，说的就是你 // 安装 $ brew install curl // 卸载 $ brew uninstall curl ","date":"2018-02-04","objectID":"/posts/mac-necessary-tools/:1:2","tags":["Mac"],"title":"Mac 那些居家必备的工具","uri":"/posts/mac-necessary-tools/"},{"categories":["Mac"],"content":"窗体工具 ","date":"2018-02-04","objectID":"/posts/mac-necessary-tools/:2:0","tags":["Mac"],"title":"Mac 那些居家必备的工具","uri":"/posts/mac-necessary-tools/"},{"categories":["Mac"],"content":"效率工具 @hzlzh 已经做过一个非常优秀的食谱 - Best App，里面列出了很多优秀的软件，但是呢，这个太多了，我是断不可能把这么多软件都用的出神入化，能常用的可能真没几个，也可能是我孤陋寡闻，没见过真正的大神是怎么把这么多工具用的登峰造极的，不过感谢 @hzlzh 和维护这份食谱的伙伴们，有你们这样的极客，才成就了更多人的方便 Alfred Alfred is an award-winning app for Mac OS X which boosts your efficiency with hotkeys, keywords, text expansion and more. Search your Mac and the web, and be more productive with custom actions to control your Mac. macOS 的神兵利器，迄今为止最具效率的软件，没有之一，不解释 Alfred Workflow 让你随心所欲： 如何编写 Alfred 使用的 Workflow，需要掌握哪些知识？ 借助 Alfred 的 Workflows 功能可以做哪些好玩的事情？ 写不了 Workflows 我就用别人的 Workflows，我有点无耻 1Password 1Password remembers them all for you. Save your passwords and log in to sites with a single click. It’s that simple. 原来管理密码账号也那么轻松呀，谁用谁知道，不解释 iStat Menus 6 iStat Menus 6 - An advanced Mac system monitor for your menubar. 菜单栏监视系统运行状况，强迫症必备 Bartender 3 Bartender 3 - Organize your menu bar apps. Bartender 3 lets you organize your menu bar apps, by hiding them, rearranging them, or moving them to the Bartender Items. You can display the full menu bar, set options to have menu bar items show in the menu bar when they have updated, or have them visible in the Bartender Items whenever you want. 聚合菜单栏图标，强迫症必备 CleanMyMac 3 CleanMyMac 3 - Clean, optimize, and maintain your Mac with the all-new CleanMyMac 3. It scans every inch of your system, removes gigabytes of junk in just two clicks, and monitors the health of your Mac. 清理、优化、维护系统，但比流氓的节操要高，有底线 Paste Paste - Never lose anything you’ve copied on your Mac again. Paste automatically stores everything you copy across all your devices and keeps your clipboard history organized. 运维的最爱，当然，它也可以是你的真爱，Time machine for your clipboard，不是盖的，从此复制粘贴如行云流水 aText aText Typing Accelerator - aText accelerates your typing by replacing abbreviations with frequently used phrases you define. 羡慕过别人的输入速度，你是不是也蠢蠢欲动，try 一下这个，你也可以的 MWeb Mweb - MWeb for Mac, iPad and iPhone，专业的 Markdown 写作、记笔记、静态博客生成软件 最好的 Markdown 写作软件之一 是的，Markdown 写作软件比较多，各人有各人的喜好吧，像我偏爱 Mweb 多一点而已。每个人的使用场景不尽相同，所以呢，自己挑吧，反正有这么多选择呢，友情提示：不要挑花眼了，选一两个就好，毕竟写才是目的嘛 同样在使用同样的工具，有些人真就把工具用出了花，这个境界，我也得试一下 码字必备：18 款优秀的 Markdown 写作工具 | 2015 年度盘点 让你爱上写作的 11 款 Markdown 工具 | 专题 · 写作 用 Markdown 写作用什么文本编辑器？ Quick Look Plugin Quick Look Plugin 快速预览的插件，无论图片、文本，不试一下怎么知道呢？请先安装 Homebrew Cask $ brew cask install qlcolorcode qlstephen qlmarkdown quicklook-json qlimagesize webpquicklook suspicious-package quicklookase qlvideo ","date":"2018-02-04","objectID":"/posts/mac-necessary-tools/:2:1","tags":["Mac"],"title":"Mac 那些居家必备的工具","uri":"/posts/mac-necessary-tools/"},{"categories":["Mac"],"content":"开发工具 JetBrains IDE JetBrains 全家桶 - Whichever technologies you use, there’s a JetBrains tool to match. 你就对号入座吧，我是 PHPer，我选 PhpStorm Visual Studio Code Visual Studio Code - Code editing. Redefined. Free. Open source. Runs everywhere. Visual Studio Code is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, macOS and Linux. It comes with built-in support for JavaScript, TypeScript and Node.js and has a rich ecosystem of extensions for other languages (such as C++, C#, Java, Python, PHP, Go) and runtimes (such as .NET and Unity). Begin your journey with VS Code with these introductory videos. 宇宙最强的编辑器难道不是 Vim or Emacs，NO NO NO，你也看见了，微软向来不服呀 Sublime Text 3 Sublime Text 3 - A sophisticated text editor for code, markup and prose. 这个我就不说了，快捷键设置的最为优雅，所以我把 PhpStorm 和 Visual Studio Code 的快捷键都映射成了 Sublime 这个德性，一套快捷键一统江湖 未完待续。。。 ","date":"2018-02-04","objectID":"/posts/mac-necessary-tools/:2:2","tags":["Mac"],"title":"Mac 那些居家必备的工具","uri":"/posts/mac-necessary-tools/"},{"categories":["PHP"],"content":"Xdebug is an extension for PHP, and provides a range of features to improve the PHP development experience. ","date":"2018-01-30","objectID":"/posts/php-xdebug/:0:0","tags":["PHP"],"title":"PHP 安装 Xdebug 扩展来调试程序","uri":"/posts/php-xdebug/"},{"categories":["PHP"],"content":"概述 Xdebug Website Xdebug GitHub Xdebug 是 PHP 的一个扩展，以协助调试和开发。它包含一个 single step debugger 与 IDEs 一起使用；它升级了 PHP 的 var_dump() 函数；它为通知、警告、错误和异常添加了堆栈跟踪；它具有记录每个函数调用和变量赋值到磁盘的功能；它包含一个分析器；并且提供了与 PHPUnit 一起使用时的代码覆盖功能。 ","date":"2018-01-30","objectID":"/posts/php-xdebug/:1:0","tags":["PHP"],"title":"PHP 安装 Xdebug 扩展来调试程序","uri":"/posts/php-xdebug/"},{"categories":["PHP"],"content":"安装 ","date":"2018-01-30","objectID":"/posts/php-xdebug/:2:0","tags":["PHP"],"title":"PHP 安装 Xdebug 扩展来调试程序","uri":"/posts/php-xdebug/"},{"categories":["PHP"],"content":"Mac 安装 $ brew install homebrew/php/php71-xdebug ","date":"2018-01-30","objectID":"/posts/php-xdebug/:2:1","tags":["PHP"],"title":"PHP 安装 Xdebug 扩展来调试程序","uri":"/posts/php-xdebug/"},{"categories":["PHP"],"content":"Linux 安装 $ git clone https://github.com/xdebug/xdebug.git $ cd xdebug $ phpize $ ./configure --enable-xdebug --with-php-config=/usr/local/bin/php-config $ sudo make clean $ sudo make $ sudo make install ","date":"2018-01-30","objectID":"/posts/php-xdebug/:2:2","tags":["PHP"],"title":"PHP 安装 Xdebug 扩展来调试程序","uri":"/posts/php-xdebug/"},{"categories":["PHP"],"content":"Windows 安装 Xdebug Download Page 下载对应的 Windows 版本，将 php_xdebug-*.dll 复制到相应的文件中 ","date":"2018-01-30","objectID":"/posts/php-xdebug/:2:3","tags":["PHP"],"title":"PHP 安装 Xdebug 扩展来调试程序","uri":"/posts/php-xdebug/"},{"categories":["PHP"],"content":"配置 ","date":"2018-01-30","objectID":"/posts/php-xdebug/:3:0","tags":["PHP"],"title":"PHP 安装 Xdebug 扩展来调试程序","uri":"/posts/php-xdebug/"},{"categories":["PHP"],"content":"将生成的 xdebug.so 添加到 php.ini 文件中 由于不同的安装方式，配置文件的路径可能不太一样。有的扩展可能需要单独的文件去配置 [xdebug] zend_extension=\"/path/to/xdebug.so\" ","date":"2018-01-30","objectID":"/posts/php-xdebug/:3:1","tags":["PHP"],"title":"PHP 安装 Xdebug 扩展来调试程序","uri":"/posts/php-xdebug/"},{"categories":["PHP"],"content":"重启 php-fpm // Mac $ brew services restart php71 // Linux $ sudo systemctl restart php71-fpm ","date":"2018-01-30","objectID":"/posts/php-xdebug/:3:2","tags":["PHP"],"title":"PHP 安装 Xdebug 扩展来调试程序","uri":"/posts/php-xdebug/"},{"categories":["PHP"],"content":"查看 xdebug 是否正确安装 $ php -i | grep xdebug /usr/local/etc/php/7.1/conf.d/ext-xdebug.ini xdebug xdebug support =\u003e enabled # 说明已经安装成功 或者 $ php --ini | grep xdebug /path/to/conf.d/ext-xdebug.ini $ cat /path/to/conf.d/ext-xdebug.ini [xdebug] zend_extension=\"/usr/local/opt/php71-xdebug/xdebug.so\" 或者 $ php --ri xdebug xdebug xdebug support =\u003e enabled ","date":"2018-01-30","objectID":"/posts/php-xdebug/:3:3","tags":["PHP"],"title":"PHP 安装 Xdebug 扩展来调试程序","uri":"/posts/php-xdebug/"},{"categories":["PHP"],"content":"进阶 当你习惯了使用 var_dump()，echo，dd()，print_r()，print 等这种方式调试代码，那么从现在起咱们换一种轻松的方式来调试代码。 ","date":"2018-01-30","objectID":"/posts/php-xdebug/:4:0","tags":["PHP"],"title":"PHP 安装 Xdebug 扩展来调试程序","uri":"/posts/php-xdebug/"},{"categories":["PHP"],"content":"配置 Xdebug 参数 使用 Homebrew 安装 PHP 环境后，在安装扩展时，一般会单独去加载扩展的配置 $ vim /path/to/ext-xdebug.ini [xdebug] zend_extension=\"/usr/local/opt/php71-xdebug/xdebug.so\" xdebug.remote_enable = 1 xdebug.idekey = PHPSTORM xdebug.remote_port = 9001 xdebug.collect_vars = On xdebug.collect_params = 4 xdebug.dump_globals = On xdebug.dump.SERVER = REQUEST_URI xdebug.show_local_vars = On ","date":"2018-01-30","objectID":"/posts/php-xdebug/:4:1","tags":["PHP"],"title":"PHP 安装 Xdebug 扩展来调试程序","uri":"/posts/php-xdebug/"},{"categories":["PHP"],"content":"配置 PhpStorm IDE ","date":"2018-01-30","objectID":"/posts/php-xdebug/:4:2","tags":["PHP"],"title":"PHP 安装 Xdebug 扩展来调试程序","uri":"/posts/php-xdebug/"},{"categories":["PHP"],"content":"效果 对了，由于最近在调试支付宝接口，看到一些错误提示码代码，没有上下文的提示，加上本人特懒，不想在多次的调试中调试跟踪，面对这些绝望的错误提示，懵逼于此，好在我望眼欲穿的时候，猛然间想起了有个叫 xdebug 东东，真特么靠谱，这也是这篇文章的由来，花了十几分钟的工夫把这货安置妥当，就走上了调试的漫漫长路，你看神马错误上下文一览无余的原形毕露，调试代码怎一个爽字了得，不说了看图。 ","date":"2018-01-30","objectID":"/posts/php-xdebug/:4:3","tags":["PHP"],"title":"PHP 安装 Xdebug 扩展来调试程序","uri":"/posts/php-xdebug/"},{"categories":["PHP"],"content":"项目调试 ","date":"2018-01-30","objectID":"/posts/php-xdebug/:5:0","tags":["PHP"],"title":"PHP 安装 Xdebug 扩展来调试程序","uri":"/posts/php-xdebug/"},{"categories":["PHP"],"content":"配置 Xdebug [xdebug] zend_extension=\"/usr/local/opt/php71-xdebug/xdebug.so\" xdebug.remote_enable = 1 xdebug.idekey = PHPSTORM xdebug.remote_port = 9001 xdebug.remote_connect_back = 1 xdebug.profiler_enable = 1 ","date":"2018-01-30","objectID":"/posts/php-xdebug/:5:1","tags":["PHP"],"title":"PHP 安装 Xdebug 扩展来调试程序","uri":"/posts/php-xdebug/"},{"categories":["PHP"],"content":"配置 PhpStorm PHP Debug DBGp Proxy 配置完成后重启 php-fpm。 PHP Servers 如果是虚拟机开发，请配置项目路径映射。 PHP Debug Configurations Server 这里选择上一步配置的 Server 就好。 项目调试效果图 当浏览器运行指定的 URL，也就是 PHP Web Application 配置的 Start URL 时，出现 Xdebug 控制台，根据控制台来进行操作 调试窗口说明： Debugger：调试器，比如：跳过，单步调试等操作 Frames：运行的帧，当前项目调试时载入的关联程序 Variables：调试中的所有变量 Watches：监视器，自定义变量监视 ","date":"2018-01-30","objectID":"/posts/php-xdebug/:5:2","tags":["PHP"],"title":"PHP 安装 Xdebug 扩展来调试程序","uri":"/posts/php-xdebug/"},{"categories":["PHP"],"content":"参考 Configuring Xdebug ","date":"2018-01-30","objectID":"/posts/php-xdebug/:6:0","tags":["PHP"],"title":"PHP 安装 Xdebug 扩展来调试程序","uri":"/posts/php-xdebug/"},{"categories":["Git"],"content":"最近遇到这样的需求，需要在一台电脑上同时使用两个 github 账号，负责不同的用途，比如：一个用来写个人项目，一个用来写公司的项目。 Git 起步 Git 基本操作 Git 查看日志 Git 分支 Git 中一个客户端设置多个账号 Git Workflow Git 命令大全 ","date":"2018-01-27","objectID":"/posts/git-multiple-accounts/:0:0","tags":["Git"],"title":"Git 中一个客户端设置多个账号","uri":"/posts/git-multiple-accounts/"},{"categories":["Git"],"content":"配置 ","date":"2018-01-27","objectID":"/posts/git-multiple-accounts/:1:0","tags":["Git"],"title":"Git 中一个客户端设置多个账号","uri":"/posts/git-multiple-accounts/"},{"categories":["Git"],"content":"注册两个 git 账号 选择一个平台注册两个账号即可。 GitHub Gitee Coding Bitbucket GitLab ","date":"2018-01-27","objectID":"/posts/git-multiple-accounts/:1:1","tags":["Git"],"title":"Git 中一个客户端设置多个账号","uri":"/posts/git-multiple-accounts/"},{"categories":["Git"],"content":"取消全局设置的用户名和邮箱 // 取消全局用户名和邮箱 $ git config --global --unset user.name $ git config --global --unset user.email ","date":"2018-01-27","objectID":"/posts/git-multiple-accounts/:1:2","tags":["Git"],"title":"Git 中一个客户端设置多个账号","uri":"/posts/git-multiple-accounts/"},{"categories":["Git"],"content":"SSH 配置 ","date":"2018-01-27","objectID":"/posts/git-multiple-accounts/:2:0","tags":["Git"],"title":"Git 中一个客户端设置多个账号","uri":"/posts/git-multiple-accounts/"},{"categories":["Git"],"content":"生成私钥和公钥 如果用户家目录下没有 .ssh 目录，请自行创建 由于我注册多家平台的 git 账号，所以对其进行了一个文件目录分类 $ mkdir -pv ~/.ssh/github # gitee|coding|bitbucket|gitlab $ ssh-keygen -t rsa -C \"myfirst@gmail.com\" # 在回车提示中输入完整路径，如：/path/to/user/.ssh/github/id_myfirst_rsa Generating public/private rsa key pair. Enter file in which to save the key (/path/to/user/.ssh/id_rsa):/path/to/user/.ssh/github/id_myfirst_rsa $ ssh-keygen -t rsa -C \"mysecond@gmail.com\" # 在回车提示中输入完整路径，如：/path/to/user/.ssh/github/id_mysecond_rsa Generating public/private rsa key pair. Enter file in which to save the key (/path/to/user/.ssh/id_rsa):/path/to/user/.ssh/github/id_mysecond_rsa 分别配置两个账号的 SSH and GPG keys 在 Settings 控制面板中找到 SSH and GPG keys，点击 New SSH Key 进行添加，Title 请自行决定。 ","date":"2018-01-27","objectID":"/posts/git-multiple-accounts/:2:1","tags":["Git"],"title":"Git 中一个客户端设置多个账号","uri":"/posts/git-multiple-accounts/"},{"categories":["Git"],"content":"将密钥添加到 ssh-agent 的会话中 如果执行 ssh-add 时显示错误 Could not open a connection to your authentication agent. 那么执行 eval ssh-agent -s。 $ ssh-add -K ~/.ssh/github/id_myfirst_rsa Identity added: /path/to/.ssh/github/id_myfirst_rsa (/path/to/.ssh/github/id_myfirst_rsa) $ ssh-add -K ~/.ssh/github/id_mysecond_rsa Identity added: /path/to/.ssh/github/id_mysecond_rsa (/path/to/.ssh/github/id_mysecond_rsa) ","date":"2018-01-27","objectID":"/posts/git-multiple-accounts/:2:2","tags":["Git"],"title":"Git 中一个客户端设置多个账号","uri":"/posts/git-multiple-accounts/"},{"categories":["Git"],"content":"查看 ssh key 的设置 $ ssh-add -l 2048 SHA256:ai3jRoAfkqgB2LYtJuQR8QZN1F5XXXXXXXXXXXXXXXX /path/to/.ssh/github/id_myfirst_rsa (RSA) 2048 SHA256:AL2jRoAfkqgB2LYtJuQR8QZN1F5XXXXXXXXXXXXXXXX /path/to/.ssh/github/id_mysecond_rsa (RSA) ","date":"2018-01-27","objectID":"/posts/git-multiple-accounts/:2:3","tags":["Git"],"title":"Git 中一个客户端设置多个账号","uri":"/posts/git-multiple-accounts/"},{"categories":["Git"],"content":"修改 ssh config 文件 $ vim ~/.ssh/config Host * KexAlgorithms +diffie-hellman-group1-sha1 # default: myfirst Host github.com HostName github.com User myfirst PreferredAuthentications publickey IdentityFile ~/.ssh/github/id_myfirst_rsa # mysecond Host mysecond.github.com HostName github.com User mysecond PreferredAuthentications publickey IdentityFile ~/.ssh/github/id_mysecond_rsa ","date":"2018-01-27","objectID":"/posts/git-multiple-accounts/:2:4","tags":["Git"],"title":"Git 中一个客户端设置多个账号","uri":"/posts/git-multiple-accounts/"},{"categories":["Git"],"content":"测试连通性 mysecond.github.com 需要配置 GitHub 的 Host。 // 测试默认用户 myfirst 的连接性 $ ssh -T git@github.com Hi myfirst! You\\'ve successfully authenticated, but GitHub does not provide shell access. // 测试另一个用户 mysecond 的连接性 $ ssh -T git@mysecond.github.com Hi mysecond! You\\'ve successfully authenticated, but GitHub does not provide shell access. ","date":"2018-01-27","objectID":"/posts/git-multiple-accounts/:2:5","tags":["Git"],"title":"Git 中一个客户端设置多个账号","uri":"/posts/git-multiple-accounts/"},{"categories":["Git"],"content":"项目测试 ","date":"2018-01-27","objectID":"/posts/git-multiple-accounts/:3:0","tags":["Git"],"title":"Git 中一个客户端设置多个账号","uri":"/posts/git-multiple-accounts/"},{"categories":["Git"],"content":"创建两个项目目录 $ cd ~/ \u0026\u0026 mkdir -pv {a,b} ","date":"2018-01-27","objectID":"/posts/git-multiple-accounts/:3:1","tags":["Git"],"title":"Git 中一个客户端设置多个账号","uri":"/posts/git-multiple-accounts/"},{"categories":["Git"],"content":"初始化项目 a $ cd ~/a $ git init $ echo \"myfirst\" \u003e README.md $ git add README.md $ git config user.name \"myfirst\" $ git config user.email \"myfirst@gmail.com\" $ git remote add github git@github.com:myfirst/test.git $ git push -u github master Counting objects: 3, done. Writing objects: 100% (3/3), 213 bytes | 213.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To github.com:myfirst/test.git * [new branch] master -\u003e master Branch master set up to track remote branch master from github. ","date":"2018-01-27","objectID":"/posts/git-multiple-accounts/:3:2","tags":["Git"],"title":"Git 中一个客户端设置多个账号","uri":"/posts/git-multiple-accounts/"},{"categories":["Git"],"content":"初始化项目 b $ cd ~/b $ git init $ echo \"mysecond\" \u003e README.md $ git add README.md $ git config user.name \"mysecond\" $ git config user.email \"mysecond@gmail.com\" $ git remote add github git@mysecond.github.com:mysecond/test.git $ git push -u github master Counting objects: 3, done. Writing objects: 100% (3/3), 218 bytes | 218.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To mysecond.github.com:mysecond/test.git * [new branch] master -\u003e master Branch master set up to track remote branch master from github. ","date":"2018-01-27","objectID":"/posts/git-multiple-accounts/:3:3","tags":["Git"],"title":"Git 中一个客户端设置多个账号","uri":"/posts/git-multiple-accounts/"},{"categories":["Mac"],"content":"官方的说法是 macOS 缺失的软件包管理器，个人认为这也许是 macOS 上最好的包管理器。 ","date":"2018-01-26","objectID":"/posts/mac-homebrew/:0:0","tags":["Mac"],"title":"Mac 缺失的包管理 Homebrew","uri":"/posts/mac-homebrew/"},{"categories":["Mac"],"content":"简介 Homebrew Website Homebrew Github Homebrew Documentation The missing package manager for macOS. ","date":"2018-01-26","objectID":"/posts/mac-homebrew/:1:0","tags":["Mac"],"title":"Mac 缺失的包管理 Homebrew","uri":"/posts/mac-homebrew/"},{"categories":["Mac"],"content":"安装 $ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" ","date":"2018-01-26","objectID":"/posts/mac-homebrew/:2:0","tags":["Mac"],"title":"Mac 缺失的包管理 Homebrew","uri":"/posts/mac-homebrew/"},{"categories":["Mac"],"content":"卸载 $ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\" 当然也可以下载 卸载脚本，然后运行 ./uninstall --help 去查看更多卸载选项。 ","date":"2018-01-26","objectID":"/posts/mac-homebrew/:3:0","tags":["Mac"],"title":"Mac 缺失的包管理 Homebrew","uri":"/posts/mac-homebrew/"},{"categories":["Mac"],"content":"更新公式 brew update ","date":"2018-01-26","objectID":"/posts/mac-homebrew/:4:0","tags":["Mac"],"title":"Mac 缺失的包管理 Homebrew","uri":"/posts/mac-homebrew/"},{"categories":["Mac"],"content":"其它操作 ","date":"2018-01-26","objectID":"/posts/mac-homebrew/:5:0","tags":["Mac"],"title":"Mac 缺失的包管理 Homebrew","uri":"/posts/mac-homebrew/"},{"categories":["Mac"],"content":"查找过期的包 $ brew outdated ","date":"2018-01-26","objectID":"/posts/mac-homebrew/:5:1","tags":["Mac"],"title":"Mac 缺失的包管理 Homebrew","uri":"/posts/mac-homebrew/"},{"categories":["Mac"],"content":"升级包 // 升级所有的包 $ brew upgrade or // 升级指定的包 $ brew upgrade \u003cformula\u003e ","date":"2018-01-26","objectID":"/posts/mac-homebrew/:5:2","tags":["Mac"],"title":"Mac 缺失的包管理 Homebrew","uri":"/posts/mac-homebrew/"},{"categories":["Mac"],"content":"安装某个包 $ brew install \u003cformula\u003e ","date":"2018-01-26","objectID":"/posts/mac-homebrew/:5:3","tags":["Mac"],"title":"Mac 缺失的包管理 Homebrew","uri":"/posts/mac-homebrew/"},{"categories":["Mac"],"content":"卸载某个包 $ brew uninstall \u003cformula\u003e ","date":"2018-01-26","objectID":"/posts/mac-homebrew/:5:4","tags":["Mac"],"title":"Mac 缺失的包管理 Homebrew","uri":"/posts/mac-homebrew/"},{"categories":["Mac"],"content":"清理 By default, Homebrew does not uninstall old versions of a formula, so over time you will accumulate old versions. // 清理指定的包 $ brew cleanup \u003cformula\u003e or // 清静所有的包 $ brew cleanup ","date":"2018-01-26","objectID":"/posts/mac-homebrew/:5:5","tags":["Mac"],"title":"Mac 缺失的包管理 Homebrew","uri":"/posts/mac-homebrew/"},{"categories":["Mac"],"content":"破坏的链接清除 $ brew prune ","date":"2018-01-26","objectID":"/posts/mac-homebrew/:5:6","tags":["Mac"],"title":"Mac 缺失的包管理 Homebrew","uri":"/posts/mac-homebrew/"},{"categories":["Mac"],"content":"快速预览文件内容插件 Quick Look plugins $ brew cask install qlcolorcode qlstephen qlmarkdown quicklook-json qlprettypatch quicklook-csv betterzipql qlimagesize webpquicklook suspicious-package ","date":"2018-01-26","objectID":"/posts/mac-homebrew/:5:7","tags":["Mac"],"title":"Mac 缺失的包管理 Homebrew","uri":"/posts/mac-homebrew/"},{"categories":["Mac"],"content":"不能更新的问题 Cannot “brew update” anymore fails to git pull formulas $ cd `brew --prefix` $ git remote add origin https://github.com/mxcl/homebrew.git $ git fetch origin $ git reset --hard origin/master ","date":"2018-01-26","objectID":"/posts/mac-homebrew/:5:8","tags":["Mac"],"title":"Mac 缺失的包管理 Homebrew","uri":"/posts/mac-homebrew/"},{"categories":["Mac"],"content":"其它问题 ","date":"2018-01-26","objectID":"/posts/mac-homebrew/:6:0","tags":["Mac"],"title":"Mac 缺失的包管理 Homebrew","uri":"/posts/mac-homebrew/"},{"categories":["Mac"],"content":"不能安装低版本 PHP 问题 Error: php@7.3 has been disabled because it is a versioned formula $ brew install php@7.3 Running `brew update --auto-update`... Error: php@7.3 has been disabled because it is a versioned formula! $ brew tap shivammathur/php $ brew install shivammathur/php/php@7.3 ","date":"2018-01-26","objectID":"/posts/mac-homebrew/:6:1","tags":["Mac"],"title":"Mac 缺失的包管理 Homebrew","uri":"/posts/mac-homebrew/"},{"categories":["Git"],"content":"分支几乎是 Git 的必杀技，倒不是说其他的版本控制没有分支这个特性，而是 Git 分支早已把其它的版本控制系统分支功能甩了好几条街。这么说不是夸张，因为 Git 的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。同时，因为每次提交时都记录了祖先信息，将来要合并分支时，寻找恰当的合并基础的工作其实已经很显然的摆在那里，所以实现起来非常容易。Git 鼓励开发者频繁使用分支，正是仗着这些特性作保障。 Git 起步 Git 基本操作 Git 查看日志 Git 分支 Git 中一个客户端设置多个账号 Git Workflow Git 命令大全 本地分支 ","date":"2018-01-25","objectID":"/posts/git-branch/:0:0","tags":["Git"],"title":"Git 分支","uri":"/posts/git-branch/"},{"categories":["Git"],"content":"创建分支 // 创建一个名称为 develop 的分支 $ git checkout -b develop Switched to a new branch 'develop' 等价于 $ git branch develop $ git checkout develop ","date":"2018-01-25","objectID":"/posts/git-branch/:1:0","tags":["Git"],"title":"Git 分支","uri":"/posts/git-branch/"},{"categories":["Git"],"content":"删除分支 // 删除一个已经有提交记录但还没有合并到 master 的分支 $ git branch -d develop error: The branch 'develop' is not fully merged. If you are sure you want to delete it, run 'git branch -D develop'. // 确定不合并 develop 分支的任何提交并删除此分支 $ git branch -D develop Deleted branch develop (was 833b688). ","date":"2018-01-25","objectID":"/posts/git-branch/:2:0","tags":["Git"],"title":"Git 分支","uri":"/posts/git-branch/"},{"categories":["Git"],"content":"查看分支 // 查看分支列表 $ git branch * develop feature master // 查看每一个分支的最后一次提交 $ git branch -v * develop 9ad35ee Add index.js feature 992122d Add .editorconfig master 23a0a9e Rename index.php to index.html // 查看哪些分支已经合并到当前分支 $ git branch --merged develop * master // 查看所有包含未合并工作的分支 $ git branch --no-merged feature ","date":"2018-01-25","objectID":"/posts/git-branch/:3:0","tags":["Git"],"title":"Git 分支","uri":"/posts/git-branch/"},{"categories":["Git"],"content":"合并分支 $ git checkout master $ git merge --no-ff develop Merge made by the 'recursive' strategy. README.md | 1 + 1 file changed, 1 insertion(+) ","date":"2018-01-25","objectID":"/posts/git-branch/:4:0","tags":["Git"],"title":"Git 分支","uri":"/posts/git-branch/"},{"categories":["Git"],"content":"分支变基 // 切换到要变基的分支 $ git checkout feature Switched to branch 'feature' // 进行变基 $ git rebase master $ git rebase master First, rewinding head to replay your work on top of it... Applying: Add .editorconfig Applying: Add releases link Using index info to reconstruct a base tree... M README.md Falling back to patching base and 3-way merge... Auto-merging README.md CONFLICT (content): Merge conflict in README.md error: Failed to merge in the changes. Patch failed at 0002 Add releases link Use 'git am --show-current-patch' to see the failed patch Resolve all conflicts manually, mark them as resolved with \"git add/rm \u003cconflicted_files\u003e\", then run \"git rebase --continue\". You can instead skip this commit: run \"git rebase --skip\". To abort and get back to the state before \"git rebase\", run \"git rebase --abort\". // 查看当前的补丁 $ git am --show-current-patch commit 15539736e18fe133f5916a55e8f38ce7b734113a (feature) Author: imajinyun \u003cimajinyun@gmail.com\u003e Date: Mon Dec 31 21:24:59 2018 +0800 Add releases link diff --git a/README.md b/README.md index d467b4f..8ec2025 100644 --- a/README.md +++ b/README.md @@ -2,3 +2,4 @@ [2]: https://symfony.com/projects [3]: https://symfony.com/doc/current/reference/requirements.html [4]: https://symfony.com/doc/current/setup.html +[5]: https://symfony.com/doc/current/contributing/community/releases.html // 解决冲突完成变基 $ vim README.md 冲突的文件内容： [1]: https://symfony.com [2]: https://symfony.com/projects [3]: https://symfony.com/doc/current/reference/requirements.html [4]: https://symfony.com/doc/current/setup.html \u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD [5]: http://semver.org ======= [5]: https://symfony.com/doc/current/contributing/community/releases.html \u003e\u003e\u003e\u003e\u003e\u003e\u003e Add releases link 修复后的文件内容： [1]: https://symfony.com [2]: https://symfony.com/projects [3]: https://symfony.com/doc/current/reference/requirements.html [4]: https://symfony.com/doc/current/setup.html [5]: http://semver.org [6]: https://symfony.com/doc/current/contributing/community/releases.html // 查看仓库状态 $ git status rebase in progress; onto 4830059 You are currently rebasing branch 'feature' on '4830059'. (fix conflicts and then run \"git rebase --continue\") (use \"git rebase --skip\" to skip this patch) (use \"git rebase --abort\" to check out the original branch) Unmerged paths: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) (use \"git add \u003cfile\u003e...\" to mark resolution) both modified: README.md no changes added to commit (use \"git add\" and/or \"git commit -a\") $ git add README.md $ git rebase --continue Applying: Add releases link // 合并此分支代码到 master 分支 $ git checkout master $ git merge --no-ff feature Merge made by the 'recursive' strategy. .editorconfig | 0 README.md | 1 + 2 files changed, 1 insertion(+) create mode 100644 .editorconfig // 变基后的历史记录，可以看到变基使得提交历史更加整洁，日志就像是串行一样 $ git log --oneline --graph * f686948 (HEAD -\u003e master) Merge branch 'feature' to master |\\ | * 78a6bfc (feature) Add releases link | * 34f8649 Add .editorconfig |/ * 4830059 (develop) Merge branch 'develop' to master |\\ | * 04a75c1 Add semver link * | 3bdd3fc Merge branch 'develop' to master |\\ \\ | |/ | * d48ea11 Add setup link |/ * 3513802 Merge branch 'develop' to master |\\ | * 9ad35ee Add index.js | * 0bc04c2 Add index.css |/ * 23a0a9e Rename index.php to index.html * da3c74c Add index.php * 7778db8 Add projects and requirements link * facc111 Add symfony website link * a384a2b Add README.md 其它操作 ","date":"2018-01-25","objectID":"/posts/git-branch/:5:0","tags":["Git"],"title":"Git 分支","uri":"/posts/git-branch/"},{"categories":["Git"],"content":"整合连续多次提交 // 查看提交日志 $ git log --oneline --graph --all * f686948 (HEAD -\u003e master) Merge branch 'feature' to master |\\ | * 78a6bfc (feature) Add releases link | * 34f8649 Add .editorconfig |/ * 4830059 (develop) Merge branch 'develop' to master |\\ | * 04a75c1 Add semver link * | 3bdd3fc Merge branch 'develop' to master |\\ \\ | |/ | * d48ea11 Add setup link |/ * 3513802 Merge branch 'develop' to master |\\ | * 9ad35ee Add index.js | * 0bc04c2 Add index.css |/ * 23a0a9e Rename index.php to index.html * da3c74c Add index.php * 7778db8 Add projects and requirements link * facc111 Add symfony website link * a384a2b Add README.md // 整合最近提交的 2 次记录，commit-id 使用第二次之前的 $ git rebase -i 4830059 弹出的编辑界面内容为： pick 34f8649 Add .editorconfig s 78a6bfc Add releases link # 修改 pick 为 squash 或者 s # Rebase 4830059..f686948 onto 4830059 (2 commands) # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \"squash\", but discard this commit's log message # x, exec = run command (the rest of the line) using shell # d, drop = remove commit # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out 保存后会弹出另一个编辑界面，内容为： # This is a combination of 2 commits. Integrating submission logs # 添加本次的提交日志信息 # This is the 1st commit message: Add .editorconfig # This is the commit message #2: Add releases link # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # Date: Mon Dec 31 20:39:09 2018 +0800 # # interactive rebase in progress; onto 4830059 # Last commands done (2 commands done): # pick 34f8649 Add .editorconfig # squash 78a6bfc Add releases link # No commands remaining. # You are currently rebasing branch 'master' on '4830059'. # # Changes to be committed: # new file: .editorconfig # modified: README.md # [detached HEAD f9fa04a] Integrating submission logs Date: Mon Dec 31 20:39:09 2018 +0800 2 files changed, 1 insertion(+) create mode 100644 .editorconfig Successfully rebased and updated refs/heads/master. // 查看提交日志 * f9fa04a (HEAD -\u003e master) Integrating submission logs * 4830059 (develop) Merge branch 'develop' to master |\\ | * 04a75c1 Add semver link * | 3bdd3fc Merge branch 'develop' to master |\\ \\ | |/ | * d48ea11 Add setup link |/ * 3513802 Merge branch 'develop' to master |\\ | * 9ad35ee Add index.js | * 0bc04c2 Add index.css |/ * 23a0a9e Rename index.php to index.html * da3c74c Add index.php * 7778db8 Add projects and requirements link * facc111 Add symfony website link * a384a2b Add README.md ","date":"2018-01-25","objectID":"/posts/git-branch/:6:0","tags":["Git"],"title":"Git 分支","uri":"/posts/git-branch/"},{"categories":["Git"],"content":"整合间歇多次提交 $ git log --oneline --graph * f9fa04a (HEAD -\u003e master) Integrating submission logs * 4830059 (develop) Merge branch 'develop' to master |\\ | * 04a75c1 Add semver link * | 3bdd3fc Merge branch 'develop' to master |\\ \\ | |/ | * d48ea11 Add setup link |/ * 3513802 Merge branch 'develop' to master |\\ | * 9ad35ee Add index.js | * 0bc04c2 Add index.css |/ * 23a0a9e Rename index.php to index.html * da3c74c Add index.php * 7778db8 Add projects and requirements link * facc111 Add symfony website link * a384a2b Add README.md // 变基 $ git rebase -i 23a0a9e 弹出的编辑界面内容为： pick 23a0a9e s 0bc04c2 Add index.css # 修改 pick 为 squash 或 s s 9ad35ee Add index.js # 修改 pick 为 squash 或 s s d48ea11 Add setup link # 修改 pick 为 squash 或 s s 04a75c1 Add semver link # 修改 pick 为 squash 或 s pick f9fa04a Integrating submission logs # Rebase 23a0a9e..f9fa04a onto 23a0a9e (5 commands) # # Commands: # p, pick = use commit # r, reword = use commit, but edit the commit message # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # f, fixup = like \"squash\", but discard this commit's log message # x, exec = run command (the rest of the line) using shell # d, drop = remove commit # # These lines can be re-ordered; they are executed from top to bottom. # # If you remove a line here THAT COMMIT WILL BE LOST. # # However, if you remove everything, the rebase will be aborted. # # Note that empty commits are commented out 正常情况下会提示成功，否则会出现如下情况： The previous cherry-pick is now empty, possibly due to conflict resolution. If you wish to commit it anyway, use: git commit --allow-empty Otherwise, please use 'git reset' interactive rebase in progress; onto 23a0a9e Last command done (1 command done): pick 23a0a9e Add links and static file Next commands to do (5 remaining commands): squash 0bc04c2 Add index.css squash 9ad35ee Add index.js You are currently rebasing branch 'master' on '23a0a9e'. nothing to commit, working tree clean Could not apply 23a0a9e... Add links and static file // 查看状态 $ git status interactive rebase in progress; onto 23a0a9e Last command done (1 command done): pick 23a0a9e Next commands to do (8 remaining commands): squash 04a75c1 Add semver link squash d48ea11 Add setup link squash 9ad35ee Add index.js squash 0bc04c2 Add index.css (use \"git rebase --edit-todo\" to view and edit) You are currently editing a commit while rebasing branch 'master' on '23a0a9e'. (use \"git commit --amend\" to amend the current commit) (use \"git rebase --continue\" once you are satisfied with your changes) nothing to commit, working tree clean // 继续变基 $ git rebase --continue 继续后弹出的编辑界面内容： # This is a combination of 5 commits. Add links and static file # 添加一行日志信息 # This is the 1st commit message: Rename index.php to index.html # This is the commit message #2: Add index.css # This is the commit message #3: Add index.js # This is the commit message #4: Add setup link # This is the commit message #5: Add semver link # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # Date: Mon Dec 31 20:05:25 2018 +0800 # # interactive rebase in progress; onto 23a0a9e # Last commands done (5 commands done): # squash d48ea11 Add setup link # squash 04a75c1 Add semver link # Next command to do (1 remaining command): # pick f9fa04a Integrating submission logs # You are currently rebasing branch 'master' on '23a0a9e'. # # Changes to be committed: # modified: README.md # renamed: index.php -\u003e index.css # new file: index.html # new file: index.js # [detached HEAD 688088f] Add links and static file Date: Mon Dec 31 20:05:25 2018 +0800 4 files changed, 2 insertions(+) rename index.php =\u003e index.css (100%) create mode 100644 index.html create mode 100644 index.js Successfully rebased and updated refs/heads/master. // 查看日志信息 $ git log --oneline --graph * fe3b3cf (HEAD -\u003e master) Integrating submission logs * 688088f Add links and static file * da3c74c Add index.php * 7778db8 ","date":"2018-01-25","objectID":"/posts/git-branch/:7:0","tags":["Git"],"title":"Git 分支","uri":"/posts/git-branch/"},{"categories":["Git"],"content":"在提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，可以使用 git log 命令查看。 Git 起步 Git 基本操作 Git 查看日志 Git 分支 Git 中一个客户端设置多个账号 Git Workflow Git 命令大全 ","date":"2018-01-24","objectID":"/posts/git-log/:0:0","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"常用选项 选项 说明 -p 按补丁格式显示每个更新之间的差异 --word-diff 按 word diff 格式显示差异 --stat 显示每次更新的文件修改统计信息 --shortstat 只显示 --stat 中最后的行数修改添加移除统计 --name-only 仅在提交信息后显示已修改的文件清单 --name-status 显示新增、修改、删除的文件清单 --abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符 --relative-date 使用较短的相对时间显示（比如：2 weeks ago） --graph 显示 ASCII 图形表示的分支合并历史 --pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline, short, full, fuller 和 format（后跟指定格式） --oneline --pretty=oneline --abbrev-commit 的简化用法 ","date":"2018-01-24","objectID":"/posts/git-log/:1:0","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"项目准备 // 此处以 vue 做演示 $ cd ~/Desktop/ $ git clone https://github.com/vuejs/vue.git Cloning into 'vue'... remote: Enumerating objects: 89, done. remote: Counting objects: 100% (89/89), done. remote: Compressing objects: 100% (64/64), done. remote: Total 53631 (delta 38), reused 51 (delta 25), pack-reused 53542 Receiving objects: 100% (53631/53631), 25.20 MiB | 1.76 MiB/s, done. Resolving deltas: 100% (37410/37410), done. $ cd vue ","date":"2018-01-24","objectID":"/posts/git-log/:2:0","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"普通格式查看 ","date":"2018-01-24","objectID":"/posts/git-log/:3:0","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"查看当前分支的所有简略日志 commit 38e967b8067441ff37cb3b923200023a6b842759 (HEAD -\u003e dev, origin/dev, origin/HEAD) Author: Xin Du (Clark) \u003cclark.duxin@gmail.com\u003e Date: Wed Dec 12 16:41:45 2018 +0000 refactor: tiny cleanup changes (#9193) commit af9e2b3f0f4156fd52ed4444b96e2b8c0932c658 Author: Nick Hall \u003ciamssb@gmail.com\u003e Date: Thu Dec 13 01:41:36 2018 +0900 chore: minor comment cleanup (#9191) ... ","date":"2018-01-24","objectID":"/posts/git-log/:3:1","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"查看所有分支的所有简略日志 $ git log --all commit ce35159d6d6e9c3607bd3232e386b5b994d0ec49 (origin/2.6) Author: Evan You \u003cyyx990803@gmail.com\u003e Date: Wed Dec 26 17:22:32 2018 -0500 chore: fix types commit c7c13c2a156269d29fd9c9f8f6a3e53a2f2cac3d Author: Evan You \u003cyyx990803@gmail.com\u003e Date: Wed Dec 26 17:17:30 2018 -0500 fix(scoped-slots): ensure $scopedSlots calls always return Arrays Also allow render functions to return an Array of a single element. Close #8056 commit d747469e1ae26190d364e5cc9c8112d3d865a0b9 Author: Evan You \u003cyyx990803@gmail.com\u003e Date: Wed Dec 26 16:02:50 2018 -0500 test: test case for v-for native collection support ... ","date":"2018-01-24","objectID":"/posts/git-log/:3:2","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"查看某个文件变动的具体日志信息 $ git log -- src/core/index.js commit 9b22d86ab315a3c6061a6a4776eab1964304f92e Author: Evan You \u003cyyx990803@gmail.com\u003e Date: Thu Mar 8 09:51:03 2018 -0500 fix: install ssr helpers for functional context during SSR close #7443, ref nuxt/nuxt.js#2565 commit 55816543c46e75aa53481ac95a89ff6f87a2d704 Author: JK \u003cjingkai.zhao@foxmail.com\u003e Date: Thu Jun 29 12:37:03 2017 +0800 fix(ssr): reference error when create $ssrContext for root component (#5981) fix #5941 ... ","date":"2018-01-24","objectID":"/posts/git-log/:3:3","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"查看某个文件变动的具体日志信息和文件内容 $ git log --follow -p -- src/core/index.js commit 9b22d86ab315a3c6061a6a4776eab1964304f92e Author: Evan You \u003cyyx990803@gmail.com\u003e Date: Thu Mar 8 09:51:03 2018 -0500 fix: install ssr helpers for functional context during SSR close #7443, ref nuxt/nuxt.js#2565 diff --git a/src/core/index.js b/src/core/index.js index b2a0cb8c..daf6203b 100644 --- a/src/core/index.js +++ b/src/core/index.js @@ -1,6 +1,7 @@ import Vue from './instance/index' import { initGlobalAPI } from './global-api/index' import { isServerRendering } from 'core/util/env' +import { FunctionalRenderContext } from 'core/vdom/create-functional-component' ... ","date":"2018-01-24","objectID":"/posts/git-log/:3:4","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"查看最近两次更新的内容差异 $ git log -p -2 commit 38e967b8067441ff37cb3b923200023a6b842759 (HEAD -\u003e dev, origin/dev, origin/HEAD) Author: Xin Du (Clark) \u003cclark.duxin@gmail.com\u003e Date: Wed Dec 12 16:41:45 2018 +0000 refactor: tiny cleanup changes (#9193) diff --git a/src/core/instance/events.js b/src/core/instance/events.js index 8225bdec..bb07a96b 100644 --- a/src/core/instance/events.js +++ b/src/core/instance/events.js @@ -102,16 +102,14 @@ export function eventsMixin (Vue: Class\u003cComponent\u003e) { vm._events[event] = null return vm } - if (fn) { - // specific handler - let cb - let i = cbs.length - while (i--) { - cb = cbs[i] - if (cb === fn || cb.fn === fn) { - cbs.splice(i, 1) - break - } + // specific handler + let cb + let i = cbs.length + while (i--) { + cb = cbs[i] + if (cb === fn || cb.fn === fn) { + cbs.splice(i, 1) + break } } return vm ... ","date":"2018-01-24","objectID":"/posts/git-log/:3:5","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"查看最近的三条的简略日志 $ git log --oneline -n3 38e967b8 (HEAD -\u003e dev, origin/dev, origin/HEAD) refactor: tiny cleanup changes (#9193) af9e2b3f chore: minor comment cleanup (#9191) b06c784b fix(ssr): support rendering comment (#9128) ","date":"2018-01-24","objectID":"/posts/git-log/:3:6","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"显示简要的增改行数统计 $ git log --stat commit 38e967b8067441ff37cb3b923200023a6b842759 (HEAD -\u003e dev, origin/dev, origin/HEAD) Author: Xin Du (Clark) \u003cclark.duxin@gmail.com\u003e Date: Wed Dec 12 16:41:45 2018 +0000 refactor: tiny cleanup changes (#9193) src/core/instance/events.js | 18 ++++++++---------- src/core/util/debug.js | 2 +- src/server/template-renderer/index.js | 2 +- 3 files changed, 10 insertions(+), 12 deletions(-) commit af9e2b3f0f4156fd52ed4444b96e2b8c0932c658 Author: Nick Hall \u003ciamssb@gmail.com\u003e Date: Thu Dec 13 01:41:36 2018 +0900 chore: minor comment cleanup (#9191) src/core/observer/dep.js | 6 +++--- 1 file changed, 3 insertions(+), 3 deletions(-) commit b06c784b81a244e1bc2d028216fcd2ab873730b9 Author: Xin Du (Clark) \u003cclark.duxin@gmail.com\u003e Date: Wed Dec 12 16:41:08 2018 +0000 fix(ssr): support rendering comment (#9128) src/server/optimizing-compiler/codegen.js | 6 +++++- test/unit/modules/server-compiler/compiler-options.spec.js | 13 +++++++++++++ 2 files changed, 18 insertions(+), 1 deletion(-) ","date":"2018-01-24","objectID":"/posts/git-log/:3:7","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"显示最后一次提交信息 $ git log -1 HEAD commit 38e967b8067441ff37cb3b923200023a6b842759 (HEAD -\u003e dev, origin/dev, origin/HEAD) Author: Xin Du (Clark) \u003cclark.duxin@gmail.com\u003e Date: Wed Dec 12 16:41:45 2018 +0000 refactor: tiny cleanup changes (#9193) ","date":"2018-01-24","objectID":"/posts/git-log/:3:8","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"查看文件改变信息 $ git log --name-status commit 38e967b8067441ff37cb3b923200023a6b842759 (HEAD -\u003e dev, origin/dev, origin/HEAD) Author: Xin Du (Clark) \u003cclark.duxin@gmail.com\u003e Date: Wed Dec 12 16:41:45 2018 +0000 refactor: tiny cleanup changes (#9193) M src/core/instance/events.js M src/core/util/debug.js M src/server/template-renderer/index.js commit af9e2b3f0f4156fd52ed4444b96e2b8c0932c658 Author: Nick Hall \u003ciamssb@gmail.com\u003e Date: Thu Dec 13 01:41:36 2018 +0900 chore: minor comment cleanup (#9191) M src/core/observer/dep.js commit b06c784b81a244e1bc2d028216fcd2ab873730b9 Author: Xin Du (Clark) \u003cclark.duxin@gmail.com\u003e Date: Wed Dec 12 16:41:08 2018 +0000 fix(ssr): support rendering comment (#9128) M src/server/optimizing-compiler/codegen.js A test/unit/modules/server-compiler/compiler-options.spec.js ","date":"2018-01-24","objectID":"/posts/git-log/:3:9","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"指定格式查看 git log --pretty=format 常用的选项： 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 -date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者（committer）的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 git log 输出的选项： 选项 说明 -(n) 仅显示最近的 n 条提交 --since, --after 仅显示指定时间之后的提交 --until, --before 仅显示指定时间之前的提交 --author 仅显示指定作者相关的提交 --committer 仅显示指定提交者相关的提交 --grep 仅显示含指定关键字的提交 -S 仅显示添加或移除了某个关键字的提交 ","date":"2018-01-24","objectID":"/posts/git-log/:4:0","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"用 oneline 将每个提交放在一行显示 这在提交数很大时非常有用。另外还有 short，full 和 fuller 可选。 $ git log --pretty=oneline 38e967b8067441ff37cb3b923200023a6b842759 (HEAD -\u003e dev, origin/dev, origin/HEAD) refactor: tiny cleanup changes (#9193) af9e2b3f0f4156fd52ed4444b96e2b8c0932c658 chore: minor comment cleanup (#9191) b06c784b81a244e1bc2d028216fcd2ab873730b9 fix(ssr): support rendering comment (#9128) 70754084ec2d84e44effeb8f82efda3397a08b0d (tag: v2.5.21) build: release 2.5.21 ... ","date":"2018-01-24","objectID":"/posts/git-log/:4:1","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"自定义格式查看日志 $ git log --pretty=format:\"%h - %an, %ar : %s\" 38e967b8 - Xin Du (Clark), 3 weeks ago : refactor: tiny cleanup changes (#9193) af9e2b3f - Nick Hall, 3 weeks ago : chore: minor comment cleanup (#9191) b06c784b - Xi n Du (Clark), 3 weeks ago : fix(ssr): support rendering comment (#9128) 70754084 - Evan You, 3 weeks ago : build: release 2.5.21 $ git log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u003c%an\u003e%Creset' --abbrev-commit * 38e967b8 - (HEAD -\u003e dev, origin/dev, origin/HEAD) refactor: tiny cleanup changes (#9193) (3 weeks ago) \u003cXin Du (Clark)\u003e * af9e2b3f - chore: minor comment cleanup (#9191) (3 weeks ago) \u003cNick Hall\u003e * b06c784b - fix(ssr): support rendering comment (#9128) (3 weeks ago) \u003cXin Du (Clark)\u003e * 70754084 - (tag: v2.5.21) build: release 2.5.21 (3 weeks ago) \u003cEvan You\u003e * b449e17e - build: build 2.5.21 (3 weeks ago) \u003cEvan You\u003e ","date":"2018-01-24","objectID":"/posts/git-log/:4:2","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"图文格式查看 $ git log --pretty=oneline --graph --abbrev-commit * 5f737e836e (HEAD -\u003e master, origin/master, origin/HEAD) feature #29613 [VarDumper] Use hyperlinks in CliDescriptor (ogizanagi) |\\ | * e54e21933a [VarDumper] Use hyperlinks in CliDescriptor * | 55113775c0 Merge branch '4.2' |\\ \\ | * | 9ade0a7605 [Cache] fix test * | | 96285882cf Merge branch '4.2' |\\ \\ \\ | |/ / | * | 43dfbe2df9 bug #29648 [Cache] fix Simple\\Psr6Cache proxying of metadata (nicolas-grekas) | |\\ \\ | | * | 02edc9b049 [Cache] fix Simple\\Psr6Cache proxying of metadata | |/ / $ git log --pretty=format:\"%h %s\" --graph * 5f737e836e feature #29613 [VarDumper] Use hyperlinks in CliDescriptor (ogizanagi) |\\ | * e54e21933a [VarDumper] Use hyperlinks in CliDescriptor * | 55113775c0 Merge branch '4.2' |\\ \\ | * | 9ade0a7605 [Cache] fix test * | | 96285882cf Merge branch '4.2' ","date":"2018-01-24","objectID":"/posts/git-log/:4:3","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"通过 ASCII 树形结构来展示所有的分支 $ git log --graph --oneline --decorate --all * 17d7a5f6 chore: update sponsors | * c8139015 (origin/feat-scoped-slot-passdown) test: add slot test case (#8344) | * bb06c75e feat(core): support passing down scopedSlots with v-bind | | * 636c9b4e (tag: v2.5.17, origin/hotfix) build: release 2.5.17 | | * 7e75b79b build: build 2.5.17 | | * b3c5e642 chore: minor tweaks | | * c28f7929 fix: fix potential xss vulnerability in ssr | |/ |/| * | 25342194 (tag: v2.5.16) build: release 2.5.16 * | 90891709 build: build 2.5.16 * | 62a922e8 fix: fix wrongly matched named slots in functional components | | * 0f4e6a9a (origin/fix-component-insert-order) fix: invoke component node create hooks before insertion | |/ |/| | | * 531cea58 (origin/perf-computed) perf: avoid unnecessary re-renders when computed property value did not change | |/ |/| | | * ca2e6a74 (origin/fix-beforeupdate) fix: beforeUpdate should be called before render and allow state mutation | |/ |/| ","date":"2018-01-24","objectID":"/posts/git-log/:4:4","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"限制格式输出 选项 说明 -(n) 仅显示最近的 n 条提交 --since, --after 仅显示指定时间之后的提交 --until, --before 仅显示指定时间之前的提交 --author 仅显示指定作者相关的提交 --committer 仅显示指定提交者相关的提交 ","date":"2018-01-24","objectID":"/posts/git-log/:5:0","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"显示三周之后的提交 $ git log --after=3.weeks commit 38e967b8067441ff37cb3b923200023a6b842759 (HEAD -\u003e dev, origin/dev, origin/HEAD) Author: Xin Du (Clark) \u003cclark.duxin@gmail.com\u003e Date: Wed Dec 12 16:41:45 2018 +0000 refactor: tiny cleanup changes (#9193) commit af9e2b3f0f4156fd52ed4444b96e2b8c0932c658 Author: Nick Hall \u003ciamssb@gmail.com\u003e Date: Thu Dec 13 01:41:36 2018 +0900 chore: minor comment cleanup (#9191) ","date":"2018-01-24","objectID":"/posts/git-log/:5:1","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"显示两周之前的提交 $ git log --before=2.weeks commit 38e967b8067441ff37cb3b923200023a6b842759 (HEAD -\u003e dev, origin/dev, origin/HEAD) Author: Xin Du (Clark) \u003cclark.duxin@gmail.com\u003e Date: Wed Dec 12 16:41:45 2018 +0000 refactor: tiny cleanup changes (#9193) commit af9e2b3f0f4156fd52ed4444b96e2b8c0932c658 Author: Nick Hall \u003ciamssb@gmail.com\u003e Date: Thu Dec 13 01:41:36 2018 +0900 chore: minor comment cleanup (#9191) ","date":"2018-01-24","objectID":"/posts/git-log/:5:2","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"显示指定人提交日志 // 查看 2018 年元月期间，Evan You 提交的但未合并的位于项目 ./src 目录下的代码 $ git log --pretty=\"%h - %s\" --author='Evan You' --after=\"2018-12-01\" \\ --before=\"2018-12-31\" --no-merges -- ./src 847e4937 - fix: fix single v-for child optimization 4074104f - perf: skip normalization on single child element v-for 47487607 - fix: fix v-for component with undefined value 0d4b35f5 - fix(vdom): remove unnecessary sameVnode condition 5d721a42 - revert: fix(sfc): avoid deindent when pad option is specified (#7647) 780dac56 - fix(ssr): should not warn for custom directives that do not have ssr implementation 8a2dbf50 - fix(transition-group): fix activeInstance regression f077ed17 - fix(ssr): fix ssr template publicPath generation 1b4a8a0c - fix(compiler): fix codegen for v-for component inside template e4b1b57f - fix(ssr): adjust call stack size defer threshold 530ca1b2 - fix(core): properly handle reused vnodes 097f6229 - fix(core): avoid mutating original children when cloning vnode $ git log --before={2,weeks,ago} --after={2018-11-30} --oneline 38e967b8 (HEAD -\u003e dev, origin/dev, origin/HEAD) refactor: tiny cleanup changes (#9193) af9e2b3f chore: minor comment cleanup (#9191) b06c784b fix(ssr): support rendering comment (#9128) 70754084 (tag: v2.5.21) build: release 2.5.21 b449e17e build: build 2.5.21 ... ","date":"2018-01-24","objectID":"/posts/git-log/:5:3","tags":["Git"],"title":"Git 查看日志","uri":"/posts/git-log/"},{"categories":["Git"],"content":"通过一顿操作来熟悉 Git 是不二法门。 Git 起步 Git 基本操作 Git 查看日志 Git 分支 Git 中一个客户端设置多个账号 Git Workflow Git 命令大全 创建仓库 请自行准备好 git 环境。 ","date":"2018-01-23","objectID":"/posts/git-basic/:0:0","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"创建服务器裸仓库 git init: 将当前的目录转换成一个 git 仓库 git init \u003cdirectory\u003e: 在指定目录创建一个空的 git 仓库 git init --bare \u003cproject-name\u003e.git: 裸库往往被创建用于作为大家一起工作的共享库，每一个人都可以往里面 push 自己的本地修改。服务器上 bare 创建的仓库，主要用来连接，同步，协调。记录每个人本地仓库的记录，而不存放项目源代码。而每个开发人员自己电脑上分别有个小仓库，存放源代码及自己的改动 // 登录远程服务器 $ ssh \u003cuser\u003e@\u003chost\u003e // 进入操作目录 $ cd /path/to/repository // 创建祼仓库 $ git init --bare \u003cproject-name\u003e.git // 退出远程服务器，进入本地终端 $ git init \u003cdirectory\u003e $ touch README.md $ git add README.md $ git commit -m \"Initial commit\" $ git remote add origin \u003cuser\u003e@\u003chost\u003e:/path/to/repository/\u003cproject-name\u003e.git $ git push -u origin master // 其它成员克隆仓库 $ git clone \u003cuser\u003e@\u003chost\u003e:/path/to/repository/\u003cproject-name\u003e.git ","date":"2018-01-23","objectID":"/posts/git-basic/:1:0","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"创建本地仓库 ","date":"2018-01-23","objectID":"/posts/git-basic/:2:0","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"初始化本地仓库 // 创建本地仓库 $ mkdir example $ cd example $ git init $ touch README.md $ git add README.md $ git commit -m \"Initial commit\" ","date":"2018-01-23","objectID":"/posts/git-basic/:2:1","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"关联远程仓库 关联多个仓库需要给不同的远程仓库起一个别名，请自行在 gitee 和 github 上创建空仓库。 $ git remote add gitee git@gitee.com:user/project.git $ git push -u gitee master 或 $ git remote add github https://github.com/user/project.git $ git push -u github master ","date":"2018-01-23","objectID":"/posts/git-basic/:2:2","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"分支跟踪远程分支 // 设置让本地某个分支跟踪远程的某个分支 $ git branch --set-upstream-to=origin/\u003cbranch\u003e \u003cbranch\u003e ","date":"2018-01-23","objectID":"/posts/git-basic/:2:3","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"克隆远程仓库 $ git clone \u003cuser\u003e@\u003chost\u003e:/path/to/repository/\u003cproject\u003e.git 或 $ git clone https://gitee.com/user/\u003cproject\u003e.git 基本操作 ","date":"2018-01-23","objectID":"/posts/git-basic/:2:4","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"初始化仓库 $ cd ~/Desktop \u0026\u0026 mkdir example \u0026\u0026 cd example $ git init Initialized empty Git repository in /Users/majinyun/Desktop/example/.git/ ","date":"2018-01-23","objectID":"/posts/git-basic/:3:0","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"忽略文件 GitHub 官方提供的 忽略文件模版 .gitignore 文件格式： 所有空行或者以注释符号 # 开头的行都会被 git 忽略 可以使用标准的 glob 模式匹配 匹配模式最后跟反斜杠 / 说明要忽略的是目录 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号 ! 取反 ","date":"2018-01-23","objectID":"/posts/git-basic/:4:0","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"添加文件 空目录是不能提交到仓库中的，至少要保证目录中有一个文件。 // 创建一个 README.md 文件 $ touch README.md // 查看仓库状态 $ git status On branch master No commits yet Untracked files: (use \"git add \u003cfile\u003e...\" to include in what will be committed) README.md nothing added to commit but untracked files present (use \"git add\" to track) // 如果这个阶段你发现文件创建错误了（本不应该放置在此目录中或不需要此文件或者其它任何原因），直接删除掉即可，否则继续以下操作 $ rm -f README.md // 添加 README.md 文件到暂存区 $ git add README.md // 查看仓库状态 $ git status On branch master No commits yet Changes to be committed: (use \"git rm --cached \u003cfile\u003e...\" to unstage) new file: README.md // 如果这个阶段你发现此文件不应该被添加到暂存区，请不要粗暴的 rm 掉，而是使用 git rm 命令干掉它 $ git rm --cached README.md ","date":"2018-01-23","objectID":"/posts/git-basic/:5:0","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"仓库状态 $ git status On branch master nothing to commit, working tree clean ","date":"2018-01-23","objectID":"/posts/git-basic/:6:0","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"提交文件 // 将暂存区的文件提交到仓库，正常情况下会如下面的操作一样，显示文件已经被加入到版本库中，但也有不正常的情况 $ git commit -m \"Add README.md\" [master (root-commit) a384a2b] Add README.md 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 README.md // 这个就是提交时的不正常情况，什么意思呢？第一种说法的意思是需要你配置一下仓库的用户名称和邮箱地址，这个小意思，我们直接来个全局配置和局部配置就搞定了。第二种说法的意思是你在完成上面的操作之后，可以修复用于此提交的标识，说白了就是你提交到仓库后还可以进行编辑提交记录的注释信息（就是就对万一将本次提交记录的注释信息写错的情况），它会弹出你所配置的编辑器让你修改提交记录的注释信息，很遗憾这个只修改最后一个提交记录的注释信息，那么问题来了，怎么修改前 N 次的的某个提交记录的注释信息呢，这里暂时先不探究，这个涉及到 rebase 操作，足以让我再折腾一篇来专门说这种情况 $ git commit -m \"Add README.md\" [master (root-commit) a384a2b] Add README.md Committer: user \u003cuser@user.com\u003e Your name and email address were configured automatically based on your username and hostname. Please check that they are accurate. You can suppress this message by setting them explicitly: git config --global user.name \"Your Name\" git config --global user.email you@example.com After doing this, you may fix the identity used for this commit with: git commit --amend --reset-author 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 README.md // 配置用户和邮箱交提交到仓库，将用户和邮箱换成你自己的，这个时间代码已经被提交到仓库 $ git config user.name \"yourname\" $ git config user.email \"yourname@email.com\" // 查看仓库状态 $ git status On branch master nothing to commit, working tree clean ","date":"2018-01-23","objectID":"/posts/git-basic/:7:0","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"修改最后一次提交日志信息 $ vim README.md [1]: https://symfony.com $ git add README.md $ git commit -m \"Add symfony link\" [master 98a19c3] Add symfony link 1 file changed, 1 insertion(+) $ git commit --amend Add symfony website link # 编辑此信息 # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # Date: Sun Dec 30 19:22:08 2018 +0800 # # On branch master # Changes to be committed: # modified: README.md # [master abe0281] Add symfony website link Date: Sun Dec 30 19:22:08 2018 +0800 1 file changed, 1 insertion(+) ","date":"2018-01-23","objectID":"/posts/git-basic/:8:0","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"修改最后一次提交记录时的用户信息 $ git commit --amend --author=\"peter \u003cpeter@dot.org\u003e\" [master facc111] Add symfony website link Author: peter \u003cpeter@dot.org\u003e Date: Sun Dec 30 19:22:08 2018 +0800 1 file changed, 1 insertion(+) ","date":"2018-01-23","objectID":"/posts/git-basic/:9:0","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"撤销对文件内容的更改 $ vim README.md [1]: https://symfony.com [2]: https://symfony.com/projects $ git status On branch master Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: README.md no changes added to commit (use \"git add\" and/or \"git commit -a\") $ git checkout -- README.md ","date":"2018-01-23","objectID":"/posts/git-basic/:10:0","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"提交文件变更到仓库 $ vim README.md [1]: https://symfony.com [2]: https://symfony.com/projects $ git status On branch master Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: README.md no changes added to commit (use \"git add\" and/or \"git commit -a\") $ git add README.md $ git commit -m \"Add projects link\" [master 7d8fcb9] Add projects link 1 file changed, 1 insertion(+) ","date":"2018-01-23","objectID":"/posts/git-basic/:11:0","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"回滚仓库到某个提交 $ git log --oneline 7d8fcb9 (HEAD -\u003e master) Add projects link facc111 Add symfony website link a384a2b Add README.md $ git reset --hard facc111 HEAD is now at facc111 Add symfony website link $ git log --oneline facc111 (HEAD -\u003e master) Add symfony website link a384a2b Add README.md ","date":"2018-01-23","objectID":"/posts/git-basic/:12:0","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"撤销工作区和暂存区 --soft：当前分支重置到指定 commit 记录位置，索引和工作树不变 --mixed：当前分支重置到指定 commit 记录位置，索引被更新，工作树不变 --hard：当前分支重置到指定 commit 记录位置，索引和工作树都更新 $ touch index.{html,js,css} $ git status On branch master Untracked files: (use \"git add \u003cfile\u003e...\" to include in what will be committed) index.css index.html index.js nothing added to commit but untracked files present (use \"git add\" to track) $ $ git add . $ git status On branch master Changes to be committed: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) new file: index.css new file: index.html new file: index.js // 只撤销暂存区 $ git reset HEAD // 全部撤销 $ git reset --hard HEAD HEAD is now at facc111 Add symfony website lin ","date":"2018-01-23","objectID":"/posts/git-basic/:13:0","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"查看已暂存和未暂存的更新 $ vim README.md [1]: https://symfony.com [2]: https://symfony.com/projects $ git add README.md $ vim README.md [1]: https://symfony.com [2]: https://symfony.com/projects [3]: https://symfony.com/doc/current/reference/requirements.html // 比较工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容 $ git diff diff --git a/README.md b/README.md index 56737ed..4a93303 100644 --- a/README.md +++ b/README.md @@ -1,2 +1,3 @@ [1]: https://symfony.com [2]: https://symfony.com/projects +[3]: https://symfony.com/doc/current/reference/requirements.html // 查看已经暂存起来的文件和上次提交时的快照之间的差异 $ git diff --cached diff --git a/README.md b/README.md index 55c6709..56737ed 100644 --- a/README.md +++ b/README.md @@ -1 +1,2 @@ [1]: https://symfony.com +[2]: https://symfony.com/projects 或者 // 查看已经暂存起来的文件和上次提交时的快照之间的差异 $ git diff --staged diff --git a/README.md b/README.md index 55c6709..56737ed 100644 --- a/README.md +++ b/README.md @@ -1 +1,2 @@ [1]: https://symfony.com +[2]: https://symfony.com/projects // 跳过使用暂存区域，git 会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤 $ git status On branch master Changes to be committed: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) modified: README.md Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: README.md $ git commit -am \"Add projects and requirements link\" [master 7778db8] Add projects and requirements link 1 file changed, 2 insertions(+) $ git status On branch master nothing to commit, working tree clean ","date":"2018-01-23","objectID":"/posts/git-basic/:14:0","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"移除文件 // 误删了文件，期望不产生提交记录就把文件干掉（此文件从来没提交到仓库中），通过以下的操作就可以看到此文件恢复到之前创建时的状态，此时你可以考虑删除或者做其它更改 $ touch index.html \u0026\u0026 git add index.html \u0026\u0026 rm index.html remove index.html? y $ git status On branch master Changes to be committed: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) new file: index.html Changes not staged for commit: (use \"git add/rm \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) deleted: index.html $ git checkout -- index.html $ git status On branch master Changes to be committed: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) new file: index.html $ git reset HEAD index.html $ git status On branch master Untracked files: (use \"git add \u003cfile\u003e...\" to include in what will be committed) index.html nothing added to commit but untracked files present (use \"git add\" to track) // 把文件从暂存区域移除，但仍然希望保留在当前工作区 $ git add index.html $ git status On branch master Changes to be committed: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) new file: index.html $ git rm --cached index.html $ git status On branch master Untracked files: (use \"git add \u003cfile\u003e...\" to include in what will be committed) index.html nothing added to commit but untracked files present (use \"git add\" to track) // 将未加入暂存区的文件全部清理掉，即将工作区的变更全部清理掉，需要谨慎操作 $ git clean -df Removing index.html ","date":"2018-01-23","objectID":"/posts/git-basic/:15:0","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"移动或者重命名文件 $ touch index.php $ git add index.php $ git commit -m \"Add index.php\" [master da3c74c] Add index.php 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 index.php $ git mv index.php index.html $ git status On branch master Changes to be committed: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) renamed: index.php -\u003e index.html ","date":"2018-01-23","objectID":"/posts/git-basic/:16:0","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"差异比较 // 比较两个分支的所有差异 $ git diff master develop diff --git a/.editorconfig b/.editorconfig deleted file mode 100644 index e69de29..0000000 diff --git a/README.md b/README.md index f6f24a8..c0cd272 100644 --- a/README.md +++ b/README.md @@ -3,4 +3,3 @@ [3]: https://symfony.com/doc/current/reference/requirements.html [4]: https://symfony.com/doc/current/setup.html [5]: http://semver.org -[6]: https://symfony.com/doc/current/contributing/community/releases.html // 比较两个提交记录的所有差异 $ git diff fe3b3cf 688088f diff --git a/.editorconfig b/.editorconfig deleted file mode 100644 index e69de29..0000000 diff --git a/README.md b/README.md index f6f24a8..c0cd272 100644 --- a/README.md +++ b/README.md @@ -3,4 +3,3 @@ [3]: https://symfony.com/doc/current/reference/requirements.html [4]: https://symfony.com/doc/current/setup.html [5]: http://semver.org -[6]: https://symfony.com/doc/current/contributing/community/releases.html // 比较两个提交中的某个文件的差异 $ git diff fe3b3cf 688088f -- README.md diff --git a/README.md b/README.md index f6f24a8..c0cd272 100644 --- a/README.md +++ b/README.md @@ -3,4 +3,3 @@ [3]: https://symfony.com/doc/current/reference/requirements.html [4]: https://symfony.com/doc/current/setup.html [5]: http://semver.org -[6]: https://symfony.com/doc/current/contributing/community/releases.html ","date":"2018-01-23","objectID":"/posts/git-basic/:17:0","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"储藏 当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。git stash 就是解决这种问题的。 ","date":"2018-01-23","objectID":"/posts/git-basic/:18:0","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"储藏任务 // 假设目前工作进行了一段时间后，仓库的目前的状态 $ git status On branch master Changes to be committed: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) modified: index.css modified: index.html modified: index.js Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: index.html // 此时由于紧急的任务或者 bug 需要解决，暂时将之前做的任务暂存起来 $ git stash Saved working directory and index state WIP on master: fe3b3cf Integrating submission logs // 获取一个干净的工作目录 $ git status On branch master nothing to commit, working tree clean ","date":"2018-01-23","objectID":"/posts/git-basic/:18:1","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"查看储藏任务列表 $ git stash list stash@{0}: WIP on master: fe3b3cf Integrating submission logs stash@{1}: WIP on master: fe3b3cf Integrating submission logs ","date":"2018-01-23","objectID":"/posts/git-basic/:18:2","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"应用最近的储藏 // apply 选项并不会删除储藏 $ git stash apply 或 $ git stash apply stash@{0} On branch master Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: README.md no changes added to commit (use \"git add\" and/or \"git commit -a\") // 此时应用储藏时与之前储藏时的文件状态不一致 $ git stash apply stash@{1} On branch master Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: index.css modified: index.html # 看这个文件之前储藏时的状态 modified: index.js // 带上一个 --index 的选项来告诉命令重新应用被暂存的变更 $ git stash apply stash@{0} --index On branch master Changes to be committed: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) modified: index.css modified: index.html modified: index.js Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: index.html # 文件暂存状态恢复了 // 应用储藏后立即删除储藏 $ git stash pop --index On branch master Changes to be committed: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) modified: index.css modified: index.html modified: index.js Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: index.html Dropped refs/stash@{0} (5c5c3fe5374020b5d4a1b0d5303b0cb932227134) ","date":"2018-01-23","objectID":"/posts/git-basic/:18:3","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"删除储藏 $ git stash drop stash@{0} Dropped stash@{0} (e2ffa6a2b49d31703266cf6668f2b51f94e9d62f) ","date":"2018-01-23","objectID":"/posts/git-basic/:18:4","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"取消储藏 // 在某些情况下，你可能想应用储藏的修改，在进行了一些其他的修改后，又要取消之前所应用储藏的修改 $ git status On branch master Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: index.html no changes added to commit (use \"git add\" and/or \"git commit -a\") $ git stash Saved working directory and index state WIP on master: fe3b3cf Integrating submission logs $ git stash list stash@{0}: WIP on master: fe3b3cf Integrating submission logs $ git stash apply stash@{0} --index On branch master Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: index.html no changes added to commit (use \"git add\" and/or \"git commit -a\") // 取消应用的储藏，没有指定默认为最近一次储藏 $ git stash show -p stash@{0} | git apply -R 或 $ git stash show -p | git apply -R ","date":"2018-01-23","objectID":"/posts/git-basic/:18:5","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"从储藏中创建分支 $ git stash branch testchanges Switched to a new branch 'testchanges' On branch testchanges Changes to be committed: (use \"git reset HEAD \u003cfile\u003e...\" to unstage) modified: index.css modified: index.html modified: index.js Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) modified: index.html Dropped refs/stash@{0} (9d514109f5cf6c23c75297af595189d5af839693) ","date":"2018-01-23","objectID":"/posts/git-basic/:18:6","tags":["Git"],"title":"Git 基本操作","uri":"/posts/git-basic/"},{"categories":["Git"],"content":"Git 是一种在全球范围都广受欢迎的版本控制系统。在开发过程中，为了跟踪代码，文档，项目等信息中的变化，版本控制变得前所未有的重要。但跟踪变化远远不能满足现代软件开发行业的协同需求，基于 Git 的 Workflow 满足了合作编程的需求，让开发从此变得更加高效和有趣。相比集中式版本控制系统如 SVN ，分布式版本控制系统 Git 拥有更强大的分支管理与合并能力，支持离线开发，并良好地保留了提交过程，让您和您的团队在开发过程中如虎添翼。 Git 起步 Git 基本操作 Git 查看日志 Git 分支 Git 中一个客户端设置多个账号 Git Workflow Git 命令大全 ","date":"2018-01-22","objectID":"/posts/git-get-started/:0:0","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"概述 ","date":"2018-01-22","objectID":"/posts/git-get-started/:1:0","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"设计初衷 为速度而生 简单的设计 对非线性开发模式的强力支持（允许上千个并行开发的分支） 完全分布式 有能力高效管理类似 Linux 内核一样的超大规模的项目（速度和数量） ","date":"2018-01-22","objectID":"/posts/git-get-started/:1:1","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"一些特性 优越的存储能力 直接记录快照，而非差异比较 离线操作，几乎所有操作都是本地执行 时刻保持数据完整性 多数操作仅添加数据 开源 git 中文件的三种状态：工作目录，暂存区域和本地仓库： ","date":"2018-01-22","objectID":"/posts/git-get-started/:1:2","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"工作流程 在工作目录中修改某些文件 对修改后的文件进行快照，然后保存到暂存区域 提交更新，将保存在暂存区域的文件快照永久转储到 git 目录中 ","date":"2018-01-22","objectID":"/posts/git-get-started/:1:3","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"关于版本控制 ","date":"2018-01-22","objectID":"/posts/git-get-started/:2:0","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"集中化的版本控制系统 CVCS - Centralized Version Control Systems ","date":"2018-01-22","objectID":"/posts/git-get-started/:2:1","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"分布式版本控制系统 DVCS - Distributed Version Control System ","date":"2018-01-22","objectID":"/posts/git-get-started/:2:2","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"安装 ","date":"2018-01-22","objectID":"/posts/git-get-started/:3:0","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"Linux 安装 安装依赖 // CentOS $ sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel // Ubuntu $ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev 手动编译安装 去这里下载 git // 解压后进行编译安装 $ tar -zxf v2.16.1.tar.gz $ cd v2.16.1 $ make prefix=/usr/local all $ sudo make prefix=/usr/local install 包管理器安装 // CentOS $ yum install git-core // Ubuntu $ apt-get install git ","date":"2018-01-22","objectID":"/posts/git-get-started/:3:1","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"Mac 安装 // 使用 brew 安装 git $ brew install git ","date":"2018-01-22","objectID":"/posts/git-get-started/:3:2","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"Windows 安装 We bring the awesome Git SCM to Windows ","date":"2018-01-22","objectID":"/posts/git-get-started/:3:3","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"配置 ","date":"2018-01-22","objectID":"/posts/git-get-started/:4:0","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"三种配置 全局配置：当前用户的所有仓库有效，存储配置的文件为 ~/.gitconfig // 查看全局配置 $ git config --global -l 或 $ git config --list --global 局部配置：当前用户的某个仓库有效，存储配置的文件为 .git/config // 查看局部配置 $ git config --local -l 或 $ git config --list --local 系统配置：系统所有用户有效，存储配置的文件为 /etc/gitconfig // 查看系统配置 $ git config --system -l 或 $ git config --list --system ","date":"2018-01-22","objectID":"/posts/git-get-started/:4:1","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"用户信息 // 配置全局的用户名称 $ git config --global user.name \"Your Name\" // 配置全局的邮箱地址 $ git config --global user.email \"Your Email\" // 取消全局配置的用户名称 $ git config --global --unset user.name // 取消全局配置的邮箱地址 $ git config --global --unset user.email // 配置某个仓库的用户名称 $ git config --local user.name \"Your Name\" // 配置某个仓库的邮箱地址 $ git config --local user.email \"Your Email\" ","date":"2018-01-22","objectID":"/posts/git-get-started/:4:2","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"文本编辑器 Git Commit Problem: \"error: There was a problem with the editor 'vi'\" // 配置 vim 为 git 默认的编辑器，为满足在 git 中输入一些额外消息的时候，自动调用一个外部文本编辑器的需要 $ git config --global core.editor $(which vim) ","date":"2018-01-22","objectID":"/posts/git-get-started/:4:3","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"差异分析工具 // 配置解决合并冲突时使用哪种差异分析工具 $ git config --global merge.tool vimdiff ","date":"2018-01-22","objectID":"/posts/git-get-started/:4:4","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"换行符配置 操作系统对回车 CR 和换行 LF 定义是有差异的。 AutoCRLF // 提交时转换为 LF，检出时转换为 CRLF $ git config --global core.autocrlf true // 提交时转换为 LF，检出时不转换 $ git config --global core.autocrlf input // 提交检出均不转换 $ git config --global core.autocrlf false SafeCRLF // 拒绝提交包含混合换行符的文件 $ git config --global core.safecrlf true // 允许提交包含混合换行符的文件 $ git config --global core.safecrlf false // 提交包含混合换行符的文件时给出警告 $ git config --global core.safecrlf warn ","date":"2018-01-22","objectID":"/posts/git-get-started/:4:5","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"修正空白符 git 预先设置了一些选项来探测和修正空白问题 默认打开的 2 个选项是 trailing-space 和 space-before-tab，trailing-space 会查找每行结尾的空格，space-before-tab 会查找每行开头的制表符前的空格 默认关闭的 2 个选项是 indent-with-non-tab 和 cr-at-eol，indent-with-non-tab 会查找 8 个以上空格（非制表符）开头的行，cr-at-eol 让 git 知道行尾回车符是合法的 // 全局配置修正空白符 $ git config --global core.whitespace trailing-space,space-before-tab ","date":"2018-01-22","objectID":"/posts/git-get-started/:4:6","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"配置快捷操作 // 为 git 命令创建一个快捷方式 $ git config --global alias.\u003calias-name\u003e \u003cgit-command\u003e // 检出快捷方式设置 $ git config --global alias.co checkout // 提交快捷方式设置 $ git config --global alias.ci commit // 状态快捷方式设置 $ git config --global alias.st status // 分支快捷方式设置 $ git config --global alias.br branch ","date":"2018-01-22","objectID":"/posts/git-get-started/:4:7","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"配置在 Windows 下 ASCII 字符的文件名正确显示 git 乱码解决方案汇总 // 一个显示乱码的实例 $ git status On branch master Your branch is up to date with 'gitee/master'. Changes not staged for commit: (use \"git add/rm \u003cfile\u003e...\" to update what will be committed) (use \"git checkout -- \u003cfile\u003e...\" to discard changes in working directory) (commit or discard the untracked or modified content in submodules) deleted: \"xxx-\\345\\210\\235\\350\\257\\206.xx\" // 中文文件名显示不正常 Untracked files: (use \"git add \u003cfile\u003e...\" to include in what will be committed) // 全局配置以解决 Windows Git Bash、Linux 下的中文转码问题 $ git config --global core.quotepath false ","date":"2018-01-22","objectID":"/posts/git-get-started/:4:8","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"配置对大小写敏感 // 全局配置对大小写敏感，保持 Mac/Win/Linux 一致性 $ git config --global core.ignorecase false ","date":"2018-01-22","objectID":"/posts/git-get-started/:4:9","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"配置菜色显示 // 全局配置菜色显示 $ git config --global color.ui auto ","date":"2018-01-22","objectID":"/posts/git-get-started/:4:10","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"以 https 方式进行连接时，记住密码 为当前仓库设置记住密码，设置后，只要在推送一次，以后就不需要用户名和密码了 // 设置保存密码到硬盘，如果是 macOS，选项可以改为 osxkeychain $ git config credential.helper store // 设置保存密码的超时时间 $ git config credential.helper 'cache --timeout=36000' // 查看密码文件（以明文的方式保存的） $ cat ~/.git-credentials ","date":"2018-01-22","objectID":"/posts/git-get-started/:5:0","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"查看配置信息 $ git config --list 或 $ git config -l ","date":"2018-01-22","objectID":"/posts/git-get-started/:5:1","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"解决目录卡顿问题 主要解决在 zsh 下，在 git 版本控制的目录输入命令执行缓慢的问题。 // 不读取文件变化信息（针对当前用户当前项目） $ git config --add oh-my-zsh.hide-dirty 1 // 不读取任何 git 信息（针对当前用户所有项目） $ git config --global --add oh-my-zsh.hide-status 1 ","date":"2018-01-22","objectID":"/posts/git-get-started/:5:2","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Git"],"content":"帮助命令 $ git help \u003cverb\u003e 或 $ git \u003cverb\u003e --help 或 $ man git // 查看帮助命令 $ git --help usage: git [--version] [--help] [-C \u003cpath\u003e] [-c \u003cname\u003e=\u003cvalue\u003e] [--exec-path[=\u003cpath\u003e]] [--html-path] [--man-path] [--info-path] [-p | --paginate | --no-pager] [--no-replace-objects] [--bare] [--git-dir=\u003cpath\u003e] [--work-tree=\u003cpath\u003e] [--namespace=\u003cname\u003e] \u003ccommand\u003e [\u003cargs\u003e] These are common Git commands used in various situations: start a working area (see also: git help tutorial) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing one work on the current change (see also: git help everyday) add Add file contents to the index mv Move or rename a file, a directory, or a symlink reset Reset current HEAD to the specified state rm Remove files from the working tree and from the index examine the history and state (see also: git help revisions) bisect Use binary search to find the commit that introduced a bug grep Print lines matching a pattern log Show commit logs show Show various types of objects status Show the working tree status grow, mark and tweak your common history branch List, create, or delete branches checkout Switch branches or restore working tree files commit Record changes to the repository diff Show changes between commits, commit and working tree, etc merge Join two or more development histories together rebase Reapply commits on top of another base tip tag Create, list, delete or verify a tag object signed with GPG collaborate (see also: git help workflows) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects 'git help -a' and 'git help -g' list available subcommands and some concept guides. See 'git help \u003ccommand\u003e' or 'git help \u003cconcept\u003e' to read about a specific subcommand or concept. ","date":"2018-01-22","objectID":"/posts/git-get-started/:5:3","tags":["Git"],"title":"Git 起步","uri":"/posts/git-get-started/"},{"categories":["Mac"],"content":" Homestead 英文官网 HomeStead 中文网站 HomeStead GitHub ","date":"2018-01-21","objectID":"/posts/mac-homestead/:0:0","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"介绍 Laravel 致力于使整个 PHP 开发体验变得愉快，包括你的本地开发环境。Vagrant 提供了一个简单、优雅的方式来管理和配置虚拟机。 Laravel Homestead 是一个官方预载的 Vagrant 盒子，旨在提供你一个美好的开发环境，而不需要在你的本地机器 中去安装 PHP，Web 服务器和其它任何服务软件。再也不用担心会搞乱你的操作系统！Vagrant 盒子完全是一次性的。如果出现问题，你可以在几分钟内销毁并重新创建它！ Homestead 运行在任何 Windows，Mac，或者 Linux 系统上，并包含 Nginx Web 服务器，PHP 7.2，PHP 7.1，PHP 5.6，MySQL，Redis，Memcached，Node，以及开发令人惊叹的 Laravel 应用程序所需的所有其他好东西。 {% note danger %} 如果你使用 Windows，你需要开启硬件虚拟化（VT-x）。它通常是通过你的 BIOS 去开启。如果你在一个 UEFI 系统上使用 Hyper-V，为了访问 VT-x，你可能还需要去禁用 Hyper-V。 {% endnote %} ","date":"2018-01-21","objectID":"/posts/mac-homestead/:1:0","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"内置软件 Ubuntu 18.04 Git PHP 7.2 PHP 7.1 PHP 7.0 PHP 5.6 Nginx Apache（可选） MySQL MariaDB（可选） Sqlite3 PostgreSQL Composer Node（Yarn，Bower，Grunt 和 Gulp） Redis Memcached Beanstalkd Mailhog Neo4j（可选） MongoDB（可选） Elasticsearch（可选） ngrok wp-cli Zend Z-Ray Go Minio 总之一句话，巨牛逼。如果这些东西让你自己折腾，怎么着也得大半天吧。想想我朝这个网络，你能顺利的搞定那简直就是牛逼中的战斗机。 ","date":"2018-01-21","objectID":"/posts/mac-homestead/:1:1","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"安装与配置 ","date":"2018-01-21","objectID":"/posts/mac-homestead/:2:0","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"起步 在启动 Homestead 环境之前，你必须安装 VirtualBox 5.2，VMWare，Parallels 或者 Hyper-V 以及 Vagrant。所有这些软件包都为所有流行的操作系统提供了易于使用的可视化安装程序。 为了使用 VMware 提供者，你将需要去购买 VMware Fusion / Workstation 和 VMware Vagrant plug-in。尽管它不是免费的，VMware 比其它盒子能提供更快的共享文件夹性能。 为了使用 Parallels 提供者，你将需要安装 Parallels Vagrant plug-in，它是免费的。 因为 Vagrant limitations，Hyper-V 提供者将忽略所有的网络设置。 安装 Homestead Vagrant 盒子 一旦 VirtualBox / VMware 和 Vagrant 被安装，你应当在你的终端中使用如下的命令将 laravel/homestead 添加到你的 Vagrant 安装中。下载盒子耗费的时间取决于你的网速： $ vagrant box add laravel/homestead ==\u003e vagrant: A new version of Vagrant is available: 2.1.4! ==\u003e vagrant: To upgrade visit: https://www.vagrantup.com/downloads.html 如果此命令失败，确保你安装的 Vagrant 是最新的。 安装 Homestead 你可以安装 Homestead 通过克隆仓库。考虑克隆仓库到你的『home』目录下的一个 Homestead 文件夹下，这样 Homestead 盒子服务将作为你的所有 Laravel 项目的主机： $ git clone https://github.com/laravel/homestead.git ~/Homestead Cloning into 'Homestead'... 你应当检查 Homestead 的标记版本，因为 master 分支不总是稳定的。你能在 GitHub Release Page 找到最新的稳定版： $ cd ~/Homestead // Clone the desired release... $ git checkout v7.14.2 一旦你克隆克隆了 Homestead 仓库，从 Homestead 目录运行 bash init.sh 命令去创建 Homestead.yaml 配置文件。此 Homestead.yaml 文件将位于 Homestead 目录中： // Mac / Linux... $ bash init.sh // Windows... \u003e init.bat ","date":"2018-01-21","objectID":"/posts/mac-homestead/:2:1","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"配置 Homestead 设置你的提供者 在你的 Homestead.yaml 文件中的 provider 键名表示哪个 Vagrant 提供者应当被使用：virtualbox，vmware_fusion，vmware_workstation，parallels 或者 hyperv。你可以设置你偏好的提供者： provider: virtualbox 配置共享文件夹 Homestead.yaml 文件中的 folders 属性列出了你希望与你的 Homestead 环境共享的所有文件夹。在这些文件夹下的文件发生改变时，他们将在你的本地机器和 Homestead 环境之间保持同步。你可以根据需要去配置任意数量的共享文件夹。 folders: - map: ~/code to: /home/vagrant/code 如果你仅仅创建一些站点，这个能用的映射将正常工作。然而，随着站点数量的不断增加，你可能会遇到性能问题。在包含大量文件的低端机器或者项目中，这个问题可能非常明显。如果你遇到这个问题，尝试将每个项目映射到其自己的 Vagrant 文件夹下： folders: - map: ~/code/project1 to: /home/vagrant/code/project1 - map: ~/code/project2 to: /home/vagrant/code/project2 要开启 NFS，你仅仅需要增加一个简单的标志到你的同步文件配置中： folders: - map: ~/code to: /home/vagrant/code type: \"nfs\" {% note danger %} 当使用 NFS 时，你应当考虑安装 vagrant-bindfs 插件。这个插件将为 Homestead 盒子中的文件和目录维护正确的 user / group 权限。 {% endnote %} 你也可以传递通过 options 键下列出它们的 Vagrant 的 Synced Folders 所支持的任何选项： folders: - map: ~/code to: /home/vagrant/code type: \"rsync\" options: rsync__args: [\"--verbose\", \"--archive\", \"--delete\", \"-zz\"] rsync__exclude: [\"node_modules\"] 配置 Nginx 站点 不熟悉 Nginx？没问题。sites 属性允许你轻松映射一个『domain』到你的 Homestead 环境的一个文件夹。在 Homestead.yaml 文件中包含一个示例站点配置，你可以根据需要添加许多站点到你的 Homestead 环境。Homestead 能作为一个方便的，虚拟化的环境为你工作的每一个 Laravel 项目服务： sites: - map: homestead.test to: /home/vagrant/code/Laravel/public 如果你改变 sites 属性在配置 Homestead 盒子后，你应当重新运行 vagrant reload --provision 去更新虚拟机中的 Nginx 配置。 主机文件 你必须在你机器的 hosts 文件中为 Nginx 站点添加『domains』。hosts 文件将把你的 Homestead 站点请求重定向到你的 Homestead 机器。在 Mac 和 Linux 中，这个文件位于 /etc/hosts。在 Windows 中，位于 C:\\Windows\\System32\\drivers\\etc\\hosts。你添加到此文件中的行看起来像如下这样： 192.168.10.10 homestead.test 确保列出的 IP 地址是 Homestead.yaml 文件中设置的 IP 地址。一旦你添加域名到你的 hosts 文件，启动 Vagrant 盒子后你能在你的 Web 浏览器中访问它： http://homestead.test ","date":"2018-01-21","objectID":"/posts/mac-homestead/:2:2","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"启动 Vagrant 盒子 一旦你根据你的喜好编辑 Homestead.yaml 后，从你的 Homestead 目录运行 vagrant up 命令。Vagrant 将启动虚拟机并自动配置你的共享文件夹和 Nginx 站点。 在销毁虚拟机，你可以使用 vagrant destroy --force 命令。 ","date":"2018-01-21","objectID":"/posts/mac-homestead/:2:3","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"按项目安装 你可以为你所管理的每个项目配置配置一个 Homestead 实例，而不是在全局范围内安装 Homestead 并在所有的项目中共享相同的 Homestead 盒子。如果你希望随项目一起发送一个 Vagrantfile，那么为每个项目安装 Homestead 可能是大有裨益的，允许其它人在项目中 vagrant up 进行工作。 要直接将 Homestead 安装到你的项目，需要使用 Composer： $ composer require laravel/homestead --dev 一旦 Homestead 被安装，使用 make 命令去生成 Vagrantfile 和 Homestead.yaml 文件在你的项目根目录。make 命令将自动配置 site 和 folders 指令在 Homestead.yaml 文件中。 // Mac / Linux $ php vendor/bin/homestead make // Windows $ vendor\\\\bin\\\\homestead make 接下来，在终端中运行 vagrant up 命令并在浏览器中输入 http://homestead.test 去访问你的项目。记住，你将需要添加一个 homestead.test 到 /etc/hosts 文件中或者你自定义的域名。 ","date":"2018-01-21","objectID":"/posts/mac-homestead/:2:4","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"安装 MariaDB 如果你偏好使用 MariaDB 而不是 MySQL，你可以在 Homestead.yaml 文件中添加 mariadb 选项。这个选项将移除 MySQL 并安装 MariaDB。MariaDB 服务作为 MySQL 的一个替代品，因此你仍然在你的应用程序数据库配置中使用 mysql 数据库驱动： box: laravel/homestead ip: \"192.168.10.10\" memory: 2048 cpus: 4 provider: virtualbox mariadb: true ","date":"2018-01-21","objectID":"/posts/mac-homestead/:2:5","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"安装 MongoDB 要安装 MongoDB 社区版，更新你的 Homestead.yaml 文件用如下的配置选项： mongodb: true 默认的 MongoDB 安装将设置数据库用户名为 homestead，相应地密码为 secret。 ","date":"2018-01-21","objectID":"/posts/mac-homestead/:2:6","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"安装 Elasticsearch 要安装 Elasticsearch，添加 elasticsearch 选项到你的 Homestead.yaml 文件并指定一个支持的版本，该版本可能是一个主版本或者一个精确的版本号（主版本号.次版本号.修复版本号）。默认安装将创建一个名为 homestead 的集群。你应当从不给 Elasticsearch 超过操作系统一半的内存，所以要确保你的 Homestead 机器至少有两倍的 Elasticsearch 分配的内存： box: laravel/homestead ip: \"192.168.10.10\" memory: 4096 cpus: 4 provider: virtualbox elasticsearch: 6 {% note info %} 查阅 Elasticsearch documentation 去学习如何自定义你的配置。 {% endnote %} ","date":"2018-01-21","objectID":"/posts/mac-homestead/:2:7","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"安装 Neo4j Neo4j 是一个图形数据库管理系统。要安装 Neo4j 社区版，更新你的 Homestead.yaml 文件用如下的配置选项： neo4j: true 默认的 Neo4j 安装将设置数据库的用户名为 homestead，相应的密码为 secret。要访问 Neo4j，用浏览器访问 http://homestead.test:7474 地址。你的端口 7687（Bolt），7474（HTTP），7473（HTTPS）是准备好服务来自 Neo4j 客户端的请求的。 ","date":"2018-01-21","objectID":"/posts/mac-homestead/:2:8","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"别名 你可以通过在你的 Homestead 目录下修改 aliases 文件添加 Bash 别名到你的 Homestead 机器： alias c='clear' alias ..='cd ..' 随后你需要更新 aliases 文件，你应当使用 vagrant reload --provision 命令重新配置 Homestead 机器。这将确保在机器中你的新别名可用。 ","date":"2018-01-21","objectID":"/posts/mac-homestead/:2:9","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"踩过的坑 装载 Homestead 镜像 官方的命令是这样的，如果你觉得执行下面命令没问题，那你真是 too young too simple，我可是踩过坑的。 $ vagrant box add laravel/homestead 执行上面命令后，你在 vagrant up 是时会遇到 Box 'laravel/homestead' could not be found 这个不是问题的问题，怎么办，不能凉拌吧。也好办，不就搜索吗? 别搜了，跟我上： $ mkdir -pv ~/Homestead $ cd ~/Homestead $ git clone https://github.com/laravel/homestead.git 查看你的 box 列表 // `virtualbox` 版本为 `0` $ vagrant box list laravel/homestead (virtualbox, 0) // 删除这个添加的 `box` $ vagrant box remove laravel/homestead 在 ~/Homestead/scripts/homestead.rb 文件中有这么一行，要求版本必须是大于 4.0.0，怎么样，我没骗你吧，版本居然不一致。小意思，改下版本号嘛，可别，咱能不碰代码就不碰： config.vm.box_version = settings[\"version\"] ||= \"\u003e= 4.0.0\" 打开克隆的项目，根目录创建 Homestead.json 文件，文件填入以下内容 { \"name\": \"laravel/homestead\", \"versions\": [{ \"version\": \"5.0.1\", \"providers\": [{ \"name\": \"virtualbox\", \"url\": \"file:///path/to/homestead-virtualbox.box\" }] }] } 好了，走一个试试 $ vagrant box add Homestead.json $ vagrant box list laravel/homestead (virtualbox, 5.0.1) 必须卧槽呀，版本号回来了，好了，我们出发 生成 key $ mkdir -pv ~/.ssh/homestead // 文件路径及名称为: ~/.ssh/homestead/homestead_rsa $ ssh-keygen -t rsa -C \"lumen@homestead\" 配置 这个基本上是在修改 ~/Homestead/Vagrantfile 文件 --- ip: \"192.168.10.10\" memory: 2048 cpus: 1 provider: virtualbox authorize: ~/.ssh/homestead/homestead_rsa.pub keys: - ~/.ssh/homestead/homestead_rsa folders: - map: ~/Codes to: /home/vagrant/workspace sites: - map: dev.lumen.com to: /home/vagrant/workspace/lumen/public databases: - homestead # blackfire: # - id: foo # token: bar # client-id: foo # client-token: bar # ports: # - send: 50000 # to: 5000 # - send: 7777 # to: 777 # protocol: udp 启动并进入虚拟机 // 启动 $ vagrant up // 登录虚拟机 $ vagrant ssh Welcome to Ubuntu 16.04.5 LTS (GNU/Linux 4.4.0-101-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage 102 packages can be updated. 29 updates are security updates. Last login: Thu Aug 30 13:32:04 2018 from 10.0.2.2 ","date":"2018-01-21","objectID":"/posts/mac-homestead/:2:10","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"日常操作 ","date":"2018-01-21","objectID":"/posts/mac-homestead/:3:0","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"全局访问 Homestead 有时你想文件系统的任何地方 vagrant up 你的 Homestead 机器。你能这样做，在 Mac / Linux 系统上通过添加一个 Bash 函数到你的 Bash 简介中。在 Windows 中，你可以通过添加一个『batch』文件到 PATH 来完成这个操作。这些脚本将允许你在你的系统的任何地方运行任何 Vagrant 命令，并自动将该命令指向你的 Homestead 安装目录： Mac / Linux function homestead() { ( cd ~/Homestead \u0026\u0026 vagrant $* ) } 确保函数中的 ~/Homestead 路径调整到实际 的 Homestead 安装的位置。一旦该函数被安装，你可以从你的系统的任何位置运行像 homestead up 或者 homestead ssh 命令。 Windows 在你的机器的任何位置创建一个如下内容的 homestead.bat 批处理文件： @echo off set cwd=%cd% set homesteadVagrant=C:\\Homestead cd /d %homesteadVagrant% \u0026\u0026 vagrant %* cd /d %cwd% set cwd= set homesteadVagrant= 确保在脚本中的实例 C:\\Homestead 路径调整为 Homestead 实际安装的位置。创建文件之后，针文件添加到 PATH 中。然后，你可以在你的系统的任何地方运行像 homestead up 或者 homestead ssh 之类的命令。 ","date":"2018-01-21","objectID":"/posts/mac-homestead/:3:1","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"通过 SSH 连接 你能从你的 Homestead 目录中通过在终端中发送 vagrant ssh 命令来 SSH 到你的虚拟机中。 但是，由于你可能需要经常 SSH 到你的 Homestead 机器，考虑将上面的『function』 添加到主机以快速 SSH 到 Homestead 盒子中。 ","date":"2018-01-21","objectID":"/posts/mac-homestead/:3:2","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"数据库连接 一个 homestead 数据库配置了开箱即用的 MySQL 和 PostgreSQL。为了更加方便，Laravel 的 .env 文件配置到框架以开箱即用此数据库。 要从你的主机的数据库客户端连接到你的 MySQL 或者 PostgreSQL 数据库，你应当连接 127.0.0.1 和端口为 33060（MySQL）或者 54320（PostgreSQL）。两个数据库的用户名和密码是 homestead / secret。 {% note danger %} 当从你的主机连接到数据库时，你应当仅使用这些非标准端口。由于 Laravel 在虚拟机中运行。你将在你的 Laravel 数据库配置文件中使用默认的 3306 和 5532 端口。 {% endnote %} ","date":"2018-01-21","objectID":"/posts/mac-homestead/:3:3","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"数据库备份 当你的 Vagrant 盒子销毁时，Homestead 能自动备份你的数据库。为了使用这个功能，你必须使用 Vagrant 2.1.0 或者更高的版本。或者，如果你使用一个旧版本的 Vagrant，你必须安装 vagrant-triggers 插件。为了开启自动数据库备份，添加如下的行到你的 Homestead.yaml 文件： backup: true 一旦配置了，当 vagrant destroy 命令被执行时，Homestead 将导出你的数据库到 mysql_backup 和 postgres_backup 目录。如果你使用 per project installation 方法，则可以在克隆的 Homestead 或者在你的项目根目录中找到这些目录。 ","date":"2018-01-21","objectID":"/posts/mac-homestead/:3:4","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"添加额外的站点 一旦你的 Homestead 环境已配置并运行，你可以为你的 Laravel 应用添加额外的 Nginx 站点。你能在你希望的单个 Homestead 环境运行多个 Laravel 安装。要添加额外的站点，在你的 Homestead.yaml 文件中添加站点： sites: - map: homestead.test to: /home/vagrant/code/Laravel/public - map: another.test to: /home/vagrant/code/another/public 如果 Vagrant 不能自动管理你的『hosts』文件，你可能还需要添加新的站点到该文件中： 192.168.10.10 homestead.test 192.168.10.10 another.test 一旦这个站点被添加，从你的 Homestead 目录运行 vagrant reload --provision 命令。 站点类型 Homestead 支持多种类型的站点，允许你轻松运行不是基于 Laravel 的项目。例如，我们可以使用 symfony2 站点类型轻松地添加一个 Symfony 应用到 Homestead： sites: - map: symfony2.test to: /home/vagrant/code/Symfony/web type: \"symfony2\" 可用的站点类型是：apache，apigility，expressive，laravel（默认），proxy，silverstripe，statamic，symfony2，symfony4，和 zf。 站点参数 你可以通过 params 站点指令添加额外的 Nginx fastcgi_param 值到你的站点。例如，我们添加一个值为 BAR 的 Foo 参数： sites: - map: homestead.test to: /home/vagrant/code/Laravel/public params: - key: FOO value: BAR ","date":"2018-01-21","objectID":"/posts/mac-homestead/:3:5","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"环境变量 你能通过添加如下的值到 Homestead.yaml 文件来设置全局环境变量： variables: - key: APP_ENV value: local - key: FOO value: bar 更新 Homestead.yaml 文件之后，确保通过运行 vagrant reload --provision 命令重新配置机器。这个将更新所有安装 的 PHP 版本的 PHP-FPM 配置并为 vagrant 用户更新环境。 ","date":"2018-01-21","objectID":"/posts/mac-homestead/:3:6","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"配置定时计划 Laravel 提供了一种通过单个计划将每分钟运行 schedule:run Artisan 命令 schedule Cron jobs 的便捷方式。schedule:run 命令将检查在你的 App\\Console\\Kernel 类中定义的计划来决定哪个工作应当被运行。 如果你想为一个 Homestead 站点的 schedule:run 命令去运行，当定义站点时，你可以设置 schedule 选项为 true： sites: - map: homestead.test to: /home/vagrant/code/Laravel/public schedule: true 站点的 Cron 工作将被定义在虚机的 /etc/cron.d 文件夹下。 ","date":"2018-01-21","objectID":"/posts/mac-homestead/:3:7","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"配置 Mailhog Mailhog 允许你轻松地捕获外发的电子邮件并进行检查它，而实际上没有将发送邮件给收件人。开始使用时，更新你的 .env 文件以使用以下的邮件设置： MAIL_DRIVER=smtp MAIL_HOST=localhost MAIL_PORT=1025 MAIL_USERNAME=null MAIL_PASSWORD=null MAIL_ENCRYPTION=null ","date":"2018-01-21","objectID":"/posts/mac-homestead/:3:8","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"配置 Minio Minio 是一个开源的对象存储服务器，具有与 Amazon S3 兼容的 API。要安装 Minio，用以下的配置选项更新你的 Homestead.yaml 文件： minio: true 默认情况下，Minio 为端口 9600 上可用。你可以访问 Minio 控制面板通过访问 http://homestead:9600。默认访问的键名是 homestead，同时默认的密钥是 secretkey。当访问 Minio，你应当总是使用 us-east-1。 为了使用 Minio，你将需要在你的 config/filesystems.php 配置文件中调整 S3 磁盘配置。你将需要添加 use_path_style_endpoint 选项到磁盘配置，并将 url 键更改为 endpoint： 's3' =\u003e [ 'driver' =\u003e 's3', 'key' =\u003e env('AWS_ACCESS_KEY_ID'), 'secret' =\u003e env('AWS_SECRET_ACCESS_KEY'), 'region' =\u003e env('AWS_DEFAULT_REGION'), 'bucket' =\u003e env('AWS_BUCKET'), 'endpoint' =\u003e env('AWS_URL'), 'use_path_style_endpoint' =\u003e true ] 最后，确保你的 .env 文件有如下的选项： AWS_ACCESS_KEY_ID=homestead AWS_SECRET_ACCESS_KEY=secretkey AWS_DEFAULT_REGION=us-east-1 AWS_URL=http://homestead:9600 ","date":"2018-01-21","objectID":"/posts/mac-homestead/:3:9","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"端口 默认情况下，如下的端口将转发到你的 Homestead 环境： SSH：2222 -\u003e 22 ngrok UI：4040 -\u003e 4040 HTTP：8000 -\u003e 80 HTTPS：44300 -\u003e 443 MySQL：33060 -\u003e 3306 PostgreSQL：54320 -\u003e 5432 MongoDB：27017 -\u003e 27017 Mailhog：8025 -\u003e 8025 Minio：9600 -\u003e 9600 转发额外的端口 如果你愿意，你可以转发额外的端口到 Vagrant 盒子，同时也指定他们的协议： ports: - send: 50000 to: 5000 - send: 7777 to: 777 protocol: udp ","date":"2018-01-21","objectID":"/posts/mac-homestead/:3:10","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"共享你的环境 有时你希望共享你当前工作的内容跟同事或客户。Vagrant 有内置的方法通过 vagrant share 去支持这个；然而，如果你有多个站点在你的 Homestead.yaml 文件中配置过，这个将不会工作。 为了解决这个问题，Homestead 包含它自己的 share 命令。开始，通过 SSH 即 vagrant ssh 命令进入到你的 Homestead 机器并运行 share homestead.test。这个将从你的 Homestead.yaml 配置文件中分享 homestead.test 站点。当然，你可以将任何其它配置的站点替换为 homestead.test： share homestead.test 运行此命令之后，你将看到一个 Ngrok 屏幕出现，其中包含了活动日志和共享站点的可访问的 URL。如果你想指定一个自定义的区域，子域，或者其它 Ngrok 运行时选项，你可以添加他们到你的 share 命令： share homestead.test -region=eu -subdomain=laravel {% note danger %} 记住，Vagrant 本质上是不安全的，并且在运行 share 时将虚拟机显露给互联网。 {% endnote %} ","date":"2018-01-21","objectID":"/posts/mac-homestead/:3:11","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"多版本 PHP {% note danger %} 这个功能仅兼容 Nginx。 {% endnote %} Homestead 6 在同一个虚拟机上引入了对多个 PHP 版本的支持。你可以在你的 Homestead.yaml 文件中指定要用于给定站点的 PHP 版本。可用的 PHP 版本是：『5.6』，『7.0』，『7.1』和『7.2』（默认）： sites: - map: homestead.test to: /home/vagrant/code/Laravel/public php: \"5.6\" 另外，你可以通过 CLI 使用任何 PHP 支持的版本： php5.6 artisan list php7.0 artisan list php7.1 artisan list php7.2 artisan list 设置 Cli 下默认的 PHP 版本： // 查看所有 php 版本和当前版本 update-alternatives --display php // 执行后，会列出当前 php 所有版本和编号，输入编号，切换到执行的版本 update-alternatives --config php ","date":"2018-01-21","objectID":"/posts/mac-homestead/:3:12","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"Web 服务器 默认情况下，Homestead 使用 Nginx Web 服务器。然而，如果 apache 是指定的一个站点类型，它能安装 Apache。同时两个 Web 服务器在同时被安装，他们不能同时运行。flip 脚本命令可用来易于处理 Web 服务器之间的切换。flip 命令自动确定正在运行的 Web 服务器，将其关闭。然后启动别一台服务器。要使用这个命令，SSH 进入到你的 Homestead 机器并在终端运行命令： flip ","date":"2018-01-21","objectID":"/posts/mac-homestead/:3:13","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"邮件 Homestead 包括 Postfix 邮件传输代理，默认监听 1025 端口。因此，你可以指示你的应用程序在 localhost 端口 1025 上使用 smtp 邮件驱动。所有发送的邮件将由 Postfix 处理并由 Mailhog 捕获。要查看已发送的邮件，在 Web 浏览器中打开 http://localhost:8025。 ","date":"2018-01-21","objectID":"/posts/mac-homestead/:3:14","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"网络接口 Homestead.yaml 中的 networks 属性为你的 Homestead 环境配置网络接口。你可以根据需要配置多个接口： networks: - type: \"private_network\" ip: \"192.168.10.20\" 要开启一个 bridged 接口，配置 bridge 设置并改变 public_network 网络类型： networks: - type: \"public_network\" ip: \"192.168.10.20\" bridge: \"en1: Wi-Fi (AirPort)\" 要开启 DHCP，仅从你的配置中移除 ip 选项： networks: - type: \"public_network\" bridge: \"en1: Wi-Fi (AirPort)\" ","date":"2018-01-21","objectID":"/posts/mac-homestead/:4:0","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"更新 Homestead 你能通过两个简单的步骤更新 Homestead。首先，你应当更新 Vagrant 盒子使用 vagrant box update 命令： $ vagrant box update 接下来，你需要去更新 Homestead 源代码。如果你克隆过仓库，你能在最初克隆仓库的位置 git pull origin master。 如果你通过你的项目的 composer.json 安装 Homestead，你应当确保你的 composer.json 包含 \"laravel/homestead\": \"^7\" 并更新你的依赖： $ composer update ","date":"2018-01-21","objectID":"/posts/mac-homestead/:5:0","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"提供指定的设置 ","date":"2018-01-21","objectID":"/posts/mac-homestead/:6:0","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"VirtualBox 默认情况下，Homestead 将 natdnshostresolver 配置设置为 on。这允许 Homestead 去使用你的主机操作系统的 DNS 设置。如果你不想覆盖这个行为，添加如下的行到你的 Homestead.yaml 文件： provider: virtualbox natdnshostresolver: off ","date":"2018-01-21","objectID":"/posts/mac-homestead/:6:1","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"符号链接在 Windows 如果符号链接在你的 Windows 机器上无法正常工作，你可能需要添加以下的块到 Vagrantfile 文件： config.vm.provider \"virtualbox\" do |v| v.customize [\"setextradata\", :id, \"VBoxInternal2/SharedFoldersEnableSymlinksCreate/v-root\", \"1\"] end ","date":"2018-01-21","objectID":"/posts/mac-homestead/:6:2","tags":["Mac"],"title":"Mac 搭建 Homestead 集成开发环境","uri":"/posts/mac-homestead/"},{"categories":["Mac"],"content":"简介 MNMP 是 macOS, Nginx, MySQL, PHP 组合开发环境的简称 ","date":"2018-01-21","objectID":"/posts/mac-mnmp/:1:0","tags":["Mac"],"title":"Mac 打造 PHP 开发环境","uri":"/posts/mac-mnmp/"},{"categories":["Mac"],"content":"Mac 准备 请先安装 Homebrew - The missing package manager for macOS ","date":"2018-01-21","objectID":"/posts/mac-mnmp/:2:0","tags":["Mac"],"title":"Mac 打造 PHP 开发环境","uri":"/posts/mac-mnmp/"},{"categories":["Mac"],"content":"旧的安装方式 Homebrew/php deprecation #4721 这种安装方式已经不被推荐，相关的 Formula 已经被迁移到 homebrew-core 下 $ brew tap homebrew/dupes $ brew tap homebrew/versions $ brew tap homebrew/php $ brew tap homebrew/homebrew-php ","date":"2018-01-21","objectID":"/posts/mac-mnmp/:2:1","tags":["Mac"],"title":"Mac 打造 PHP 开发环境","uri":"/posts/mac-mnmp/"},{"categories":["Mac"],"content":"新的安装方式 php: import from homebrew/php #16067 默认了一些必要的扩展（opcache/openssl 等） 其它扩展通过 pecl 去安装 ","date":"2018-01-21","objectID":"/posts/mac-mnmp/:2:2","tags":["Mac"],"title":"Mac 打造 PHP 开发环境","uri":"/posts/mac-mnmp/"},{"categories":["Mac"],"content":"Nginx 安装 $ brew info nginx $ brew install nginx ","date":"2018-01-21","objectID":"/posts/mac-mnmp/:3:0","tags":["Mac"],"title":"Mac 打造 PHP 开发环境","uri":"/posts/mac-mnmp/"},{"categories":["Mac"],"content":"操作 $ sudo brew services start nginx $ sudo brew services restart nginx $ sudo brew services stop nginx ","date":"2018-01-21","objectID":"/posts/mac-mnmp/:3:1","tags":["Mac"],"title":"Mac 打造 PHP 开发环境","uri":"/posts/mac-mnmp/"},{"categories":["Mac"],"content":"开机运行 $ cp /usr/local/opt/nginx/homebrew.mxcl.nginx.plist ~/Library/LaunchAgents/ $ launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist ","date":"2018-01-21","objectID":"/posts/mac-mnmp/:3:2","tags":["Mac"],"title":"Mac 打造 PHP 开发环境","uri":"/posts/mac-mnmp/"},{"categories":["Mac"],"content":"参考 Full Example Configuration ","date":"2018-01-21","objectID":"/posts/mac-mnmp/:3:3","tags":["Mac"],"title":"Mac 打造 PHP 开发环境","uri":"/posts/mac-mnmp/"},{"categories":["Mac"],"content":"MySQL 安装 $ brew install mysql $ unset TMPDIR $ mysqld --initialize-insecure --explicit_defaults_for_timestamp=1 --user=`whoami` --basedir=\"$(brew --prefix mysql)\" --datadir=/usr/local/var/mysql --tmpdir=/tmp $ mysql_secure_installation ","date":"2018-01-21","objectID":"/posts/mac-mnmp/:4:0","tags":["Mac"],"title":"Mac 打造 PHP 开发环境","uri":"/posts/mac-mnmp/"},{"categories":["Mac"],"content":"PHP 安装 ","date":"2018-01-21","objectID":"/posts/mac-mnmp/:5:0","tags":["Mac"],"title":"Mac 打造 PHP 开发环境","uri":"/posts/mac-mnmp/"},{"categories":["Mac"],"content":"旧的安装方式 $ brew info php71 $ brew install php71 ","date":"2018-01-21","objectID":"/posts/mac-mnmp/:5:1","tags":["Mac"],"title":"Mac 打造 PHP 开发环境","uri":"/posts/mac-mnmp/"},{"categories":["Mac"],"content":"新的安装方式 $ brew info php@7.1 $ brew install php@7.1 ","date":"2018-01-21","objectID":"/posts/mac-mnmp/:5:2","tags":["Mac"],"title":"Mac 打造 PHP 开发环境","uri":"/posts/mac-mnmp/"},{"categories":["Mac"],"content":"PHP-FPM: Configuration the Listen Directive PHP-FPM: Configuration the Listen Directive Unix Sockets // www.conf listen = /var/run/php71-fpm.sock listen.owner = www-data listen.group = www-data // nginx.conf fastcgi_pass unix:/var/run/php71-fpm.sock; TCP Sockets // www.conf Listen 127.0.0.1:9000 listen.allowed_clients = 127.0.0.1 // nginx.conf fastcgi_pass 127.0.0.1:9000; ","date":"2018-01-21","objectID":"/posts/mac-mnmp/:5:3","tags":["Mac"],"title":"Mac 打造 PHP 开发环境","uri":"/posts/mac-mnmp/"},{"categories":["Mac"],"content":"扩展安装 旧的扩展安装方式 正常扩展的安装 // Redis $ brew install --HEAD homebrew/php/php71-redis // Memcached $ brew install --HEAD homebrew/php/php71-memcached // Opcache $ brew install php71-opcache // Phalcon $ brew install php71-phalcon // Mongodb $ brew install php71-mongodb 特殊扩展的安装 Intl 扩展安装 #4386 php70-intl #4139 php70-intl sierra bottle not installing config file #2544 php**-intl broken after ﻿﻿icu4c upgrade // php71 $ brew install php71-intl // php70 $ brew install -s php70-intl 新的扩展安装方式 正常扩展的安装 必要是请使用 sudo 执行 // Igbinary $ pecl install igbinary // Mongodb $ pecl install mongodb // Redis $ pecl install redis // Memcached $ pecl install memcached // Xdebug $ pecl install xdebug 特殊扩展的安装 Phalcon 安装 $ which php $ git clone https://github.com/phalcon/cphalcon $ cd cphalcon/build/php7/64bits $ sudo /usr/local/opt/php@7.1/bin/phpize $ sudo ./configure --with-php-config=/usr/local/opt/php@7.1/bin/php-config $ cd /usr/local/include $ ls -s ../opt/openssl/include/openssl . $ cd - $ sudo make $ sudo make install ","date":"2018-01-21","objectID":"/posts/mac-mnmp/:5:4","tags":["Mac"],"title":"Mac 打造 PHP 开发环境","uri":"/posts/mac-mnmp/"},{"categories":["Mac"],"content":"路径 将环境变量添加到 ~/.zshrc 或者 ~/.bashrc 中并进行 source ~/.zshrc 或者 source ~/.bashrc ","date":"2018-01-21","objectID":"/posts/mac-mnmp/:5:5","tags":["Mac"],"title":"Mac 打造 PHP 开发环境","uri":"/posts/mac-mnmp/"},{"categories":["Mac"],"content":"旧的路径 export PATH=\"$(brew --prefix homebrew/php/php71)/bin:$PATH\" export PATH=\"$(brew --prefix php71)/sbin:$PATH\" ","date":"2018-01-21","objectID":"/posts/mac-mnmp/:5:6","tags":["Mac"],"title":"Mac 打造 PHP 开发环境","uri":"/posts/mac-mnmp/"},{"categories":["Mac"],"content":"新的路径 export PATH=\"/usr/local/opt/php@7.1/bin:$PATH\" export PATH=\"/usr/local/opt/php@7.1/sbin:$PATH\" ","date":"2018-01-21","objectID":"/posts/mac-mnmp/:5:7","tags":["Mac"],"title":"Mac 打造 PHP 开发环境","uri":"/posts/mac-mnmp/"},{"categories":["Mac"],"content":"操作 $ brew services start php71 $ brew services restart php71 $ brew services stop php71 ","date":"2018-01-21","objectID":"/posts/mac-mnmp/:5:8","tags":["Mac"],"title":"Mac 打造 PHP 开发环境","uri":"/posts/mac-mnmp/"},{"categories":["Mac"],"content":"开机运行 $ cp /usr/local/opt/php71/homebrew.mxcl.php71.plist ~/Library/LaunchAgents/ $ launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.php71.plist ","date":"2018-01-21","objectID":"/posts/mac-mnmp/:5:9","tags":["Mac"],"title":"Mac 打造 PHP 开发环境","uri":"/posts/mac-mnmp/"},{"categories":["Mac"],"content":"多版本 PHP 安装多版本 PHP $ brew unlink php[55,56,70,71...] $ brew install php[55,56,70,71...] 切换 PHP 版本 $ brew-php-switcher [55,56,70,71...] -s ","date":"2018-01-21","objectID":"/posts/mac-mnmp/:5:10","tags":["Mac"],"title":"Mac 打造 PHP 开发环境","uri":"/posts/mac-mnmp/"},{"categories":["Mac"],"content":"Vagrant 是一个基于 Ruby 的工具，用于创建和部署虚拟化开发环境。它使用 Oracle 的开源 VirtualBox 虚拟化系统，使用 Chef 创建自动化虚拟环境。 ","date":"2018-01-21","objectID":"/posts/mac-vagrant/:0:0","tags":["Mac"],"title":"Mac 中让开发更加容易的 Vagrant","uri":"/posts/mac-vagrant/"},{"categories":["Mac"],"content":"安装 ","date":"2018-01-21","objectID":"/posts/mac-vagrant/:1:0","tags":["Mac"],"title":"Mac 中让开发更加容易的 Vagrant","uri":"/posts/mac-vagrant/"},{"categories":["Mac"],"content":"安装 VirtualBox VirtualBox 或者 Parallels 安装其一就可以了 Download VirtualBox ","date":"2018-01-21","objectID":"/posts/mac-vagrant/:1:1","tags":["Mac"],"title":"Mac 中让开发更加容易的 Vagrant","uri":"/posts/mac-vagrant/"},{"categories":["Mac"],"content":"安装 Parallels Vagrant Parallels Plugin ","date":"2018-01-21","objectID":"/posts/mac-vagrant/:1:2","tags":["Mac"],"title":"Mac 中让开发更加容易的 Vagrant","uri":"/posts/mac-vagrant/"},{"categories":["Mac"],"content":"安装 Vagrant 官网 GitHub ","date":"2018-01-21","objectID":"/posts/mac-vagrant/:1:3","tags":["Mac"],"title":"Mac 中让开发更加容易的 Vagrant","uri":"/posts/mac-vagrant/"},{"categories":["Mac"],"content":"命令 ","date":"2018-01-21","objectID":"/posts/mac-vagrant/:2:0","tags":["Mac"],"title":"Mac 中让开发更加容易的 Vagrant","uri":"/posts/mac-vagrant/"},{"categories":["Mac"],"content":"基本操作 // 添加镜像到 Vagrant vagrant box add centos ~/.vagrant.d/boxes/vagrant-centos-7.1.box // 创建开发目录, 切换目录 mkdir -pv ~/Vagrant/centos cd ~/Vagrant/centos // 初始化 vagrant init centos // 启动环境 vagrant up // 登录虚拟机 vagrant ssh // 将虚拟机挂起, 虚拟机内存都保存到硬盘上, 下次可以快速恢复 vagrant suspend // 将虚拟机关闭, 虚拟机内存释放, 下次启动要慢一点 vagrant halt // 将虚拟机删除, 所有变更都丢失, 下次启动要重新克隆一个 VagrantBox vagrant destroy // 移除虚拟机 vagrant box remove centos // 虚拟机打包之前删除下面的文件 sudo rm -rf /etc/udev/rules.d/70-persistent-ipoib(net).rules // 虚拟机打包 vagrant package --base centos --output centos.box ","date":"2018-01-21","objectID":"/posts/mac-vagrant/:2:1","tags":["Mac"],"title":"Mac 中让开发更加容易的 Vagrant","uri":"/posts/mac-vagrant/"},{"categories":["Mac"],"content":"其它命令 // 添加别名为 centos 的镜像 vagrant box add centos ~/.vagrant.d/boxes/vagrant-centos-7.1.box // 查看所有添加的镜像 vagrant box list // 移除别名为 centos 的镜像 vagrant box remove centos // 移除名称为 bento/centos-7.2，版本为 2.3.0 的镜像 vagrant box remove bento/centos-7.2 --box-version 2.3.0 // 重载虚拟机 vagrant reload // 重启虚拟机并应用对 Vagrantfile 的更改 vagrant reload --provision // 恢复虚拟机状态 vagrant resume // 登录虚拟机 vagrant ssh // 查看虚拟机状态 vagrant status // 暂停虚拟机, 保存状态 vagrant suspend // 查看全局状态 vagrant global-status // 销毁指定的虚拟机（慎用，一旦执行，创建的虚拟机就灰飞烟灭了） vagrant destroy 1a2b3c4d // 升级所有 Box vagrant box update ","date":"2018-01-21","objectID":"/posts/mac-vagrant/:2:2","tags":["Mac"],"title":"Mac 中让开发更加容易的 Vagrant","uri":"/posts/mac-vagrant/"},{"categories":["Mac"],"content":"VirtualBox VBoxManage User Manual // 列出当前系统中所有可用的虚拟机 VBoxManage list vms \"\u003cinaccessible\u003e\" {b457c29d-3eaf-4d19-8f38-7991c85aa43a} \"ubuntu_default_1588584023862_25557\" {eee17f07-35dc-4c48-bff9-8006bf3df55c} \"centos_default_1588597614517_34912\" {3c640794-da30-40b2-a155-c76b42c5cac7} // 克隆虚拟机 VBoxManage clonevm --register ubuntu_default_1588584023862_25557 --name Ubuntu 0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100% Machine has been successfully cloned as \"Ubuntu\" // 将本地虚拟机导出为一个使用开放虚拟化格式（OVF - Open Virtualization Format）文件 VBoxManage export ubuntu_default_1588584023862_25557 -o Ubuntu.ova 0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100% Successfully exported 1 machine(s). // 删除克隆的虚拟机 VBoxManage unregistervm --delete \"Ubuntu\" 0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100% // 导入虚拟机 VBoxManage import Ubuntu.ova --vsys 0 --vmname Ubuntu18 0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100% Interpreting /Users/majinyun/Downloads/qiniu/Ubuntu.ova... OK. Disks: vmdisk1 10737418240 -1 http://www.vmware.com/interfaces/specifications/vmdk.html#streamOptimized Ubuntu-disk001.vmdk -1 -1 vmdisk2 10485760 -1 http://www.vmware.com/interfaces/specifications/vmdk.html#streamOptimized Ubuntu-disk002.vmdk -1 -1 Virtual system 0: 0: Suggested OS type: \"Ubuntu_64\" (change with \"--vsys 0 --ostype \u003ctype\u003e\"; use \"list ostypes\" to list all possible values) 1: VM name specified with --vmname: \"Ubuntu18\" 2: Suggested VM group \"/\" (change with \"--vsys 0 --group \u003cgroup\u003e\") 3: Suggested VM settings file name \"/Users/majinyun/VirtualBoxVMs/ubuntu_default_1588584023862_25557 2/ubuntu_default_1588584023862_25557 2.vbox\" (change with \"--vsys 0 --settingsfile \u003cfilename\u003e\") 4: Suggested VM base folder \"/Users/majinyun/VirtualBoxVMs\" (change with \"--vsys 0 --basefolder \u003cpath\u003e\") 5: Number of CPUs: 2 (change with \"--vsys 0 --cpus \u003cn\u003e\") 6: Guest memory: 1024 MB (change with \"--vsys 0 --memory \u003cMB\u003e\") 7: Sound card (appliance expects \"\", can change on import) (disable with \"--vsys 0 --unit 7 --ignore\") 8: Network adapter: orig NAT, config 3, extra slot=0;type=NAT 9: Network adapter: orig HostOnly, config 3, extra slot=1;type=HostOnly 10: IDE controller, type PIIX4 (disable with \"--vsys 0 --unit 10 --ignore\") 11: IDE controller, type PIIX4 (disable with \"--vsys 0 --unit 11 --ignore\") 12: SCSI controller, type LsiLogic (change with \"--vsys 0 --unit 12 --scsitype {BusLogic|LsiLogic}\"; disable with \"--vsys 0 --unit 12 --ignore\") 13: Hard disk image: source image=Ubuntu-disk001.vmdk, target path=Ubuntu-disk001.vmdk, controller=12;channel=0 (change target path with \"--vsys 0 --unit 13 --disk path\"; disable with \"--vsys 0 --unit 13 --ignore\") 14: Hard disk image: source image=Ubuntu-disk002.vmdk, target path=Ubuntu-disk002.vmdk, controller=12;channel=1 (change target path with \"--vsys 0 --unit 14 --disk path\"; disable with \"--vsys 0 --unit 14 --ignore\") 0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100% Successfully imported the appliance. // 显示指定虚拟机的详细信息 VBoxManage showvminfo \"Ubuntu18\" Name: Ubuntu18 Groups: / Guest OS: Ubuntu (64-bit) UUID: 03d737bc-2e47-4130-aa0b-b6a80767b474 Config file: /Users/majinyun/VirtualBoxVMs/Ubuntu18/Ubuntu18.vbox Snapshot folder: /Users/majinyun/VirtualBoxVMs/Ubuntu18/Snapshots Log folder: /Users/majinyun/VirtualBoxVMs/Ubuntu18/Logs Hardware UUID: 03d737bc-2e47-4130-aa0b-b6a80767b474 Memory size 1024MB Page Fusion: disabled VRAM size: 16MB CPU exec cap: 100% HPET: disabled CPUProfile: host Chipset: piix3 Firmware: BIOS . . . // 启动虚拟机 VBoxManage startvm Ubuntu18 Waiting for VM \"Ubuntu18\" to power on... VM \"Ubuntu18\" has been successfully started. // 关闭虚拟机 VBoxManage controlvm Ubuntu18 poweroff 0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100% // 删除导入的虚拟机 VBoxManage unregistervm --delete \"Ubuntu18\" 0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100% ","date":"2018-01-21","objectID":"/posts/mac-vagrant/:3:0","tags":["Mac"],"title":"Mac 中让开发更加容易的 Vagrant","uri":"/posts/mac-vagrant/"},{"categories":["Mac"],"content":"问题 ","date":"2018-01-21","objectID":"/posts/mac-vagrant/:4:0","tags":["Mac"],"title":"Mac 中让开发更加容易的 Vagrant","uri":"/posts/mac-vagrant/"},{"categories":["Mac"],"content":"解决系统更新后不能挂载共享目录 // 解决 yum update 更新后 vagrant reload 不能挂载共享目录 sudo /etc/init.d/vboxadd setup 共享目录不能挂载到 vagrant 目录 vagrant up 遇到 mount no such device 的问题 broken networking when packaging ubuntu boxes ","date":"2018-01-21","objectID":"/posts/mac-vagrant/:4:1","tags":["Mac"],"title":"Mac 中让开发更加容易的 Vagrant","uri":"/posts/mac-vagrant/"},{"categories":["Mac"],"content":"解决 VBoxManage: error: Failed to create the host-only adapter // 解决 CleanMyMacX 智能清理后不能启动 vagrant 虚拟机 sudo /Library/Application\\ Support/VirtualBox/LaunchDaemons/VirtualBoxStartup.sh restart ","date":"2018-01-21","objectID":"/posts/mac-vagrant/:4:2","tags":["Mac"],"title":"Mac 中让开发更加容易的 Vagrant","uri":"/posts/mac-vagrant/"},{"categories":["Mac"],"content":"解决 /sbin/mount.vboxsf: mounting failed with the error: No such device VirtualBox Guest Additions in Vagrant image vagrant plugin install vagrant-vbguest vagrant vbguest vagrant ssh cd /opt/VBoxGuestAdditions-5.2.4/init/ sudo ./vboxadd setup sudo yum -y install kernel kernel-devel exit vagrant reload ","date":"2018-01-21","objectID":"/posts/mac-vagrant/:4:3","tags":["Mac"],"title":"Mac 中让开发更加容易的 Vagrant","uri":"/posts/mac-vagrant/"},{"categories":["Mac"],"content":"增加 Vagrant 磁盘空间 VBoxManage clonehd centos-vm-disk1.vmdk centos-vm-disk1.vdi --format VDI VBoxManage modifyhd centos-vm-disk1.vdi --resize 20480 VBoxManage clonehd centos-vm-disk1.vdi centos-vm-disk.vmdk --format VMDK RESIZE A VAGRANT VMDK DRIVE Add some way to increase disk space from Vagrantfile Manage a VirtualBox-headless system: stop and remove a VM ","date":"2018-01-21","objectID":"/posts/mac-vagrant/:4:4","tags":["Mac"],"title":"Mac 中让开发更加容易的 Vagrant","uri":"/posts/mac-vagrant/"},{"categories":["Mac"],"content":"更新 VirtualBox 和 Vagrant 后无法启动 vagrant up Vagrant failed to initialize at a very early stage: The plugins failed to initialize correctly. This may be due to manual modifications made within the Vagrant home directory. Vagrant can attempt to automatically correct this issue by running: vagrant plugin repair If Vagrant was recently updated, this error may be due to incompatible versions of dependencies. To fix this problem please remove and re-install all plugins. Vagrant can attempt to do this automatically by running: vagrant plugin expunge --reinstall Or you may want to try updating the installed plugins to their latest versions: vagrant plugin update Error message given during initialization: Unable to resolve dependency: user requested 'vagrant-parallels (\u003e 0)' ","date":"2018-01-21","objectID":"/posts/mac-vagrant/:4:5","tags":["Mac"],"title":"Mac 中让开发更加容易的 Vagrant","uri":"/posts/mac-vagrant/"},{"categories":["Mac"],"content":"更新 VirtualBox 后 Vagrant 提示需要更新版本 I patched Vagrant on macOS with this script vagrant up The provider 'virtualbox' that was requested to back the machine 'default' is reporting that it isn't usable on this system. The reason is shown below: Vagrant has detected that you have a version of VirtualBox installed that is not supported by this version of Vagrant. Please install one of the supported versions listed below to use Vagrant: 4.0, 4.1, 4.2, 4.3, 5.0, 5.1, 5.2, 6.0 A Vagrant update may also be available that adds support for the version you specified. Please check www.vagrantup.com/downloads.html to download the latest version. curl https://github.com/briancain/vagrant/commit/fb4e6985e142da56bad143d70600cd3695c91757.patch \u003e /tmp/vagrant_226_virtualbox_610.patch cd /opt/vagrant/embedded/gems/2.2.6/gems/vagrant-2.2.6 sudo git apply --verbose --exclude='website/*' /tmp/vagrant_226_virtualbox_610.patch Password: Skipped patch 'website/source/docs/virtualbox/index.html.md'. Checking patch plugins/providers/virtualbox/driver/meta.rb... Checking patch plugins/providers/virtualbox/driver/version_6_1.rb... Checking patch plugins/providers/virtualbox/plugin.rb... Applied patch plugins/providers/virtualbox/driver/meta.rb cleanly. Applied patch plugins/providers/virtualbox/driver/version_6_1.rb cleanly. Applied patch plugins/providers/virtualbox/plugin.rb cleanly. ","date":"2018-01-21","objectID":"/posts/mac-vagrant/:4:6","tags":["Mac"],"title":"Mac 中让开发更加容易的 Vagrant","uri":"/posts/mac-vagrant/"},{"categories":["Mac"],"content":"参考 Vagrant 官网 About Vagrant Cloud and Atlas ","date":"2018-01-21","objectID":"/posts/mac-vagrant/:5:0","tags":["Mac"],"title":"Mac 中让开发更加容易的 Vagrant","uri":"/posts/mac-vagrant/"},{"categories":["PHP"],"content":"总而言之，就是巨牛逼 PHP 集成开发 IDE，无出其右者。如果你还挣扎在 Atom，Sublime Text，Vim，EditPlus，Notepad++，PHP Development Tools (PDT)，Zend Studio，Eclipse PDT，NetBeans，KDevelop，PHPEdit，PHP Tools for Visual Studio 等等工具上，不如用一站式的 PhpStorm，避免折腾，专注代码本身。 ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:0:0","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"简介 Lightning-smart PHP IDE. PhpStorm deeply understands your code. 开发 PHP 的一众工具 我不想冒犯谁，至于什么 Editor VS IDE 之类的种种咱先不争论了好吗？说什么 Editor 快 IDE 慢（依我看这样的人不是傻就是蠢），谁不知道用 PHP 写个单文件的 hello world 程序比框架写出来的快！不过说明一下，PhpStorm 比较吃内存。 ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:1:0","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"主要的框架支持 PhpStorm 非常适合工作在 Symfony，Drupal，WordPress，Zend Framework，Laravel，Magento，Joomla，CakePHP，Yii 和其它的框架中。 ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:1:1","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"所有的 PHP 工具 编辑器实际上 gets 你的代码并且深度理解它的结构，为现代和遗留项目提供了所有的 PHP 语言特性。它提供了最好的代码完成，重构，即时错误预防和其它更多的功能。 ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:1:2","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"囊括前端技术 充分利用诸如 HTML5，CSS，Sass，Less，Stylus，CoffeeScript，TypeScript，Emmet 和 JavaScript 等前沿的前端技术，并提供重构，设计和有效的单元测试。在浏览器即时查看更改多亏了有 Live Edit ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:1:3","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"内置的开发者工具 IDE 支持很多常规任务，由于有了版本控制系统集成，支持远程部署，database/SQL，命令行工具，Vagrant，Composer，REST Client 以及许多其它工具 ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:1:4","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"三合一 如果安装了 PhpStorm，WebStorm 可以扔掉了，是的，PhpStorm 就这么牛叉。 PhpStorm = WebStorm + PHP + DB/SQL。 WebStorm 的所有功能都包含在 PhpStorm 中，对 PHP 和 Databases/SQL 支持的全面支持将被添加到顶层 ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:1:5","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"智能编码协助 在你键入的时候，数百个检查工具会检查你的代码，分析整个项目。PHPDoc 支持，代码（重新）编排和格式化，快速修复和其它功能可以帮助你编写易于维护的整洁代码 ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:1:6","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"智能代码导航 让你成为代码库的主人应该归功于高效，闪电般的导航功能。IDE 理解你想去的地方，并立即到达那里 ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:1:7","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"快速而安全的重构 使用 Safe Rename，Move，Delete，Extract Method，Inline Variable，Push members Up / Pull members Down，Change Signature 和许多其它重构，可靠的重构你的代码。特定于语言的重构只需要点击几下就可以帮助你执行项目范围内的更改，并且可以安全了撤消 ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:1:8","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"容易调试和测试 PhpStorm 以其零配置的可视化调试器而闻名，提供非凡的洞察力，让你在每个步骤中了解你的应用程序发生了什么。它工作在 Xdebug 和 Zend Debugger，可以在本地和远程使用。使用 PHPUnit 进行单元测试，与 Behat 和分析器集成 BDD 也是可用的 ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:1:9","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"PhpStorm 信息 ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:2:0","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"安装 JetBranins PhpStorm ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:2:1","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"破解 IntelliJ IDEA 注册码 ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:2:2","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"PhpStorm 快捷键 ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:3:0","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"选项 PhpStorm Key Description Command+, Preferences...: 偏好 Command+H Hide PhpStorm: 隐藏 PhpStorm Option+Command+H Hide Others: 隐藏其它 Command+Q Quit PhpStorm File Key Description Command+N New...: 新建 Shift+Command+S Save As...: 另存为 Command+S Save All: 保存 Option+Command+Y Synchronize: 同步 Edit Key Description Command+Z Undo: 撤销 Shift+Command+Z Redo: 重做 Command+X Cut: 剪切 Command+C Copy: 复制 Shift+Command+C Copy Path: 复制路径 Option+Shift+Command+C Copy Reference: 复制引用 Command+V Paste: 粘贴 Shift+Command+V Paste from History...: 从粘贴板历史中选择粘贴 Option+Shift+Command+V Paste Simple: 简单粘贴 Delete Delete: 删除 Find Command+F Find...: 查找 Command+R Replace...: 替换 Command+G Find Next / Move to Next Occurrence: 查找下一个 / 移动到下一个出现的地方 Shift+Command+G Find Previous / Move to Previous Occurrence: 查找上一个 / 移动到上一个出现的地方 Control+Command+G Select All Occurrences: 选中所有出现的地方 Control+G Add Selection for Next Occurrence: 选中下一个出现的地方 Control+Shift+G Unselect Occurrence: 取消选中的地方 Shift+Command+F Find in Path...: 在路径中查找 Shift+Command+R Replace in Path...: 在路径中替换 Option+F7 Find Usages: 查找使用的地方 Option+Shift+Command+F7 Find Usages Settings...: 查找使用设置 Option+Command+F7 Show Usages: 显示使用的地方 Command+F7 Find Usages in File: 在文件中查找使用的地方 Shift+Command+F7 Highlight Usages in File: 在文件中高亮使用的地方 Option+Command+X Find by XPath...: 通过自定义路径查找 Shift+Command+8 Column Selection Mode: 列选择模式 Command+A Select All: 选中所有 Option+↑ Extend Selection: 扩展选中 Option+↓ Shrink Selection: 缩小选中 Control+Shift+J Join Lines: 合并行 Command+D Duplicate Line: 复制行 Tab Indent Selection: 选中向右缩进 Shift+Tab Unindent Line of Selection: 选中向左缩进 Shift+Command+U Toggle Case: 大小写切换 Tab Next Parameter: 下一个参数 Shift+Tab Previous Parameter: 上一个参数 View Key Description Tool Windows Command+1 Project: 项目 Command+2 Favorites: 喜好 Command+3 Find: 查找 Command+4 Run: 运行 Command+5 Debug: 调试 Command+6 TODO: 待办事项 Command+7 Structure: 结构 Command+8 Hierarchy: 继承 Command+9 Version Control: 版本控制 Option+F12 Terminal: 终端 F1 Quick Documentation: 快速到文档 Command+P Parameter Info: 参数信息 Command+E Recent Files: 最近打开的文件 Shift+Command+E Recently Changed Files: 最近修改的文件 Option+Shift+C Recent Changes: 最近修改文件历史记录 Command+D Compare With...: 当前文件与历史记录比较 Control+` Quick Switch Scheme...: 快速切换模式 Control+Command+F Enter Full Screen: 全屏 Navigate Key Description Command+O Class...: 搜索类 Shift+Command+O File...: 搜索文件 Option+Command+O Symbol...: 搜索符号 Option+Command+. Custom Folding...: 搜索自定义折叠 Command+L Line...: 定位行 Command+[ Back: 反退 Command+] Forward: 前进 Shift+Command+Delete Last Edit Location: 最后编辑位置 Bookmarks F3 Toggle Bookmark: 切换书签 Option+F3 Toggle Bookmark with Mnemonic: 切换书签记忆 Command+F3 Show Bookmark: 显示书签 Option+F1 Select In...: 选择目标 Command+↑ Jump to Navigation Bar: 跳转到导航栏 Command+B Declaration: 跳转到函数声明 Option+Command+B Implementation(s): 跳转到接口实现类 Shift+Command+B Type Declaration: 跳转到类型声明 Command+U Super Method: 跳转到超级方法 Shift+Command+T Test: 跳转到测试类 Control+Command+↑ Related Symbol...: 相关符号 Command+F12 File Structure: 文件结构 Control+H Type Hierarchy: 类型继承 Shift+Command+H Method Hierarchy: 方法继承 Control+Option+H Call Hierarchy: 调用继承 F2 Next Highlighted Error: 下一个高亮错误 Shift+F2 Previous Highlighted Error: 上一个高亮错误 Control+Option+→ Next Emmet Edit Point: 下一个 Emmet 编辑点 Control+Option+← Previous Emmet Edit Point: 上一个 Emmet 编辑点 Control+↓ Next Method: 下一个方法 Control+↑ Previous Method: 上一个方法 Code Key Description Control+O Override Method...: 覆盖方法 Control+I Implement Method...: 实现方法 Command+N Generate...: 生成 Option+Command+T Surround With...: 环绕 Shift+Command+Delete Unwrap / Remove: 打开 / 移除 Completion Option+/ Cyclic Expand Word: 循环展开单词(向前) Shift+Option+? Cyclic Expand Word(Backward): 循环展开单词(向后) Folding Command++ Expand: 展开 Command+- Collapse: 折叠 Option+Command++ Expand Recursively: 递归展开 Option+Command+- Collapse Recursively: 递归折叠 Shift+Command++ Expand All: 展开所有 Shift+Command+- Collapse All: 折叠所有 Command+J Insert Live Template...: 插入模板 Option+Command+J Surround with Live Template...: 环绕模板 Command+/ Comment with Line Comment: 行注释 Option+Command+/ Comment with Block Comment: 块注释 O","date":"2018-01-21","objectID":"/posts/php-phpstorm/:3:1","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"主题 Colour schemes for a variety of editors created by Dayle Rees ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:3:2","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"帮助 ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:3:3","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"其它 ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:4:0","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"插件 A Static Code Analyzer for PHP (a PhpStorm/Idea Plugin) environment parameters completion, based on .env file keys Vim emulation plug-in for IDEs based on the IntelliJ platform Interactive viewer for ‘.log’ files ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:4:1","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"教程 Be Awesome in PHPStorm Getting Started ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:4:2","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["PHP"],"content":"问题 优化 phpstorm 运行卡顿问题 phpstorm 在 mac 上卡顿 mac 下 intellij idea 变得特别卡该如何解决 ","date":"2018-01-21","objectID":"/posts/php-phpstorm/:4:3","tags":["PHP"],"title":"PHP 开发利器之 PhpStorm","uri":"/posts/php-phpstorm/"},{"categories":["MySQL"],"content":"MySQL-5.5 之前， UTF8 编码只支持 1-3 个字节，只支持 BMP 这部分的 Unicode 编码区，而 Emoji 图标恰好是 4 个字节的编码进行存储。从 MySQL-5.5 开始，可支持 4 个字节 UTF 编码 utf8mb4，一个字符最多能有 4 字节，所以能支持更多的字符集。所以要解决问题，必需把数据库表字符编码全部改成 utf8mb4。 MySQL 数据类型 MySQL 用户管理 MySQL 关键字查询 MySQL 字符串函数 MySQL 字符串连接函数 MySQL 忘记 root 密码后重置 MySQL 最值查询 MySQL 日期时间函数 MySQL 联合查询 MySQL 查询当前年、季、月、周的第一天和最后一天 MySQL 支持 Emoji 图标的设置 MySQL 存储引擎 MySQL 隔离级别及其脏读不可重复读幻读 ","date":"2018-01-21","objectID":"/posts/mysql-support-emoji/:0:0","tags":["MySQL"],"title":"MySQL 支持 emoji 图标的设置","uri":"/posts/mysql-support-emoji/"},{"categories":["MySQL"],"content":"常用字符集 Unicode：是字符集，而没有编码方式 UTF-8：是一种 Unicode 字符集的编码方式，其他还有 UTF-16，UTF-32 等 ASCII - American Standard Code for Information Interchange：美国信息交换标准代码，主要用于显示现代英语和其他西欧语言。单字节编码，7 位表示一个字符，共 128 个字符 GBK - Chinese Internal Code Specification：汉字内码扩展规范。双字节编码，共收录了 21003 个汉字，共有 21885 个字符，兼容 GB2312-80 标准 UTF-8 - 8-bit Unicode Transformation Format：针对 Unicode 的可变长度字符编码，又称万国码。UTF-8 用 1 到 6 个字节编码 Unicode 字符，如果 UNICODE 字符由 2 个字节表示，则编码成 UTF-8 很可能需要 3 个字节。而如果 UNICODE 字符由 4 个字节表示，则编码成 UTF-8 可能需要 6 个字节。Unicode 一个中文字符占 2 个字节，而 UTF-8 一个中文字符占 3 个字节 utf8mb4 - 8-bit Unicode Transformation Format：utf8mb4 兼容 utf8，能支持更多的字符集，MySQL 在 5.5.3 之后增加了这个编码。most bytes 4 是专门用来兼容四字节的 Unicode，也就是说能存储四个字节，处理 emoji 表情毫无压力 ","date":"2018-01-21","objectID":"/posts/mysql-support-emoji/:1:0","tags":["MySQL"],"title":"MySQL 支持 emoji 图标的设置","uri":"/posts/mysql-support-emoji/"},{"categories":["MySQL"],"content":"操作 设置成 utf8mb4 请根据实际情况而定，没有必要全部都设置为 utf8mb4。 ","date":"2018-01-21","objectID":"/posts/mysql-support-emoji/:2:0","tags":["MySQL"],"title":"MySQL 支持 emoji 图标的设置","uri":"/posts/mysql-support-emoji/"},{"categories":["MySQL"],"content":"将数据库，数据表，数据表字段设置为 utf8mb4 // 更改数据库的编码方式 ALTER DATABASE test CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci; // 更改数据表的编码方式 ALTER TABLE test.demo CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; // 更改数据表的字段编码方式 ALTER TABLE test.demo CHANGE `title` `title` VARCHAR(80) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT ''; 或 ALTER TABLE test.demo MODIFY `title` VARCHAR(80) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT ''; ","date":"2018-01-21","objectID":"/posts/mysql-support-emoji/:2:1","tags":["MySQL"],"title":"MySQL 支持 emoji 图标的设置","uri":"/posts/mysql-support-emoji/"},{"categories":["MySQL"],"content":"查看设置 查看数据库设置情况 SHOW VARIABLES WHERE Variable_name LIKE 'character\\_set\\_%' OR Variable_name LIKE 'collation%'; // 结果 character_set_client utf8mb4 character_set_connection utf8mb4 character_set_database utf8mb4 character_set_filesystem binary character_set_results utf8mb4 character_set_server utf8mb4 character_set_system utf8 collation_connection utf8mb4_general_ci collation_database utf8mb4_general_ci collation_server utf8mb4_general_ci 查看数据表设置情况 SHOW FULL COLUMNS FROM test.demo; ","date":"2018-01-21","objectID":"/posts/mysql-support-emoji/:2:2","tags":["MySQL"],"title":"MySQL 支持 emoji 图标的设置","uri":"/posts/mysql-support-emoji/"},{"categories":["MySQL"],"content":"参考 Unicode 和 UTF-8 有何区别 清官谈 mysql 中 utf8 和 utf8mb4 区别 ","date":"2018-01-21","objectID":"/posts/mysql-support-emoji/:3:0","tags":["MySQL"],"title":"MySQL 支持 emoji 图标的设置","uri":"/posts/mysql-support-emoji/"},{"categories":["MySQL"],"content":"MySQL 也有很多存储引擎，不过常用的还是 InnoDB 引擎，本文就汇总一下这些存储引擎。 MySQL 数据类型 MySQL 用户管理 MySQL 关键字查询 MySQL 字符串函数 MySQL 字符串连接函数 MySQL 忘记 root 密码后重置 MySQL 最值查询 MySQL 日期时间函数 MySQL 联合查询 MySQL 查询当前年、季、月、周的第一天和最后一天 MySQL 支持 emoji 图标的设置 MySQL 存储引擎 MySQL 隔离级别及其脏读不可重复读幻读 ","date":"2018-01-20","objectID":"/posts/mysql-storage-engine/:0:0","tags":["MySQL"],"title":"MySQL 存储引擎","uri":"/posts/mysql-storage-engine/"},{"categories":["MySQL"],"content":"MySQL 的存储引擎 Archive：用于数据存档的引擎（数据行被插入后就不能再修改了）。非常适合存储大量的独立的，作为历史记录的数据。因为它们不经常被读取。Archive 拥有高效的插入速度，但其对查询的支持相对较差 BDB：源自 Berkeley DB，事务型数据库的另一种选择，支持 COMMIT 和 ROLLBACK 等其他事务特性 BlackHole：黑洞引擎(写操作是删除数据，读操作是返回空白记录)。由于写入的任何数据都会消失。一般用于记录 binlog 做复制的中继 CSV：逻辑上由逗号分割数据的存储引擎。它会在数据库子目录里为每个数据表创建一个 .CSV 文件。这是一种普通文本文件，每个数据行占用一个文本行。CSV 存储引擎不支持索引 Example：实例(存根)存储引擎。官方实例 Falcon：用来进行事务处理的存储引擎 Federated：用来访问远程数据表的存储引擎。将不同的 MySQL 服务器联合起来，逻辑上组成一个完整的数据库。非常适合分布式应用 InnoDB：具备外键支持功能的事务处理引擎。MySQL-5.5 版本后 MySQL 的默认数据库引擎，是专为事务设计的存储引擎，支持 ACID 事务，支持外键和行级锁定，拥有高并发处理能力。但是，InnoDB 在创建索引和加载数据时，比 MyISAM 慢 Memory：内存引擎。所有数据置于内存，表结构不是存储在内存中的存储引擎，查询时不需要执行磁盘 I/O 操作，所以要比 MyISAM 和 InnoDB 快很多倍。但是会占用和数据量成正比的内存空间。并且其内容会在 MySQL 重新启动时丢失，表结构不会丢失 Merge/MRG_MYISAM：管理由多个 MyISAM 数据表构成的数据表集合。将一定数量的 MyISAM 表联合而成一个整体，在超大规模数据存储时很有用 MyISAM：不支持事务和行级锁，所以 MyISAM 引擎速度很快，性能优秀。MyISAM 可以对整张表加锁，支持并发插入，支持全文索引 NDB/Cluster：MySQL Cluster 专用存储引擎。高冗余的存储引擎，用多台数据机器联合提供服务以提高整体性能和安全性。适合数据量大，安全和性能要求高的应用 PERFORMANCE_SCHEMA：Performance Schema ","date":"2018-01-20","objectID":"/posts/mysql-storage-engine/:1:0","tags":["MySQL"],"title":"MySQL 存储引擎","uri":"/posts/mysql-storage-engine/"},{"categories":["MySQL"],"content":"查看数据库支持的引擎 SHOW ENGINES; ","date":"2018-01-20","objectID":"/posts/mysql-storage-engine/:2:0","tags":["MySQL"],"title":"MySQL 存储引擎","uri":"/posts/mysql-storage-engine/"},{"categories":["MySQL"],"content":"MyISAM 和 InnoDB 名称 MyISAM InnoDB 备注 使用场景 为速度而设计，和 SELECT 搭配使用更好 为高可靠性和高性能而设计，适合处理大量数据 表锁类型 表级锁，特定的操作会将整张表锁起来，上锁期间，表中的数据不能进行其它操作。偏向静态数据，动态数据会影响性能 行级锁，只对 SELECT，UPDATE，DELETE 操作的特定数据加上行锁，上锁期间，表中的其它数据依然能被操作 外键支持 不支持 支持，对外键和引用完整性支持，包括递归式删除和更新 事务支持 不支持，没有 COMMIT 和 ROLLBACK，对操作没有回退的余地 支持，执行 COMMIT 和 ROLLBACK 操作，可以将事务中的数据变化进行回滚，崩溃后的自动恢复 集群支持 不支持 并不完全支持。可以将表转换为 NDB 存储引擎而用在集群环境中 数据操作 数据压缩，自我复制，查询缓存，数据加密 数据压缩，自我复制，查询缓存，数据加密 全文索引 支持全文检索，需要通过 FULLTEXT 索引来实现 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，并且效果更好 存储结构 每个 MyISAM 在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm 文件存储表定义。数据文件的扩展名为 .MYD - MYData。索引文件的扩展名是 .MYI - MYIndex 所有的表都保存在同一个数据文件中(也可能是多个文件，或者是独立的表空间文件)，InnoDB 表的大小只受限于操作系统文件的大小，一般为 2GB 存储空间 可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)，动态表，压缩表 需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引 AUTO_INCREMENT 可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增 InnoDB 中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列 表主键 允许没有任何索引和主键的表存在，索引都是保存行的地址 如果没有设定主键或者非空唯一索引，就会自动生成一个 6 字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值 表的行数 保存有表的总行数，如果 SELECT COUNT(*) FROM table; 会直接取出出该值 没有保存表的总行数，如果 SELECT COUNT(*) FROM table; 就会遍历整个表，消耗相当大，但是在加了 wehre 条件后，MyISAM 和 InnoDB 处理的方式都一样 其它支持 支持空间数据类型和 SPATIAL 索引 InnoDB 存储引擎会把数据表集中存储在一个共享的表空间里 ","date":"2018-01-20","objectID":"/posts/mysql-storage-engine/:3:0","tags":["MySQL"],"title":"MySQL 存储引擎","uri":"/posts/mysql-storage-engine/"},{"categories":["MySQL"],"content":"如果结果的长度大于 max_allowed_pa​​cket 系统变量的值，则字符串值函数将返回 NULL。看 Configuring the Server MySQL 数据类型 MySQL 用户管理 MySQL 关键字查询 MySQL 字符串函数 MySQL 字符串连接函数 MySQL 忘记 root 密码后重置 MySQL 最值查询 MySQL 日期时间函数 MySQL 联合查询 MySQL 查询当前年、季、月、周的第一天和最后一天 MySQL 支持 emoji 图标的设置 MySQL 存储引擎 MySQL 隔离级别及其脏读不可重复读幻读 ","date":"2018-01-20","objectID":"/posts/mysql-string-functions/:0:0","tags":["MySQL"],"title":"MySQL 字符串函数","uri":"/posts/mysql-string-functions/"},{"categories":["MySQL"],"content":"常用字符串函数 名称 描述 备注 LEFT() 从左边截取指定的字符串 MID() 从指定的位置截取字符串 RIGHT() 从右边截取指定的字符串 TRIM() 移除字符串两端的空格 SUBSTR() 截取指定的字符串 SUBSTRING() 截取指定的字符串 SUBSTRING_INDEX() 截取指定的定界符出现的次数之前的字符串 ","date":"2018-01-20","objectID":"/posts/mysql-string-functions/:1:0","tags":["MySQL"],"title":"MySQL 字符串函数","uri":"/posts/mysql-string-functions/"},{"categories":["MySQL"],"content":"字符串函数用法 ","date":"2018-01-20","objectID":"/posts/mysql-string-functions/:2:0","tags":["MySQL"],"title":"MySQL 字符串函数","uri":"/posts/mysql-string-functions/"},{"categories":["MySQL"],"content":"LEFT 和 RIGHT 函数 SELECT LEFT('hello world, hello mysql', 5) AS url; SELECT RIGHT('hello world, hello mysql', 5) AS url; // 结果 hello mysql ","date":"2018-01-20","objectID":"/posts/mysql-string-functions/:2:1","tags":["MySQL"],"title":"MySQL 字符串函数","uri":"/posts/mysql-string-functions/"},{"categories":["MySQL"],"content":"TRIM 函数 SELECT TRIM(' http://www.mysql.com ') AS url; SELECT TRIM(LEADING 'xyz' FROM 'xyzxyzxyzhello world') AS url; SELECT TRIM(BOTH 'z' FROM 'zzzzzhello worldzzzzz') AS url; SELECT TRIM(TRAILING 'test' FROM 'hello worldtest') AS url; // 结果 http://www.mysql.com hello world hello world hello world ","date":"2018-01-20","objectID":"/posts/mysql-string-functions/:2:2","tags":["MySQL"],"title":"MySQL 字符串函数","uri":"/posts/mysql-string-functions/"},{"categories":["MySQL"],"content":"SUBSTR 和 SUBSTRING 和 MID 函数 SET @url = 'http://www.mysql.com/'; SELECT MID(@url, 8, 13) AS url; SELECT SUBSTR(@url, 8, 13) AS url; SELECT SUBSTRING(@url , -14, 13) AS url; // 结果 www.mysql.com www.mysql.com www.mysql.com ","date":"2018-01-20","objectID":"/posts/mysql-string-functions/:2:3","tags":["MySQL"],"title":"MySQL 字符串函数","uri":"/posts/mysql-string-functions/"},{"categories":["MySQL"],"content":"SUBSTRING_INDEX 函数 SELECT SUBSTRING_INDEX('www.mysql.com.cn', '.', 3) AS url; SELECT SUBSTRING_INDEX('hello world, hello mysql', 'mysql ', 1) AS url; // 结果 www.mysql.com hello world, hello mysql ","date":"2018-01-20","objectID":"/posts/mysql-string-functions/:2:4","tags":["MySQL"],"title":"MySQL 字符串函数","uri":"/posts/mysql-string-functions/"},{"categories":["MySQL"],"content":"参考 String Functions ","date":"2018-01-20","objectID":"/posts/mysql-string-functions/:3:0","tags":["MySQL"],"title":"MySQL 字符串函数","uri":"/posts/mysql-string-functions/"},{"categories":["MySQL"],"content":"MySQL 的字符串连接函数 CONCAT，CONCAT_WS，GROUP_CONTACT。 MySQL 数据类型 MySQL 用户管理 MySQL 关键字查询 MySQL 字符串函数 MySQL 字符串连接函数 MySQL 忘记 root 密码后重置 MySQL 最值查询 MySQL 日期时间函数 MySQL 联合查询 MySQL 查询当前年、季、月、周的第一天和最后一天 MySQL 支持 emoji 图标的设置 MySQL 存储引擎 MySQL 隔离级别及其脏读不可重复读幻读 ","date":"2018-01-20","objectID":"/posts/mysql-string-concat-functions/:0:0","tags":["MySQL"],"title":"MySQL 字符串连接函数","uri":"/posts/mysql-string-concat-functions/"},{"categories":["MySQL"],"content":"数据准备 /* Navicat Premium Data Transfer Source Server : localhost Source Server Type : MySQL Source Server Version : 50718 Source Host : 127.0.0.1 Source Database : test Target Server Type : MySQL Target Server Version : 50718 File Encoding : utf-8 Date: 07/14/2017 23:53:40 PM */ SET NAMES utf8mb4; SET FOREIGN_KEY_CHECKS = 0; -- ---------------------------- -- Table structure for `demo` -- ---------------------------- DROP TABLE IF EXISTS `demo`; CREATE TABLE `demo` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键 ID', `key` varchar(50) NOT NULL DEFAULT '' COMMENT '用户名', `val` varchar(50) NOT NULL DEFAULT '' COMMENT '用户姓', `createdAt` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间戳', `updatedAt` int(10) unsigned DEFAULT '0' COMMENT '更新时间戳', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8; -- ---------------------------- -- Records of `demo` -- ---------------------------- BEGIN; INSERT INTO `demo` VALUES ('1', 'A', '10', '0', '0'), ('2', 'B', '20', '0', '0'), ('3', 'B', '21', '0', '0'), ('4', 'C', '30', '0', '0'), ('5', 'C', '31', '0', '0'), ('6', 'C', '32', '0', '0'), ('7', 'D', '40', '0', '0'), ('8', 'D', '41', '0', '0'), ('9', 'D', '42', '0', '0'), ('10', 'D', '43', '0', '0'), ('11', 'E', '50', '0', '0'), ('12', 'E', '51', '0', '0'), ('13', 'E', '52', '0', '0'), ('14', 'E', '53', '0', '0'), ('15', 'E', '54', '0', '0'), ('16', 'F', '60', '0', '0'), ('17', 'F', '61', '0', '0'), ('18', 'F', '62', '0', '0'), ('19', 'F', '63', '0', '0'), ('20', 'F', '64', '0', '0'), ('21', 'F', '65', '0', '0'); COMMIT; SET FOREIGN_KEY_CHECKS = 1; ","date":"2018-01-20","objectID":"/posts/mysql-string-concat-functions/:1:0","tags":["MySQL"],"title":"MySQL 字符串连接函数","uri":"/posts/mysql-string-concat-functions/"},{"categories":["MySQL"],"content":"GROUP_CONCAT() - 列转行 ","date":"2018-01-20","objectID":"/posts/mysql-string-concat-functions/:2:0","tags":["MySQL"],"title":"MySQL 字符串连接函数","uri":"/posts/mysql-string-concat-functions/"},{"categories":["MySQL"],"content":"将 key 和 val 用空格连接，用冒号加空格连成一行，按 id 降序，并按 key 进行分组 SELECT GROUP_CONCAT( CONCAT_WS(': ', `key`, `val`) ORDER BY `id` DESC SEPARATOR ', ' ) AS info FROM demo GROUP BY `key`; // 结果 A: 10 B: 21, B: 20 C: 32, C: 31, C: 30 D: 43, D: 42, D: 41, D: 40 E: 54, E: 53, E: 52, E: 51, E: 50 F: 65, F: 64, F: 63, F: 62, F: 61, F: 60 ","date":"2018-01-20","objectID":"/posts/mysql-string-concat-functions/:2:1","tags":["MySQL"],"title":"MySQL 字符串连接函数","uri":"/posts/mysql-string-concat-functions/"},{"categories":["MySQL"],"content":"将所有的 val 去重后连成一行，并按 key 分组 SELECT GROUP_CONCAT(DISTINCT `val`) AS `vals` FROM demo GROUP BY `key`; // 结果 10 20,21 30,31,32 40,41,42,43 50,51,52,53,54 60,61,62,63,64,65 ","date":"2018-01-20","objectID":"/posts/mysql-string-concat-functions/:2:2","tags":["MySQL"],"title":"MySQL 字符串连接函数","uri":"/posts/mysql-string-concat-functions/"},{"categories":["MySQL"],"content":"CONCAT() - 连接字符串 CONCAT(str1,str2,…) ","date":"2018-01-20","objectID":"/posts/mysql-string-concat-functions/:3:0","tags":["MySQL"],"title":"MySQL 字符串连接函数","uri":"/posts/mysql-string-concat-functions/"},{"categories":["MySQL"],"content":"CONCAT() 函数在连接字符串的时候，只要其中一个是 NULL，那么将返回 NULL SELECT CONCAT('a', 'b', 'c', NULL) AS string; // 结果 NULL ","date":"2018-01-20","objectID":"/posts/mysql-string-concat-functions/:3:1","tags":["MySQL"],"title":"MySQL 字符串连接函数","uri":"/posts/mysql-string-concat-functions/"},{"categories":["MySQL"],"content":"CONCAT_WS() - 按指定符号连接字符串 即 CONCAT With Separator，是 CONCAT() 的特殊形式 CONCAT_WS(separator,str1,str2,…) ","date":"2018-01-20","objectID":"/posts/mysql-string-concat-functions/:4:0","tags":["MySQL"],"title":"MySQL 字符串连接函数","uri":"/posts/mysql-string-concat-functions/"},{"categories":["MySQL"],"content":"和 CONCAT() 函数不同的是，CONCAT_WS() 函数在执行的时候，不会因为 NULL 值而返回 NULL SELECT CONCAT_WS( '', 'a', 'b', 'c', '', NULL, FALSE, TRUE ) AS string; // 结果 abc01 ","date":"2018-01-20","objectID":"/posts/mysql-string-concat-functions/:5:0","tags":["MySQL"],"title":"MySQL 字符串连接函数","uri":"/posts/mysql-string-concat-functions/"},{"categories":["MySQL"],"content":"将每个 val 用 | 连接起来，并按 key 分组 SELECT CONCAT_WS('|', `key`, `val`) AS info FROM demo; // 结果 A|10 B|20 B|21 C|30 C|31 C|32 D|40 D|41 D|42 D|43 E|50 E|51 E|52 E|53 E|54 F|60 F|61 F|62 F|63 F|64 F|65 ","date":"2018-01-20","objectID":"/posts/mysql-string-concat-functions/:5:1","tags":["MySQL"],"title":"MySQL 字符串连接函数","uri":"/posts/mysql-string-concat-functions/"},{"categories":["MySQL"],"content":"按 key 分组，将 val 的值按逗号空格分隔后连接到 key 字段中 如: F: 60, 61, 62, 63, 64, 65 SELECT GROUP_CONCAT(`key` SEPARATOR ',') AS `val` FROM ( SELECT CONCAT( `key`, ': ', GROUP_CONCAT(`val` SEPARATOR ', ') ) AS `key` FROM demo GROUP BY `key` ) custom GROUP BY `key`; // 结果 A: 10 B: 20, 21 C: 30, 31, 32 D: 40, 41, 42, 43 E: 50, 51, 52, 53, 54 F: 60, 61, 62, 63, 64, 65 ","date":"2018-01-20","objectID":"/posts/mysql-string-concat-functions/:5:2","tags":["MySQL"],"title":"MySQL 字符串连接函数","uri":"/posts/mysql-string-concat-functions/"},{"categories":["MySQL"],"content":"参考 Difference between GROUP_CONCAT() and CONCAT_WS() ","date":"2018-01-20","objectID":"/posts/mysql-string-concat-functions/:6:0","tags":["MySQL"],"title":"MySQL 字符串连接函数","uri":"/posts/mysql-string-concat-functions/"},{"categories":["MySQL"],"content":"联合查询语句牵扯到多张表，多表查询有多种语法，多种使用场景，不同的场景需要不同的语法。 MySQL 数据类型 MySQL 用户管理 MySQL 关键字查询 MySQL 字符串函数 MySQL 字符串连接函数 MySQL 忘记 root 密码后重置 MySQL 最值查询 MySQL 日期时间函数 MySQL 联合查询 MySQL 查询当前年、季、月、周的第一天和最后一天 MySQL 支持 emoji 图标的设置 MySQL 存储引擎 MySQL 隔离级别及其脏读不可重复读幻读 ","date":"2018-01-20","objectID":"/posts/mysql-join-query/:0:0","tags":["MySQL"],"title":"MySQL 联合查询","uri":"/posts/mysql-join-query/"},{"categories":["MySQL"],"content":"数据准备 /* Navicat Premium Data Transfer Source Server : localhost Source Server Type : MySQL Source Server Version : 50718 Source Host : 127.0.0.1 Source Database : test Target Server Type : MySQL Target Server Version : 50718 File Encoding : utf-8 Date: 05/16/2017 08:44:43 AM */ SET NAMES utf8mb4; SET FOREIGN_KEY_CHECKS = 0; -- ---------------------------- -- Table structure for `course` -- ---------------------------- DROP TABLE IF EXISTS `course`; CREATE TABLE `course` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键 ID', `title` varchar(50) NOT NULL DEFAULT '' COMMENT '课程标题名称', `englishName` varchar(50) DEFAULT '' COMMENT '英文名称', `createdAt` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间戳', `updatedAt` int(10) unsigned DEFAULT '0' COMMENT '更新时间戳', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8; -- ---------------------------- -- Records of `course` -- ---------------------------- BEGIN; INSERT INTO `course` VALUES ('1', '语文', 'Chinese', '0', '0'), ('2', '数学', 'Mathematics', '0', '0'), ('3', '英语', 'English', '0', '0'), ('4', '历史', 'History', '0', '0'), ('5', '政治', 'Politics', '0', '0'), ('6', '地理', 'Geography', '0', '0'), ('7', '物理', 'Physics', '0', '0'), ('8', '化学', 'Chemistry', '0', '0'), ('9', '生物', 'Biology', '0', '0'), ('10', '体育', 'Sports', '0', '0'); COMMIT; -- ---------------------------- -- Table structure for `lesson` -- ---------------------------- DROP TABLE IF EXISTS `lesson`; CREATE TABLE `lesson` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键 ID', `courseId` int(10) unsigned DEFAULT '0' COMMENT '所属课程 ID', `title` varchar(50) NOT NULL DEFAULT '' COMMENT '课时标题名称', `tags` varchar(255) DEFAULT '' COMMENT '所属标签', `createdAt` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间戳', `updatedAt` int(10) unsigned DEFAULT '0' COMMENT '更新时间戳', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8; -- ---------------------------- -- Records of `lesson` -- ---------------------------- BEGIN; INSERT INTO `lesson` VALUES ('1', '1', '高中一年级语文', '高一语文', '0', '0'), ('2', '1', '高中二年级语文', '高二语文', '0', '0'), ('3', '1', '高中三年级语文', '高三语文', '0', '0'), ('4', '0', '高中一年级数学', '高一数学', '0', '0'), ('5', '0', '高中二年级数学', '高二数学', '0', '0'), ('6', '0', '高中三年级数学', '高三数学', '0', '0'), ('7', '3', '高中一年级英语', '高一英语', '0', '0'), ('8', '3', '高中二年级英语', '高二英语', '0', '0'), ('9', '3', '高中三年级英语', '高三英语', '0', '0'), ('10', '0', '高中一年级历史', '高一历史', '0', '0'), ('11', '0', '高中二年级历史', '高二历史', '0', '0'), ('12', '0', '高中三年级历史', '高三历史', '0', '0'), ('13', '5', '高中一年级政治', '高一政治', '0', '0'), ('14', '5', '高中二年级政治', '高二政治', '0', '0'), ('15', '5', '高中三年级政治', '高三政治', '0', '0'), ('16', '0', '高中一年级地理', '高一地理', '0', '0'), ('17', '0', '高中二年级地理', '高二地理', '0', '0'), ('18', '0', '高中三年级地理', '高三地理', '0', '0'), ('19', '7', '高中一年级物理', '高一物理', '0', '0'), ('20', '7', '高中二年级物理', '高二物理', '0', '0'), ('21', '7', '高中三年级物理', '高三物理', '0', '0'), ('22', '0', '高中一年级化学', '高一化学', '0', '0'), ('23', '0', '高中二年级化学', '高二化学', '0', '0'), ('24', '0', '高中三年级化学', '高三化学', '0', '0'), ('25', '9', '高中一年级生物', '高一生物', '0', '0'), ('26', '9', '高中二年级生物', '高二生物', '0', '0'), ('27', '9', '高中三年级生物', '高三生物', '0', '0'), ('28', '0', '高中一年级体育', '高一体育', '0', '0'), ('29', '0', '高中二年级体育', '高二体育', '0', '0'), ('30', '0', '高中三年级体育', '高三体育', '0', '0'); COMMIT; SET FOREIGN_KEY_CHECKS = 1; ","date":"2018-01-20","objectID":"/posts/mysql-join-query/:1:0","tags":["MySQL"],"title":"MySQL 联合查询","uri":"/posts/mysql-join-query/"},{"categories":["MySQL"],"content":"连接查询 ","date":"2018-01-20","objectID":"/posts/mysql-join-query/:2:0","tags":["MySQL"],"title":"MySQL 联合查询","uri":"/posts/mysql-join-query/"},{"categories":["MySQL"],"content":"INNER JOIN - 内连接 SELECT a.`id` AS courseId, a.`title` AS courseTitle, a.`englishName`, b.`id` AS lessonId, b.`title` AS lessonTitle, b.`tags` FROM test.`course` AS a INNER JOIN test.`lesson` AS b ON a.`id` = b.`courseId`; ","date":"2018-01-20","objectID":"/posts/mysql-join-query/:2:1","tags":["MySQL"],"title":"MySQL 联合查询","uri":"/posts/mysql-join-query/"},{"categories":["MySQL"],"content":"OUTER JOIN - 外连接 MySQL 并不支持 FULL OUTER JOIN 语法。 SELECT a.`id` AS courseId, a.`title` AS courseTitle, a.`englishName`, b.`id` AS lessonId, b.`title` AS lessonTitle, b.`tags` FROM test.`course` AS a LEFT JOIN test.`lesson` AS b ON a.`id` = b.`courseId` UNION SELECT a.`id` AS courseId, a.`title` AS courseTitle, a.`englishName`, b.`id` AS lessonId, b.`title` AS lessonTitle, b.`tags` FROM test.`course` AS a RIGHT JOIN test.`lesson` AS b ON a.`id` = b.`courseId`; ","date":"2018-01-20","objectID":"/posts/mysql-join-query/:2:2","tags":["MySQL"],"title":"MySQL 联合查询","uri":"/posts/mysql-join-query/"},{"categories":["MySQL"],"content":"LEFT JOIN - 左连接 SELECT a.`id` AS courseId, a.`title` AS courseTitle, a.`englishName`, b.`id` AS lessonId, b.`title` AS lessonTitle, b.`tags` FROM test.`course` AS a LEFT JOIN test.`lesson` AS b ON a.`id` = b.`courseId`; ","date":"2018-01-20","objectID":"/posts/mysql-join-query/:2:3","tags":["MySQL"],"title":"MySQL 联合查询","uri":"/posts/mysql-join-query/"},{"categories":["MySQL"],"content":"RIGHT JOIN 右连接 SELECT a.`id` AS courseId, a.`title` AS courseTitle, a.`englishName`, b.`id` AS lessonId, b.`title` AS lessonTitle, b.`tags` FROM test.`course` AS a RIGHT JOIN test.`lesson` AS b ON a.`id` = b.`courseId`; ","date":"2018-01-20","objectID":"/posts/mysql-join-query/:2:4","tags":["MySQL"],"title":"MySQL 联合查询","uri":"/posts/mysql-join-query/"},{"categories":["MySQL"],"content":"LEFT JOIN EXCLUDING INNER JOIN SELECT a.`id` AS courseId, a.`title` AS courseTitle, a.`englishName`, b.`id` AS lessonId, b.`title` AS lessonTitle, b.`tags` FROM test.`course` AS a LEFT JOIN test.`lesson` AS b ON a.`id` = b.`courseId` WHERE b.`id` IS NULL; ","date":"2018-01-20","objectID":"/posts/mysql-join-query/:2:5","tags":["MySQL"],"title":"MySQL 联合查询","uri":"/posts/mysql-join-query/"},{"categories":["MySQL"],"content":"RIGHT JOIN EXCLUDING INNER JOIN SELECT a.`id` AS courseId, a.`title` AS courseTitle, a.`englishName`, b.`id` AS lessonId, b.`title` AS lessonTitle, b.`tags` FROM test.`course` AS a RIGHT JOIN test.`lesson` AS b ON a.`id` = b.`courseId` WHERE a.`id` IS NULL; ","date":"2018-01-20","objectID":"/posts/mysql-join-query/:2:6","tags":["MySQL"],"title":"MySQL 联合查询","uri":"/posts/mysql-join-query/"},{"categories":["MySQL"],"content":"OUTER JOIN EXCLUDING INNER JOIN SELECT a.`id` AS courseId, a.`title` AS courseTitle, a.`englishName`, b.`id` AS lessonId, b.`title` AS lessonTitle, b.`tags` FROM test.`course` AS a LEFT JOIN test.`lesson` AS b ON a.`id` = b.`courseId` WHERE b.`courseId` IS NULL UNION SELECT a.`id` AS courseId, a.`title` AS courseTitle, a.`englishName`, b.`id` AS lessonId, b.`title` AS lessonTitle, b.`tags` FROM test.`course` AS a RIGHT JOIN test.`lesson` AS b ON a.`id` = b.`courseId` WHERE a.`id` IS NULL; ","date":"2018-01-20","objectID":"/posts/mysql-join-query/:2:7","tags":["MySQL"],"title":"MySQL 联合查询","uri":"/posts/mysql-join-query/"},{"categories":["MySQL"],"content":"CROSS JOIN 笛卡尔积, 即 N * M 三种表示方法: CROSS JOIN, JOIN, , SELECT a.`id` AS courseId, a.`title` AS courseTitle, a.`englishName`, b.`id` AS lessonId, b.`title` AS lessonTitle, b.`tags` FROM test.`course` AS a CROSS JOIN test.`lesson` AS b; SELECT a.`id` AS courseId, a.`title` AS courseTitle, a.`englishName`, b.`id` AS lessonId, b.`title` AS lessonTitle, b.`tags` FROM test.`course` AS a JOIN test.`lesson` AS b; SELECT a.`id` AS courseId, a.`title` AS courseTitle, a.`englishName`, b.`id` AS lessonId, b.`title` AS lessonTitle, b.`tags` FROM test.`course` AS a, test.`lesson` AS b; ","date":"2018-01-20","objectID":"/posts/mysql-join-query/:2:8","tags":["MySQL"],"title":"MySQL 联合查询","uri":"/posts/mysql-join-query/"},{"categories":["MySQL"],"content":"在很多时候，我们并不会直接利用 MySQL 的 root 用户进行项目的开发，一般的，我们都会创建一个具有部分权限的用户。 MySQL 数据类型 MySQL 用户管理 MySQL 关键字查询 MySQL 字符串函数 MySQL 字符串连接函数 MySQL 忘记 root 密码后重置 MySQL 最值查询 MySQL 日期时间函数 MySQL 联合查询 MySQL 查询当前年、季、月、周的第一天和最后一天 MySQL 支持 Emoji 图标的设置 MySQL 存储引擎 MySQL 隔离级别及其脏读不可重复读幻读 ","date":"2018-01-20","objectID":"/posts/mysql-user-manager/:0:0","tags":["MySQL"],"title":"MySQL 用户管理","uri":"/posts/mysql-user-manager/"},{"categories":["MySQL"],"content":"创建用户 Adding User Accounts ","date":"2018-01-20","objectID":"/posts/mysql-user-manager/:1:0","tags":["MySQL"],"title":"MySQL 用户管理","uri":"/posts/mysql-user-manager/"},{"categories":["MySQL"],"content":"创建本地用户 CREATE USER 'developer'@'localhost' IDENTIFIED BY ']8Mgbs6m{4)z?DYJU8XA'; ","date":"2018-01-20","objectID":"/posts/mysql-user-manager/:1:1","tags":["MySQL"],"title":"MySQL 用户管理","uri":"/posts/mysql-user-manager/"},{"categories":["MySQL"],"content":"创建远程用户 // 从 192.168.10.10 / 192.168.10.11 登陆的用户 CREATE USER 'developer'@'192.168.10.10' IDENTIFIED BY ']8Mgbs6m{4)z?DYJU8XA'; CREATE USER 'developer'@'192.168.10.11' IDENTIFIED BY ']8Mgbs6m{4)z?DYJU8XA'; // 从任意 IP 登陆的用户 CREATE USER 'developer'@'%' IDENTIFIED BY ']8Mgbs6m{4)z?DYJU8XA'; // 不做指定默认为 '%' CREATE USER 'developer' IDENTIFIED BY ']8Mgbs6m{4)z?DYJU8XA'; 解决 Plugin sha256_password reported: ''sha256_password' is deprecated and will be removed in a future release 问题。如果从 MySQL-5.6 或 MySQL-5.7 升级到 MySQL-8.X 会引起这样的问题，MySQL-8.0 及更高版本引入了一种更安全的密码认证插件，名为 caching_sha2_password，现在已成为这些版本的默认选项。旧的认证插件 sha256_password 已被弃用，并计划在未来的 MySQL 发布中移除。因此设置密码时需要这样操作： -- 删除用户 DROP USER 'developer'@'%'; -- 修改密码 ALTER USER 'developer'@'%' IDENTIFIED WITH mysql_native_password BY ']8Mgbs6m{4)z?DYJU8XA'; -- 创建用户 CREATE USER 'developer'@'%' IDENTIFIED WITH caching_sha2_password BY 'yourpassword'; ","date":"2018-01-20","objectID":"/posts/mysql-user-manager/:1:2","tags":["MySQL"],"title":"MySQL 用户管理","uri":"/posts/mysql-user-manager/"},{"categories":["MySQL"],"content":"修改密码 -- 查询用户 SELECT User, Host, HEX(authentication_string) FROM mysql.user; -- 修改密码 ALTER user 'developer'@'localhost' IDENTIFIED BY ']8Mgbs6m{4)z?DYJU8XA'; -- 或者 UPDATE user SET authentication_string=PASSWORD(']8Mgbs6m{4)z?DYJU8XA'),password_expired='N' WHERE User='developer' AND Host='localhost'; -- 或者 SELECT PASSWORD('hello'); SET PASSWORD FOR 'developer'@'192.168.10.11'='*6B4F89A54E27ECDAD8DABT2SA901ASD1DB119X0SOPV29'; ","date":"2018-01-20","objectID":"/posts/mysql-user-manager/:2:0","tags":["MySQL"],"title":"MySQL 用户管理","uri":"/posts/mysql-user-manager/"},{"categories":["MySQL"],"content":"删除用户 DELETE FROM `user` WHERE `user`='developer' AND `host`='192.168.10.11'; -- 或者 DROP USER developer@'192.168.10.11'; FLUSH PRIVILEGES; ","date":"2018-01-20","objectID":"/posts/mysql-user-manager/:3:0","tags":["MySQL"],"title":"MySQL 用户管理","uri":"/posts/mysql-user-manager/"},{"categories":["MySQL"],"content":"修改用户账号 RENAME USER 'developer'@'192.168.10.11' TO 'inspector'@'192.168.10.11'; ","date":"2018-01-20","objectID":"/posts/mysql-user-manager/:4:0","tags":["MySQL"],"title":"MySQL 用户管理","uri":"/posts/mysql-user-manager/"},{"categories":["MySQL"],"content":"赋予用户权限 其中的 test.* 表示对 test 数据库的所有操作授予提供的权限。 -- 赋予部分权限 GRANT SELECT,DELETE,UPDATE,INSERT ON test.* TO 'developer'@'192.168.10.10'; -- 赋予所有权限 -- WITH GRANT OPTION 则表示 TO 子句所指定的所有用户都具有把自己所拥有的权限授予给其他用户的权利，而无论那些其他用户是否拥有该权限 GRANT ALL PRIVILEGES ON test.* TO 'developer'@'localhost' WITH GRANT OPTION; GRANT ALL PRIVILEGES ON test.* TO 'developer'@'%' WITH GRANT OPTION; -- 赋予权限的同时设置系统登录口令 GRANT ALL PRIVILEGES ON test.* TO 'hello'@'%' IDENTIFIED BY 'password', 'world'@'%' IDENTIFIED BY 'password'; ","date":"2018-01-20","objectID":"/posts/mysql-user-manager/:5:0","tags":["MySQL"],"title":"MySQL 用户管理","uri":"/posts/mysql-user-manager/"},{"categories":["MySQL"],"content":"查看用户权限 -- 查看本地 developer 的权限，没有指定后面的 localhost 则默认为 '%' SHOW GRANTS FOR 'developer'@'localhost'; -- 查看指定 host 的 developer 的权限 SHOW GRANTS FOR 'developer'@'192.168.10.10'; ","date":"2018-01-20","objectID":"/posts/mysql-user-manager/:6:0","tags":["MySQL"],"title":"MySQL 用户管理","uri":"/posts/mysql-user-manager/"},{"categories":["MySQL"],"content":"撤销用户权限 -- 撤销 INSERT 权限 REVOKE INSERT ON test.* FROM 'developer'@'192.168.10.10'; -- 撤销所有权限 REVOKE ALL ON test.* FROM 'developer'@'192.168.10.10'; ","date":"2018-01-20","objectID":"/posts/mysql-user-manager/:7:0","tags":["MySQL"],"title":"MySQL 用户管理","uri":"/posts/mysql-user-manager/"},{"categories":["MySQL"],"content":"MySQL 查询当前年份的第一天和最后一天、当前季度的第一天和最后一天、当前月份的第一天和最后一天、当前周的第一天和最后一天。 MySQL 数据类型 MySQL 用户管理 MySQL 关键字查询 MySQL 字符串函数 MySQL 字符串连接函数 MySQL 忘记 root 密码后重置 MySQL 最值查询 MySQL 日期时间函数 MySQL 联合查询 MySQL 查询当前年、季、月、周的第一天和最后一天 MySQL 支持 emoji 图标的设置 MySQL 存储引擎 MySQL 隔离级别及其脏读不可重复读幻读 ","date":"2018-01-20","objectID":"/posts/mysql-datatime-query/:0:0","tags":["MySQL"],"title":"MySQL 查询当前年、季、月、周的第一天和最后一天","uri":"/posts/mysql-datatime-query/"},{"categories":["MySQL"],"content":"年份 ","date":"2018-01-20","objectID":"/posts/mysql-datatime-query/:1:0","tags":["MySQL"],"title":"MySQL 查询当前年、季、月、周的第一天和最后一天","uri":"/posts/mysql-datatime-query/"},{"categories":["MySQL"],"content":"当前年份第一天 SELECT DATE_SUB(CURDATE(), INTERVAL DAYOFYEAR(NOW()) - 1 DAY) AS '当前年份的第一天'; ","date":"2018-01-20","objectID":"/posts/mysql-datatime-query/:1:1","tags":["MySQL"],"title":"MySQL 查询当前年、季、月、周的第一天和最后一天","uri":"/posts/mysql-datatime-query/"},{"categories":["MySQL"],"content":"当前年份最后一天 SELECT CONCAT(YEAR(NOW()), '-12-31') AS '当前年份的最后一天'; ","date":"2018-01-20","objectID":"/posts/mysql-datatime-query/:1:2","tags":["MySQL"],"title":"MySQL 查询当前年、季、月、周的第一天和最后一天","uri":"/posts/mysql-datatime-query/"},{"categories":["MySQL"],"content":"季度 ","date":"2018-01-20","objectID":"/posts/mysql-datatime-query/:2:0","tags":["MySQL"],"title":"MySQL 查询当前年、季、月、周的第一天和最后一天","uri":"/posts/mysql-datatime-query/"},{"categories":["MySQL"],"content":"当前季度第一天 SELECT MAKEDATE(YEAR(CURDATE()), 1) + INTERVAL QUARTER(CURDATE()) QUARTER - INTERVAL 1 QUARTER - INTERVAL +1 MONTH AS '当前季度的第一天'; ","date":"2018-01-20","objectID":"/posts/mysql-datatime-query/:2:1","tags":["MySQL"],"title":"MySQL 查询当前年、季、月、周的第一天和最后一天","uri":"/posts/mysql-datatime-query/"},{"categories":["MySQL"],"content":"当前季度最后一天 SELECT LAST_DAY(MAKEDATE(EXTRACT(YEAR FROM CURDATE()), 1) + INTERVAL QUARTER(CURDATE()) * 3 - 1 MONTH) AS '当前季度的最后一天'; ","date":"2018-01-20","objectID":"/posts/mysql-datatime-query/:2:2","tags":["MySQL"],"title":"MySQL 查询当前年、季、月、周的第一天和最后一天","uri":"/posts/mysql-datatime-query/"},{"categories":["MySQL"],"content":"当前月份 ","date":"2018-01-20","objectID":"/posts/mysql-datatime-query/:3:0","tags":["MySQL"],"title":"MySQL 查询当前年、季、月、周的第一天和最后一天","uri":"/posts/mysql-datatime-query/"},{"categories":["MySQL"],"content":"当前月份的第一天 SELECT DATE_SUB(CURDATE(), INTERVAL DAYOFMONTH(NOW()) - 1 DAY) AS '当前月份的第一天'; ","date":"2018-01-20","objectID":"/posts/mysql-datatime-query/:3:1","tags":["MySQL"],"title":"MySQL 查询当前年、季、月、周的第一天和最后一天","uri":"/posts/mysql-datatime-query/"},{"categories":["MySQL"],"content":"当前月份的最后一天 SELECT LAST_DAY(NOW()) AS '当前月份的最后一天'; ","date":"2018-01-20","objectID":"/posts/mysql-datatime-query/:3:2","tags":["MySQL"],"title":"MySQL 查询当前年、季、月、周的第一天和最后一天","uri":"/posts/mysql-datatime-query/"},{"categories":["MySQL"],"content":"当前周 ","date":"2018-01-20","objectID":"/posts/mysql-datatime-query/:4:0","tags":["MySQL"],"title":"MySQL 查询当前年、季、月、周的第一天和最后一天","uri":"/posts/mysql-datatime-query/"},{"categories":["MySQL"],"content":"当前周的第一天 SELECT DATE_SUB(CURDATE(), INTERVAL WEEKDAY(CURDATE()) + 0 DAY) AS '当前周的第一天'; ","date":"2018-01-20","objectID":"/posts/mysql-datatime-query/:4:1","tags":["MySQL"],"title":"MySQL 查询当前年、季、月、周的第一天和最后一天","uri":"/posts/mysql-datatime-query/"},{"categories":["MySQL"],"content":"当前周的最后一天 SELECT DATE_SUB(CURDATE(), INTERVAL WEEKDAY(CURDATE()) - 6 DAY) AS '当前周的最后一天'; ","date":"2018-01-20","objectID":"/posts/mysql-datatime-query/:4:2","tags":["MySQL"],"title":"MySQL 查询当前年、季、月、周的第一天和最后一天","uri":"/posts/mysql-datatime-query/"},{"categories":["MySQL"],"content":"整理一下我曾有所耳闻的 MySQL 日期和时间函数。 MySQL 数据类型 MySQL 用户管理 MySQL 关键字查询 MySQL 字符串函数 MySQL 字符串连接函数 MySQL 忘记 root 密码后重置 MySQL 最值查询 MySQL 日期时间函数 MySQL 联合查询 MySQL 查询当前年、季、月、周的第一天和最后一天 MySQL 支持 emoji 图标的设置 MySQL 存储引擎 MySQL 隔离级别及其脏读不可重复读幻读 ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:0:0","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"常用日期时间函数 名称 描述 备注 ADDDATE() 添加日期 ADDTIME() 添加时间 CONVERT_TZ() 转换不同时区 CURDATE() 返回当前日期 CURRENT_DATE() 和 CURRENT_DATE 等同于 CURDATE() CURRENT_TIME() 和 CURRENT_TIME 等同于 CURTIME() CURRENT_TIMESTAMP() 和 CURRENT_TIMESTAMP 等同于 NOW() CURTIME() 返回当前时间 DATE_ADD() 添加两个日期 DATE_FORMAT() 按指定方式格式化日期 DATE_SUB() 求解两个日期的间隔 DATE() 提取日期或日期时间表达式中的日期部分 DATEDIFF() 求解两个日期的间隔 DAY() 等同于 DAYOFMONTH() DAYNAME() 返回星期中某天的名称 DAYOFMONTH() 返回一月中某天的序号(1-31) DAYOFWEEK() 返回参数所指定的一周中某天的索引值 DAYOFYEAR() 返回一年中某天的序号(1-366) EXTRACT 提取日期中的相应部分 FROM_DAYS() 将一个天数序号转变为日期值 FROM_UNIXTIME() 将日期格式化为 UNIX 的时间戳 HOUR() 提取时间 LAST_DAY 根据参数, 返回月中最后一天 LOCALTIME() 和 LOCALTIME 等同于 NOW() LOCALTIMESTAMP 和 LOCALTIMESTAMP() 等同于 NOW() MAKEDATE() 基于给定参数年份和所在年中的天数序号, 返回一个日期 MAKETIME 根据给定小时, 分, 秒返回一个格式时间 MICROSECOND() 返回参数所对应的毫秒数 MINUTE() 返回参数对应的分钟数 MONTH() 返回传入日期所对应的月序数 MONTHNAME() 返回月的名称 NOW() 返回当前日期与时间 PERIOD_ADD() 为年-月组合日期添加一个时段 PERIOD_DIFF() 返回两个时段之间的月份差值 QUARTER() 返回日期参数所对应的季度序号 SEC_TO_TIME() 将描述转变成 HH:MM:SS 的格式 SECOND() 返回秒序号(0-59 STR_TO_DATE() 将字符串转变为日期 SUBDATE() 从给定的日期中减去一个时间区间, 相当于 DATE_SUB() SUBTIME() 计算时间差值 SYSDATE() 返回函数执行时的时间 TIME_FORMAT() 提取参数中的时间部分 TIME_TO_SEC() 将参数转化为秒数 TIME() 提取传入表达式的时间部分 TIMEDIFF() 计算时间差值 TIMESTAMP() 单个参数时, 函数返回日期或日期时间表达式; 有 2 个参数时, 将参数求和 TIMESTAMPADD() 为日期时间表达式添加一个间隔 INTERVAL TIMESTAMPDIFF() 从日期时间表达式中减去一个间隔 INTERVAL TO_DAYS() 返回转换成天数的日期参数 UNIX_TIMESTAMP() 返回一个 UNIX 时间戳 UTC_DATE() 返回当前的 UTC 日期 UTC_TIME() 返回当前的 UTC 时间 UTC_TIMESTAMP() 返回当前的 UTC 时间与日期 WEEK() 返回周序号 WEEKDAY() 返回某天在星期中的索引值 WEEKOFYEAR() 返回日期所对应的星期在一年当中的序号(1-53) YEAR() 返回年份 YEARWEEK() 返回年份及星期序号 ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:1:0","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"日期时间函数用法 ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:0","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"DATE_ADD() 函数 SELECT DATE_ADD('2017-11-11', INTERVAL 31 DAY); SELECT ADDDATE('2017-11-11', INTERVAL 31 DAY); SELECT ADDDATE('2017-11-11', 31); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:1","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"ADDTIME() 函数 SELECT ADDTIME('2017-12-31 23:59:59.999999', '0 0:0:0.000001'); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:2","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"CONVERT_TZ() 函数 Unable to load timezones? MySQL Server Time Zone Support // 导入时区数据 $ mysql_tzinfo_to_sql /usr/share/zoneinfo | mysql -uroot -p -S /usr/local/var/run/mysql/mysql.sock --force mysql // 设置全局时区 SET GLOBAL time_zone = 'Asia/Shanghai'; // 查看系统时区 SELECT @@global.time_zone, @@session.time_zone; // 时区相关的表 SELECT * FROM mysql.time_zone; SELECT * FROM mysql.time_zone_transition_type; SELECT * FROM mysql.time_zone_transition; SELECT * FROM mysql.time_zone_name; SELECT * FROM mysql.time_zone_leap_second; SELECT CONVERT_TZ(NOW(), 'Asia/Shanghai', 'GMT'); SELECT CONVERT_TZ(NOW(), '+08:00', '+00:00'); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:3","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"CURRENT_DATE(), CURRENT_DATE 函数 SELECT CURRENT_DATE(); SELECT CURRENT_DATE() + 0; SELECT CURRENT_DATE; SELECT CURRENT_DATE + 0; ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:4","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"CURRENT_TIME(), CURRENT_TIME 函数 SELECT CURRENT_TIME(); SELECT CURRENT_TIME() + 0; SELECT CURRENT_TIME; SELECT CURRENT_TIME + 0; ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:5","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"NOW(), CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP, LOCALTIMESTAMP(), LOCALTIMESTAMP, LOCALTIME(), LOCALTIME 函数 SELECT NOW(); SELECT CURRENT_TIMESTAMP(); SELECT CURRENT_TIMESTAMP; SELECT LOCALTIMESTAMP(); SELECT LOCALTIMESTAMP; SELECT LOCALTIME(); SELECT LOCALTIME; ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:6","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"DATE_ADD() 函数 SELECT DATE_ADD(CURRENT_DATE(), INTERVAL +1 YEAR); SELECT DATE_ADD(CURRENT_DATE(), INTERVAL +1 QUARTER); SELECT DATE_ADD(CURRENT_DATE(), INTERVAL +1 MONTH); SELECT DATE_ADD(CURRENT_DATE(), INTERVAL +1 DAY); SELECT DATE_ADD(CURRENT_TIME(), INTERVAL +1 HOUR); SELECT DATE_ADD(CURRENT_TIME(), INTERVAL +1 MINUTE); SELECT DATE_ADD(CURRENT_TIME(), INTERVAL +60 SECOND); SELECT DATE_ADD(CURRENT_TIME(), INTERVAL +5000 MICROSECOND); SELECT DATE_ADD(NOW(), INTERVAL +1 YEAR); SELECT DATE_ADD(NOW(), INTERVAL +1 MONTH); SELECT DATE_ADD(NOW(), INTERVAL +1 WEEK); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:7","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"DATE_FORMAT(), STR_TO_DATE() 函数 名称 描述 备注 %a 一星期中每天名称的缩写(Sun…Sat) %b 月份的缩写(Jan…Dec) %c 月份的数字表现形式(0…12) %D 带有英语后缀的一个月中的每一天的名称(0th、1st、2nd、3rd) %d 用数字形式表现的每月中的每一天(00…31) %e 用数字形式表现的每月中的每一天(0…31) %f 毫秒(000000…999999) %H 24 时制显示的小时(00…23) %h 12 时制显示的小时(01…12) %I 12 时制显示的小时(01…12) %i 以数字形式表现的分钟数(00…59) %j 一年中的每一天(001…366) %k 24 时制小时的另一种表现格式(0…23) %l 12 时制小时的另一种表现格式(1…12) %M 用完整英文名称表示的月份(January…December) %m 用数字表现的月份(00…12) %p 上午(AM)或下午(PM) %r 12 时制的时间值(hh:mm:ss, 后跟 AM 或 PM) %S 秒(00…59) %s 秒(00…59) %T 24 时制的小时(hh:mm:ss) %U 星期(00…53), 其中星期天是每星期的开始日 %u 星期(00…53), 其中星期一是每星期的开始日 %V 星期(01…53), 其中星期天是每星期的开始日, 和 %X 一起使用 %v 星期(01…53), 其中星期一是每星期的开始日, 和 %x 一起使用 %W 一星期中各日名称(Sunday…Saturday) %w 一星期中各日名称(0 代表星期日, 6 代表星期六, 以此类推) %X 某星期所处年份. 其中, 星期天是每星期的开始日, 采用 4 位数字形式表现, 和 %V一起使用 %x 某星期所处年份. 其中, 星期一是每星期的开始日, 采用 4 位数字形式表现, 和 %V 一起使用 %Y 4 位数字表示的年份 %y 2 位数字表示的年份 %% 符号 % 的字面值 %x(x为斜体) 字符 x 的字面值, x 指以上未列出的任何字符 SELECT DATE_FORMAT(NOW(), '%Y年-%m月-%d号 %p %H时%i分%s秒'); SELECT DATE_FORMAT(NOW(), '%Y %M %D %p %H:%m:%s %W %u %j'); SELECT STR_TO_DATE('February 1 2018', '%M %d %Y'); SELECT STR_TO_DATE('March,8,2018', '%M,%e,%Y'); SELECT STR_TO_DATE('Friday, July 28, 2018', '%W, %M %e, %Y'); SELECT STR_TO_DATE('2018,10,1 9', '%Y,%m,%d %h'); SELECT STR_TO_DATE('2018,6,2 21,30,01', '%Y,%m,%d %H,%i,%s'); SELECT STR_TO_DATE('16,3,33', '%H,%i,%s'); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:8","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"DATE_SUB(), SUBDATE() 函数 SELECT DATE_SUB(CURRENT_DATE(), INTERVAL +1 YEAR); SELECT DATE_SUB(CURRENT_DATE(), INTERVAL +1 QUARTER); SELECT DATE_SUB(CURRENT_DATE(), INTERVAL +1 MONTH); SELECT DATE_SUB(CURRENT_DATE(), INTERVAL +1 DAY); SELECT DATE_SUB(CURRENT_TIME(), INTERVAL +1 HOUR); SELECT DATE_SUB(CURRENT_TIME(), INTERVAL +1 MINUTE); SELECT DATE_SUB(CURRENT_TIME(), INTERVAL +60 SECOND); SELECT DATE_SUB(CURRENT_TIME(), INTERVAL +5000 MICROSECOND); SELECT DATE_SUB(NOW(), INTERVAL +1 YEAR); SELECT DATE_SUB(NOW(), INTERVAL +1 MONTH); SELECT DATE_SUB(NOW(), INTERVAL +1 WEEK); SELECT SUBDATE(CURRENT_TIMESTAMP(6), INTERVAL 4 MICROSECOND); SELECT SUBDATE(NOW(), INTERVAL 60 SECOND); SELECT SUBDATE(LOCALTIMESTAMP(), INTERVAL 30 MINUTE); SELECT SUBDATE(LOCALTIME(), INTERVAL 2 HOUR); SELECT SUBDATE(CURDATE(), INTERVAL 10 DAY); SELECT SUBDATE(CURRENT_DATE(), 10); SELECT SUBDATE(CURRENT_DATE(), INTERVAL 4 WEEK); SELECT SUBDATE(CURRENT_DATE(), INTERVAL 3 MONTH); SELECT SUBDATE(CURRENT_DATE(), INTERVAL 2 QUARTER); SELECT SUBDATE(CURRENT_DATE(), INTERVAL 1 YEAR); SELECT SUBDATE('2019-01-01 00:00:10.000001', INTERVAL '10.000001' SECOND_MICROSECOND); SELECT SUBDATE('2019-01-01 00:02:10.000001', INTERVAL '2:10.000001' MINUTE_MICROSECOND); SELECT SUBDATE(NOW(), INTERVAL '3:30' MINUTE_SECOND); SELECT SUBDATE('2019-01-01 01:03:10.000001', INTERVAL '1:03:10.000001' HOUR_MICROSECOND); SELECT SUBDATE(NOW(), INTERVAL '1:30:30' HOUR_SECOND); SELECT SUBDATE(NOW(), INTERVAL '1:01' HOUR_MINUTE); SELECT SUBDATE('2019-01-01 00:02:10.000001', INTERVAL '10 1:03:12.000001' DAY_MICROSECOND); SELECT SUBDATE(NOW(), INTERVAL '7 1:30:30' DAY_SECOND); SELECT SUBDATE(CURRENT_TIMESTAMP(), INTERVAL '7 1:30' DAY_MINUTE); SELECT SUBDATE(LOCALTIME(), INTERVAL '7 1' DAY_HOUR); SELECT SUBDATE(CURDATE(), INTERVAL '5-3' YEAR_MONTH); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:9","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"DATEDIFF() 函数 SELECT DATEDIFF(DATE_ADD(CURDATE(), INTERVAL + 1 DAY), CURDATE()); SELECT DATEDIFF(DATE_ADD(CURRENT_DATE(), INTERVAL + 1 DAY), CURRENT_DATE()); SELECT DATEDIFF(DATE_ADD(CURTIME(), INTERVAL + 1 DAY), CURTIME()); SELECT DATEDIFF(DATE_ADD(CURRENT_TIME(), INTERVAL + 1 DAY), CURRENT_TIME()); SELECT DATEDIFF(CURDATE(), DATE_SUB(CURRENT_DATE(), INTERVAL +1 DAY)); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:10","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"DAY(), DAYOFMONTH() 函数 SELECT DAY(CURRENT_DATE()); SELECT DAY(CURRENT_TIME()); SELECT DAY(NOW()); SELECT DAY('2016-12-31 23:59:59'); SELECT DAYOFMONTH(CURRENT_DATE()); SELECT DAYOFMONTH(CURRENT_TIME()); SELECT DAYOFMONTH(NOW()); SELECT DAYOFMONTH('2016-12-31 23:59:59'); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:11","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"DAYNAME() 函数 SELECT DAYNAME(CURDATE()); SELECT DAYNAME(CURRENT_DATE()); SELECT DAYNAME(CURTIME()); SELECT DAYNAME(CURRENT_TIME()); SELECT DAYNAME(CURRENT_TIMESTAMP()); SELECT DAYNAME(NOW()); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:12","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"DAYOFWEEK() 函数 SELECT DAYOFWEEK(CURDATE()); SELECT DAYOFWEEK(CURRENT_DATE()); SELECT DAYOFWEEK(NOW()); SELECT DAYOFWEEK(LOCALTIMESTAMP()); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:13","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"DAYOFYEAR() 函数 SELECT DAYOFYEAR(CURDATE()); SELECT DAYOFYEAR(CURRENT_DATE()); SELECT DAYOFYEAR(NOW()); SELECT DAYOFYEAR(LOCALTIMESTAMP()); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:14","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"EXTRACT() 函数 SELECT EXTRACT(MICROSECOND FROM CURRENT_TIMESTAMP(6)); SELECT EXTRACT(SECOND FROM CURRENT_TIMESTAMP(6)); SELECT EXTRACT(MINUTE FROM CURRENT_TIMESTAMP(6)); SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP(6)); SELECT EXTRACT(DAY FROM CURRENT_TIMESTAMP(6)); SELECT EXTRACT(WEEK FROM CURRENT_TIMESTAMP(6)); SELECT EXTRACT(MONTH FROM CURRENT_TIMESTAMP(6)); SELECT EXTRACT(QUARTER FROM CURRENT_TIMESTAMP(6)); SELECT EXTRACT(YEAR FROM CURRENT_TIMESTAMP(6)); SELECT EXTRACT(SECOND_MICROSECOND FROM CURRENT_TIMESTAMP(6)); SELECT EXTRACT(MINUTE_MICROSECOND FROM CURRENT_TIMESTAMP(6)); SELECT EXTRACT(MINUTE_SECOND FROM CURRENT_TIMESTAMP(6)); SELECT EXTRACT(HOUR_MICROSECOND FROM CURRENT_TIMESTAMP(6)); SELECT EXTRACT(HOUR_SECOND FROM CURRENT_TIMESTAMP(6)); SELECT EXTRACT(HOUR_MINUTE FROM CURRENT_TIMESTAMP(6)); SELECT EXTRACT(DAY_MICROSECOND FROM CURRENT_TIMESTAMP(6)); SELECT EXTRACT(DAY_SECOND FROM CURRENT_TIMESTAMP(6)); SELECT EXTRACT(DAY_MINUTE FROM CURRENT_TIMESTAMP(6)); SELECT EXTRACT(DAY_HOUR FROM CURRENT_TIMESTAMP(6)); SELECT EXTRACT(YEAR_MONTH FROM CURRENT_TIMESTAMP(6)); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:15","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"FROM_DAYS() 函数 SELECT FROM_DAYS('736644'); SELECT FROM_DAYS('737009'); SELECT FROM_DAYS('737374'); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:16","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"HOUR() 函数 SELECT HOUR(CURTIME()); SELECT HOUR(CURRENT_TIME()); SELECT HOUR(CURRENT_TIMESTAMP()); SELECT HOUR(NOW()); SELECT HOUR(LOCALTIMESTAMP()); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:17","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"LAST_DAY() 函数 SELECT LAST_DAY(CURDATE()); SELECT LAST_DAY(DATE_SUB(CURDATE(), INTERVAL +1 YEAR)); SELECT LAST_DAY(DATE_ADD(CURDATE(), INTERVAL +1 QUARTER)); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:18","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"MAKEDATE() 函数 SET @YEAR = '2018'; SELECT MAKEDATE(@YEAR, 1); SELECT MAKEDATE(@YEAR, 100); SELECT MAKEDATE(@YEAR, 200); SELECT MAKEDATE(@YEAR, 365); SELECT MAKEDATE(@YEAR, 366); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:19","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"MAKETIME() 函数 SELECT MAKETIME(11, 8, 1); SELECT MAKETIME(16, 59, 0); SELECT MAKETIME(23, 59, 59); SELECT MAKETIME(2017, 59, 59); SELECT MAKETIME(-2017, 59, 59); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:20","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"MICROSECOND() 函数 SELECT MICROSECOND(CURRENT_TIMESTAMP(6)); SELECT MICROSECOND('2018-12-31 23:59:59.000001'); SELECT MICROSECOND('2018-12-31 23:59:59.999999'); SELECT MICROSECOND(CURRENT_DATE()); SELECT MICROSECOND('12:59:59.141592'); SELECT MICROSECOND('838:58:59.001234'); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:21","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"MINUTE() 函数 SELECT MINUTE(CURTIME()); SELECT MINUTE(CURRENT_TIME()); SELECT MINUTE(CURRENT_TIMESTAMP(6)); SELECT MINUTE(NOW()); SELECT MINUTE('2018:59:59.001234'); SELECT MINUTE(LOCALTIME()); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:22","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"MONTH() 函数 SELECT MONTH(CURDATE()); SELECT MONTH(CURRENT_DATE()); SELECT MONTH(CURRENT_TIMESTAMP(6)); SELECT MONTH(LOCALTIMESTAMP()); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:23","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"MONTHNAME() 函数 SELECT MONTHNAME(CURDATE()); SELECT MONTHNAME(CURRENT_DATE()); SELECT MONTHNAME(CURRENT_TIMESTAMP()); SELECT MONTHNAME(LOCALTIMESTAMP()); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:24","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"PERIOD_ADD() 函数 SET @YEAR = '201806'; SELECT PERIOD_ADD(@YEAR, 2); SELECT PERIOD_ADD(@YEAR, 7); SELECT PERIOD_ADD(@YEAR, -7); SELECT PERIOD_ADD('1806', 7); SELECT PERIOD_ADD('1806', -7); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:25","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"PERIOD_DIFF() 函数 SELECT PERIOD_DIFF(201806, 201804); SELECT PERIOD_DIFF(201806, 201812); SELECT PERIOD_DIFF(1806, 1812); SELECT PERIOD_DIFF(1806, 200812); SELECT PERIOD_DIFF(201806, 0812); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:26","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"QUARTER() 函数 SELECT QUARTER(CURDATE()); SELECT QUARTER(CURRENT_DATE()); SELECT QUARTER(CURRENT_TIMESTAMP()); SELECT QUARTER(NOW()); SELECT QUARTER(LOCALTIME()); SELECT QUARTER(LOCALTIMESTAMP()); SELECT QUARTER(DATE_ADD(CURRENT_DATE(), INTERVAL +6 MONTH)); SELECT QUARTER(DATE_SUB(CURRENT_DATE(), INTERVAL -3 MONTH)); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:27","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"SECOND() 函数 SELECT SECOND(CURTIME()); SELECT SECOND(CURRENT_TIME()); SELECT SECOND(CURRENT_TIMESTAMP()); SELECT SECOND(NOW()); SELECT SECOND(LOCALTIME()); SELECT SECOND(LOCALTIMESTAMP()); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:28","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"SEC_TO_TIME() 函数 SELECT SEC_TO_TIME(1); SELECT SEC_TO_TIME(2); SELECT SEC_TO_TIME(3600); SELECT SEC_TO_TIME(360000); SELECT SEC_TO_TIME(5000); SELECT SEC_TO_TIME(-5000); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:29","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"SECOND() 函数 SELECT SECOND(CURTIME()); SELECT SECOND(CURRENT_TIME()); SELECT SECOND(CURRENT_TIMESTAMP(6)); SELECT SECOND(NOW()); SELECT SECOND('3600:11:59'); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:30","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"SUBTIME() 函数 SELECT SUBTIME('2019-01-01 00:00:10.000001', '2.000001'); SELECT SUBTIME('2019-01-01 00:00:10.000001', '3:2.000001'); SELECT SUBTIME('2019-01-01 00:00:10.000001', '4:3:2.000001'); SELECT SUBTIME('2019-01-01 00:00:10.000001', '5 4:3:2.000001'); SELECT SUBTIME('12:59:59.999999', '0.000001'); SELECT SUBTIME('01:01:01.999998', '5.000001'); SELECT SUBTIME('01:01:01.000001', '8:01:01.003441'); SELECT SUBTIME('01:02:03.000001', '-8:01:01.003441'); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:31","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"SYSDATE() 函数 SELECT SYSDATE(); SELECT SYSDATE() + 0; SELECT SYSDATE() + 1; ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:32","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"TIME() 函数 SELECT TIME(LOCALTIMESTAMP(6)); SELECT TIME(NOW()); SELECT TIME(CURRENT_TIME()); SELECT TIME(NULL); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:33","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"TIME_FORMAT() 函数 名称 描述 备注 %f 毫秒(000000…999999) %H 24 时制显示的小时(00…23) %h 12 时制显示的小时(01…12) %I 12 时制显示的小时(01…12) %i 以数字形式表现的分钟数(00…59) %p 上午(AM)或下午(PM) %r 12 时制的时间值(hh:mm:ss, 后跟 AM 或 PM) %S 秒(00…59) %s 秒(00…59) %T 24 时制的小时(hh:mm:ss) SELECT TIME_FORMAT(CURTIME(), '%H %i %s'); SELECT TIME_FORMAT(CURRENT_TIME(), '%h:%i:%s %p'); SELECT TIME_FORMAT(CURRENT_TIME, '%h:%i %p'); SELECT TIME_FORMAT('18:50:30.000001', '%r'); SELECT TIME_FORMAT('18:50:30.000001', '%T'); SELECT TIME_FORMAT('18:50:30.000001', '%f'); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:34","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"TIME_TO_SEC() 函数 SELECT TIME_TO_SEC('00:00:01'); SELECT TIME_TO_SEC('00:00:01.999999'); SELECT TIME_TO_SEC('00:00:02'); SELECT TIME_TO_SEC(CURTIME()); SELECT TIME_TO_SEC(NOW()); SELECT TIME_TO_SEC('-1:00:00'); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:35","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"TIMEDIFF() 函数 SELECT TIMEDIFF(NOW(), SUBDATE(LOCALTIME(), INTERVAL 1 SECOND)); SELECT TIMEDIFF(CURTIME(), SUBTIME(CURTIME(), '1:00:00')); SELECT TIMEDIFF(SUBTIME(CURTIME(), '1:00:00'), CURTIME()); SELECT TIMEDIFF(NOW(), CURTIME()); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:36","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"TIMESTAMP() 函数 SELECT TIMESTAMP(CURDATE()); SELECT TIMESTAMP(CURDATE(), CURTIME()); SELECT TIMESTAMP(NOW(), '02:00:00'); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:37","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"TIMESTAMPADD() 函数 SELECT TIMESTAMPADD(SECOND, 3600, CURTIME()); SELECT TIMESTAMPADD(MINUTE, 60, CURTIME()); SELECT TIMESTAMPADD(HOUR, 1, CURTIME()); SELECT TIMESTAMPADD(DAY, 1, CURDATE()); SELECT TIMESTAMPADD(WEEK, 1, CURDATE()); SELECT TIMESTAMPADD(MONTH, 1, CURDATE()); SELECT TIMESTAMPADD(QUARTER, 1, CURDATE()); SELECT TIMESTAMPADD(YEAR, 1, CURDATE()); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:38","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"TIMESTAMPDIFF() 函数 SELECT TIMESTAMPDIFF(SECOND, CURDATE(), ADDDATE(CURDATE(), INTERVAL 3600 SECOND)); SELECT TIMESTAMPDIFF(MINUTE, CURDATE(), ADDDATE(CURDATE(), INTERVAL 60 MINUTE)); SELECT TIMESTAMPDIFF(HOUR, CURDATE(), ADDDATE(CURDATE(), INTERVAL 1 HOUR)); SELECT TIMESTAMPDIFF(DAY, CURDATE(), ADDDATE(CURDATE(), INTERVAL 1 DAY)); SELECT TIMESTAMPDIFF(WEEK, CURDATE(), ADDDATE(CURDATE(), INTERVAL 1 MONTH)); SELECT TIMESTAMPDIFF(MONTH, CURDATE(), ADDDATE(CURDATE(), INTERVAL 1 QUARTER)); SELECT TIMESTAMPDIFF(YEAR, CURDATE(), ADDDATE(CURDATE(), INTERVAL 1 YEAR)); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:39","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"TO_DAYS() 函数 SELECT TO_DAYS(CURDATE()); SELECT TO_DAYS('19-01-01'); SELECT TO_DAYS(NOW()); SELECT TO_DAYS('0000-01-01'); SELECT TO_DAYS('0000-00-00'); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:40","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"WEEK() 函数 SELECT WEEK(CURDATE()); SELECT WEEK(CURRENT_DATE()); SELECT WEEK(CURRENT_TIMESTAMP()); SELECT WEEK(NOW()); SELECT WEEK(LOCALTIME()); SELECT WEEK(LOCALTIMESTAMP()); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:41","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"WEEKDAY() 函数 SELECT WEEKDAY(CURDATE()); SELECT WEEKDAY(CURRENT_DATE()); SELECT WEEKDAY(CURRENT_TIMESTAMP()); SELECT WEEKDAY(NOW()); SELECT WEEKDAY(LOCALTIME()); SELECT WEEKDAY(LOCALTIMESTAMP()); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:42","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"WEEKOFYEAR() 函数 SELECT WEEKOFYEAR(CURDATE()); SELECT WEEKOFYEAR(CURRENT_DATE()); SELECT WEEKOFYEAR(CURRENT_TIMESTAMP()); SELECT WEEKOFYEAR(NOW()); SELECT WEEKOFYEAR(LOCALTIME()); SELECT WEEKOFYEAR(LOCALTIMESTAMP()); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:43","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"YEAR() 函数 SELECT YEAR(CURDATE()); SELECT YEAR(CURRENT_DATE()); SELECT YEAR(CURRENT_TIMESTAMP()); SELECT YEAR(NOW()); SELECT YEAR(LOCALTIME()); SELECT YEAR(LOCALTIMESTAMP()); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:44","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"YEARWEEK() 函数 SELECT YEARWEEK(CURDATE()); SELECT YEARWEEK(CURRENT_DATE()); SELECT YEARWEEK(CURRENT_TIMESTAMP()); SELECT YEARWEEK(NOW()); SELECT YEARWEEK(LOCALTIME()); SELECT YEARWEEK(LOCALTIMESTAMP()); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:45","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"UTC_DATE(), UTC_TIME(), UTC_TIMESTAMP() 函数 SELECT UTC_DATE(); SELECT UTC_TIME(); SELECT UTC_TIMESTAMP(); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:2:46","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"日期时间和时间戳转换 // 当前日期时间转换为时间戳 SELECT UNIX_TIMESTAMP(NOW()); // 时间戳转换为日期时间 SELECT FROM_UNIXTIME('1478793600'); ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:3:0","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"参考 Date/Time Functions MySQL Date and Time functions MySQL Date and Time Functions ","date":"2018-01-20","objectID":"/posts/mysql-datetime-functions/:4:0","tags":["MySQL"],"title":"MySQL 日期时间函数","uri":"/posts/mysql-datetime-functions/"},{"categories":["MySQL"],"content":"MySQL 关键字通过 LIKE 和正则查询。 MySQL 数据类型 MySQL 用户管理 MySQL 关键字查询 MySQL 字符串函数 MySQL 字符串连接函数 MySQL 忘记 root 密码后重置 MySQL 最值查询 MySQL 日期时间函数 MySQL 联合查询 MySQL 查询当前年、季、月、周的第一天和最后一天 MySQL 支持 emoji 图标的设置 MySQL 存储引擎 MySQL 隔离级别及其脏读不可重复读幻读 ","date":"2018-01-20","objectID":"/posts/mysql-keywords-query/:0:0","tags":["MySQL"],"title":"MySQL 关键字查询","uri":"/posts/mysql-keywords-query/"},{"categories":["MySQL"],"content":"数据准备 /* Navicat Premium Data Transfer Source Server : localhost Source Server Type : MySQL Source Server Version : 50714 Source Host : 127.0.0.1 Source Database : test Target Server Type : MySQL Target Server Version : 50714 File Encoding : utf-8 Date: 03/08/2017 22:41:15 PM */ SET NAMES utf8mb4; SET FOREIGN_KEY_CHECKS = 0; -- ---------------------------- -- Table structure for `test` -- ---------------------------- DROP TABLE IF EXISTS `test`; CREATE TABLE `test` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键 ID', `key` varchar(45) NOT NULL COMMENT '键名', `val` varchar(45) NOT NULL COMMENT '键值', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=38 DEFAULT CHARSET=utf8 COMMENT='测试表'; -- ---------------------------- -- Records of `test` -- ---------------------------- BEGIN; INSERT INTO `test` VALUES ('1', 'chenyulong', '56'), ('2', 'maxiaoming', '33'), ('3', 'huxiaofeng', '23'), ('4', 'huangyi', '38'), ('5', 'MAYUN', '58'), ('6', 'CHENLONG', '64'), ('7', 'HUZHEN', '27'), ('8', 'LeiXiaoFei', '32'), ('9', 'Sunli', '42'), ('10', 'sunhong', '30'), ('11', 'Maoyouming', '33'), ('12', 'Maming', '43'), ('13', 'HUANGyu', '38'), ('14', 'maJINren', '34'), ('15', 'Lixiao', '33'), ('16', 'LIXIAOLI', '49'), ('17', 'sunYU', '50'), ('18', 'Liaihua', '54'), ('19', 'huXIaoYang', '44'), ('20', 'chenxiaoXIAO', '34'), ('21', 'wangjun', '90%'), ('22', 'zhaoqian', '_mysql'), ('23', 'wangwu', '%88'), ('24', 'lixiang', 'mysql_'), ('25', 'lianxiang', '_php'), ('26', 'lianyue', 'php_'), ('27', 'houxiaojun', '80%'), ('28', 'suNxiaOhua', '_phper'), ('29', 'jieXiaoguo', 'mysqler_'), ('30', 'sunming', '%66'), ('31', 'yingzheng', '%888'), ('32', 'piaojinhui', '900%'), ('33', 'jinzhengnan', '800%'), ('34', 'quanzhilong', '%666'), ('35', 'zhangquan', '__php'), ('36', 'zhangyu', '__mysql'), ('37', 'liyifeng', 'mysqler__'); COMMIT; SET FOREIGN_KEY_CHECKS = 1; ","date":"2018-01-20","objectID":"/posts/mysql-keywords-query/:1:0","tags":["MySQL"],"title":"MySQL 关键字查询","uri":"/posts/mysql-keywords-query/"},{"categories":["MySQL"],"content":"匹配模式 SQL 的模式缺省是忽略大小写的。 ","date":"2018-01-20","objectID":"/posts/mysql-keywords-query/:2:0","tags":["MySQL"],"title":"MySQL 关键字查询","uri":"/posts/mysql-keywords-query/"},{"categories":["MySQL"],"content":"SQL 匹配模式 %: 表示任意个（包括 0 个）或多个字符，可匹配任意类型和长度的字符 _: 表示任意单个字符，匹配单个任意字符，它常用来限制表达式的字符长度语句 字符转义 // 查询以 90% 结尾的数据 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE TRUE AND a.`val` LIKE '%90/%' ESCAPE '/'; // 查询以 80 开头匹配任意字符串并以 % 结尾的数据 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE TRUE AND a.`val` LIKE '80%/%' ESCAPE '/'; // 查询以 %88 开头的数据 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE TRUE AND a.`val` LIKE '/%88%' ESCAPE '/'; // 查询以 _php 开头的数据 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE TRUE AND a.`val` LIKE '/_php%' ESCAPE '/'; ","date":"2018-01-20","objectID":"/posts/mysql-keywords-query/:2:1","tags":["MySQL"],"title":"MySQL 关键字查询","uri":"/posts/mysql-keywords-query/"},{"categories":["MySQL"],"content":"正则匹配模式 .: 匹配任意单个字符 ?: 匹配前面的子表达式 0 次或 1 次 +: 匹配前面的子表达式 1 次或多次 *: 匹配前面的子表达式 0 次或多次 ^: 表示匹配开始位置 $: 表示匹配结束位置 []: 表示一个集合 {}: 表示重复的次数 ","date":"2018-01-20","objectID":"/posts/mysql-keywords-query/:2:2","tags":["MySQL"],"title":"MySQL 关键字查询","uri":"/posts/mysql-keywords-query/"},{"categories":["MySQL"],"content":"查询实例 ","date":"2018-01-20","objectID":"/posts/mysql-keywords-query/:3:0","tags":["MySQL"],"title":"MySQL 关键字查询","uri":"/posts/mysql-keywords-query/"},{"categories":["MySQL"],"content":"查询以 ma 字符串开头的数据 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE TRUE AND a.`key` LIKE 'ma%'; SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE TRUE AND a.`key` REGEXP '^ma'; ","date":"2018-01-20","objectID":"/posts/mysql-keywords-query/:3:1","tags":["MySQL"],"title":"MySQL 关键字查询","uri":"/posts/mysql-keywords-query/"},{"categories":["MySQL"],"content":"查询以 ming 字符串结尾的数据 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE TRUE AND a.`key` LIKE '%ming'; SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE TRUE AND a.`key` REGEXP 'ming$'; ","date":"2018-01-20","objectID":"/posts/mysql-keywords-query/:3:2","tags":["MySQL"],"title":"MySQL 关键字查询","uri":"/posts/mysql-keywords-query/"},{"categories":["MySQL"],"content":"查询包含 xiao 字符串的数据 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE TRUE AND a.`key` LIKE '%xiao%'; SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE TRUE AND a.`key` REGEXP 'xiao'; ","date":"2018-01-20","objectID":"/posts/mysql-keywords-query/:3:3","tags":["MySQL"],"title":"MySQL 关键字查询","uri":"/posts/mysql-keywords-query/"},{"categories":["MySQL"],"content":"查询长度为 10, 中间包含 xiao 字符串的数据 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE TRUE AND a.`key` LIKE '___xiao___'; SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE TRUE AND a.`key` REGEXP '^[a-zA-Z]{3}xiao[a-zA-Z]{3}$'; ","date":"2018-01-20","objectID":"/posts/mysql-keywords-query/:3:4","tags":["MySQL"],"title":"MySQL 关键字查询","uri":"/posts/mysql-keywords-query/"},{"categories":["PHP"],"content":"收集整理了一些 PHP7 的新特性。 ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:0:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"标量类型声明 \u003c?php declare(strict_types = 1); function paramInt(int ...$value) { return array_sum($value); } function paramFloat(float ...$value) { return array_values($value); } function paramString(string ...$value) { return implode(',', $value); } function paramBool(bool ...$value) { return $value; } var_dump(paramInt(1, 2, 3)); var_dump(paramFloat(1.1, 2.2, 3.3)); var_dump(paramString('a', 'b', 'c')); var_dump(paramBool(true, false)); // 结果 int(6) array(3) { [0] =\u003e double(1.1) [1] =\u003e double(2.2) [2] =\u003e double(3.3) } string(5) \"a,b,c\" array(2) { [0] =\u003e bool(true) [1] =\u003e bool(false) } ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:1:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"返回值类型声明 \u003c?php declare(strict_types = 1); function returnInt(int ...$value) : int { return array_sum($value); } function returnFloat(float ...$value) : float { return array_sum($value); } function returnString(string ...$value) : string { return implode(',', $value); } function returnBool(bool $value) : bool { return $value ? true : false; } function returnArray(array ...$value) : array { return $value; } var_dump(returnInt(1, 2, 3)); var_dump(returnFloat(1.1, 2.2, 3.3)); var_dump(returnString('a', 'b', 'c')); var_dump(returnBool(true)); var_dump(returnArray(['hello'], ['world'], ['!'])); // 结果 int(6) double(6.6) string(5) \"a,b,c\" bool(true) array(3) { [0] =\u003e array(1) { [0] =\u003e string(5) \"hello\" } [1] =\u003e array(1) { [0] =\u003e string(5) \"world\" } [2] =\u003e array(1) { [0] =\u003e string(1) \"!\" } } ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:2:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"NULL 合并运算符 \u003c?php // 判断 UID 是否存在 $uid = isset($_REQUEST['uid']) ? $_REQUEST['uid'] : 'unknown'; // 上面的代码可以替换为如下代码 $uid = $_REQUEST['uid'] ?? 'unknown'; // 如果 SESSION 中不存在 UID，就取 REQUEST 中的 UID $uid = $_SESSION['uid'] ?? $_REQUEST['uid'] ?? 'unknown'; var_dump($uid); // 结果 string(7) \"unknown\" ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:3:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"太空飞船操作符 还有这种操作？当然有，且看如下实例。 \u003c?php // PHP7 之前 function compare($a, $b) { if ($a == $b) { return 0; } return ($a \u003e $b) ? 1 : -1; } $a = $b = [ 'e' =\u003e 70, 'd' =\u003e 10, 'b' =\u003e 80, 'a' =\u003e 20, 'c' =\u003e 90, ]; uasort($a, 'compare'); print_r($a); // 结果 Array ( [d] =\u003e 10 [a] =\u003e 20 [e] =\u003e 70 [b] =\u003e 80 [c] =\u003e 90 ) // PHP7 function after_compare($a, $b) { return $a \u003c=\u003e $b; } uksort($b, 'after_compare'); print_r($b); // 结果 Array ( [a] =\u003e 20 [b] =\u003e 80 [c] =\u003e 90 [d] =\u003e 10 [e] =\u003e 70 ) ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:4:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"通过 define() 定义常量数组 \u003c?php define('ROLES', [ 'ADMIN', 'MANAGER', 'USER', ]); var_dump(ROLES[0], ROLES[1], ROLES[2]); // 结果 string(5) \"ADMIN\" string(7) \"MANAGER\" string(4) \"USER\" ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:5:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"匿名类 \u003c?php interface Logger { public function log(string $msg); } class App { private $logger; public function setLogger(Logger $logger) { $this-\u003elogger = $logger; } public function getLogger() : Logger { return $this-\u003elogger; } } $app = new App(); $app-\u003esetLogger(new class implements Logger { public function log(string $msg) { return $msg; } }); var_dump($app-\u003egetLogger()-\u003elog('Hello World!')); // 结果 string(12) \"Hello World!\" ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:6:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"Unicode codepoint 转译语法 \u003c?php $😄 = '愉快高兴'; $🇨🇳 = '我的祖国'; $🌈 = '雨后彩虹'; $try = \"^_^ \\u{0050}\\u{0048}\\u{0050}\\u{0037} - \\u{1F64F}\"; $array = [$😄, $🇨🇳, $🌈, $try]; print_r($array); Array ( [0] =\u003e 愉快高兴 [1] =\u003e 我的祖国 [2] =\u003e 雨后彩虹 [3] =\u003e ^_^ PHP7 - 🙏 ) ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:7:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"Closure::call() \u003c?php class Object { private $name = 'Object Name'; } // PHP7 之前 $beforeName = function () { return $this-\u003ename; }; var_dump($beforeName-\u003ebindTo(new Object(), 'Object')()); // 结果 string(11) \"Object Name\" // PHP7 $afterName = function () { return $this-\u003ename; }; var_dump($afterName-\u003ecall(new Object())); // 结果 string(11) \"Object Name\" ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:8:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"为 unserialize() 提供过滤 特性旨在提供更安全的方式解包不可靠的数据。它通过白名单的方式来防止潜在的代码注入。 \u003c?php class Test { public $name = 'test'; protected $weight = 60; private $age; public function __construct() { $this-\u003eage = 18; } public function getAge() { return $this-\u003eage; } } $test = serialize(new Test()); // 允许解析 class $a = unserialize($test); // 将所有的对象都转换为 __PHP_Incomplete_Class 对象，不允许解析 class $b = unserialize($test, ['allowed_classes' =\u003e false]); // 将除 Test 之外的所有对象都转换为 __PHP_Incomplete_Class 对象，允许解析 class $c = unserialize($test, ['allowed_classes' =\u003e ['Test']]); // 默认情况下所有的类都是可接受的，等同于省略第二个参数，允许解析 class $d = unserialize($test, ['allowed_classes' =\u003e true]); print_r([ $a-\u003egetAge(), // $b-\u003egetAge(), // PHP Fatal error: main(): The script tried to execute a method or access a property of an incomplete object. $c-\u003egetAge(), $d-\u003egetAge(), ]); // 结果 Array ( [0] =\u003e 18 [1] =\u003e 18 [2] =\u003e 18 ) ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:9:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"IntlChar 需要 intl 扩展。 \u003c?php $array = [ '获取 UNICODE 版本' =\u003e IntlChar::UNICODE_VERSION, '获取字符名称' =\u003e IntlChar::charName('@'), '获取中括号匹配的闭合括号' =\u003e IntlChar::getBidiPairedBracket('['), '获取 A 字符的镜像字符' =\u003e IntlChar::charMirror('\u003c'), '判断 ? 是否有镜像字符' =\u003e IntlChar::isMirrored('?') ? 'OK' : 'NO', '获取 codepoint 表示的字符' =\u003e IntlChar::chr(65), ]; print_r($array); // 结果 Array ( [获取 UNICODE 版本] =\u003e 10.0 [获取字符名称] =\u003e COMMERCIAL AT [获取中括号匹配的闭合括号] =\u003e ] [获取 A 字符的镜像字符] =\u003e \u003e [判断 ? 是否有镜像字符] =\u003e NO [获取 codepoint 表示的字符] =\u003e A ) ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:10:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"预期 指示 默认值 可能的值 zend.assertions 1 1 - 生成并执行代码（开发模式）。2 - 生成代码，但在运行时跳过它。-1 - 不生成代码（生产模式） assert.exception 0 1 - 当断言失败时，抛出提供的异常作为异常，或者在示提供异常的情况下抛出新的 AssertionError 对象。0 - 如上所述使用或生成 Throwable，但只生成基于该对象的警告，而不是抛出它（与 PHP5 行为兼容） ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:11:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"zend.assertions 为 1 \u003c?php ini_set('zend.assertions', 1); class MyException extends AssertionError { } assert(true == false, new MyException('Some error message')); echo 'this is a test'; // 结果 PHP Warning: assert(): MyException: Some error message ... Warning: assert(): MyException: Some error message ... this is a test ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:11:1","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"zend.assertions 为 0 \u003c?php ini_set('zend.assertions', 0); class MyException extends AssertionError { } assert(true == false, new MyException('Some error message')); echo 'this is a test'; // 结果 this is a test ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:11:2","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"zend.assertions 为 -1 \u003c?php ini_set('zend.assertions', -1); class MyException extends AssertionError { } assert(true == false, new MyException('Some error message')); echo 'this is a test'; // 结果 PHP Warning: zend.assertions may be completely enabled or disabled only in php.ini ... PHP Warning: assert(): MyException: Some error message ... Warning: zend.assertions may be completely enabled or disabled only in php.ini ... Warning: assert(): MyException: Some error message ... this is a test ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:11:3","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"assert.exception 为 1 \u003c?php ini_set('assert.exception', 1); class MyException extends AssertionError { } assert(true == false, new MyException('Some error message')); echo 'this is a test'; // 结果 PHP Fatal error: Uncaught MyException: Some error message ... Fatal error: Uncaught MyException: Some error message ... MyException: Some error message ... 注意： this is a test 是没有输出的 ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:11:4","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"assert.exception 为 0 \u003c?php ini_set('assert.exception', 0); class MyException extends AssertionError { } assert(true == false, new MyException('Some error message')); echo 'this is a test'; // 结果 PHP Warning: assert(): MyException: Some error message ... Warning: assert(): MyException: Some error message ... this is a test 版本 描述 备注 7.2.0 当 assertion 被废弃时使用字符串。当 assert.active 和 zend.assertions 都设置为 1 时，它会发出 E_DEPRECATED 通知 7.0.0 assert() 现在是一个语言构造而不是一个函数。assertion 现在可以是一个表达式。第二个参数现在被解释为 exception（如果给出 Throwable 对象），或者 description 从 PHP 5.4.8 起支持 5.4.8 添加了 description 参数。description 现在也提供给 ASSERT_CALLBACK 模式下的回调函数作为第四个参数 ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:11:5","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"use 以组声明 \u003c?php // PHP7 之前的代码 use Some\\Classes\\ClassA; use Some\\Classes\\ClassB; use Some\\Classes\\ClassC as C; use function Some\\Functions\\funca; use function Some\\Functions\\funcb; use function Some\\Functions\\funcc; use const Some\\Consts\\ConstA; use const Some\\Consts\\ConstB; use const Some\\Consts\\ConstC; // PHP7 及之后的代码 use Some\\Classes\\{ClassA, ClassB, ClassC as C}; use function Some\\Functions\\{funca, funcb, funcc}; use const Some\\Functions\\{ConstA, ConstB, ConstC}; ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:12:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"生成器可以返回表达式 此特性基于 PHP 5.5 版本中引入的生成器特性构建的。 它允许在生成器函数中通过使用 return 语法来返回一个表达式（但是不允许返回引用值），可以通过调用 Generator::getReturn() 方法来获取生成器的返回值，但是这个方法只能在生成器完成产生工作以后调用一次。 \u003c?php $gen = (function () { yield 1; yield 2; return 3; })(); foreach ($gen as $value) { echo $value, PHP_EOL; } echo $gen::getReturn(), PHP_EOL; // 结果 1 2 3 ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:13:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"生成器委托 只需在最外层生成其中使用 yield from，就可以把一个生成器自动委派给其他的生成器，Traversable 对象或者 array。 \u003c?php function gen() { yield 1; yield 2; yield from other(); } function other() { yield 3; yield 4; } foreach (gen() as $value) { echo $value, PHP_EOL; } // 结果 1 2 3 4 ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:14:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"整数除法函数 intdiv() 整型值可以使用十进制、十六进制、八进制或二进制表示，前面可以加上可选的符号（- 或者 +）。其中，二进制表达的 integer 自 PHP 5.4.0 起可用；要使用八进制表达，数字前必须加上 0（零）；要使用十六进制表达，数字前必须加上 0x；要使用二进制表达，数字前必须加上 0b \u003c?php $value = intdiv(1000, 33); var_dump($value); // 结果 int(30) ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:15:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"会话选项 在调用 session_start() 的时候， 传入的选项参数中也支持 session.lazy_write 行为， 默认情况下这个配置项是打开的。它的作用是控制 PHP 只有在会话中的数据发生变化的时候才写入会话存储文件，如果会话中的数据没有发生改变，那么 PHP 会在读取完会话数据之后，立即关闭会话存储文件，不做任何修改，可以通过设置 read_and_close 来实现。 \u003c?php session_start([ 'cache_limiter' =\u003e 'private', 'read_and_close' =\u003e true, ]); var_dump(ini_get('session.cache_limiter')); // 结果 string(7) \"private\" ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:16:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"执行一个正则表达式搜索并且使用一个回调进行替换 \u003c?php // 将字符串中的年份增加一年 $text = \"Fools day is 04/01/2017\\nChristmas day was 12/24/2017\\n\"; echo preg_replace_callback( \"|(\\d{2}/\\d{2}/)(\\d{4})|\", function ($match) { return $match[1] . ($match[2] + 1); }, $text ); echo PHP_EOL; echo preg_replace_callback_array( [ '|(\\d{2}/\\d{2}/)(\\d{4})|' =\u003e function ($match) { return $match[1] . ($match[2] + 1); } ], $text ); // 结果 Fools day is 04/01/2018 Christmas day was 12/24/2018 Fools day is 04/01/2018 Christmas day was 12/24/2018 ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:17:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"伪随机数产生器 CSPRNG bin2hex() - 函数把包含数据的二进制字符串转换为十六进制值。 \u003c?php $array = [ bin2hex(random_bytes(4)), bin2hex(random_bytes(16)), random_int(10, 99), random_int(1000, 9999), ]; print_r($array); // 结果 Array ( [0] =\u003e 49a44caf [1] =\u003e ae67bae0c8695dc6684dddb31364ea0e [2] =\u003e 59 [3] =\u003e 6021 ) ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:18:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"错误处理方式 在 PHP7 中改变了大多数错误的报告方式。不再通过 PHP5 使用的传统错误报告机制来报告错误，现在大多数错误被作为 Error 异常抛出。这种 Error 异常可以像 Exception 异常一样被第一个匹配的 try / catch 块所捕获。如果没有匹配的 catch 块，则调用异常处理函数（事先通过 set_exception_handler() 注册）进行处理。如果尚未注册异常处理函数，则按照传统方式处理：被报告为一个致命错误（Fatal Error）。 由于错误层次结构不从 Exception 扩展，因此使用 catch（Exception $ e）{...} 块处理 PHP5 中未捕获的异常的代码将不会处理此类错误。需要一个 catch（Error $ e）{...} 块或一个 set_exception_handler() 处理程序来处理致命错误。 Error 层次结构 - Throwable - Error - ArithmeticError - DivisionByZeroError - AssertionError - ParseError - TypeError - Exception - ... \u003c?php class Division { protected $value = 100; public function doDivision() : string { try { $value = $this-\u003evalue % 0; } catch (DivisionByZeroError $e) { return $e-\u003egetMessage(); } } } $division = new Division(); print $division-\u003edoDivision(); // 结果 Modulo by zero ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:19:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"弃用的功能 ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:20:0","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"弃用 PHP4 风格的构造函数 \u003c?php class Test { public function Test() { print __METHOD__; } } new Test(); // 结果 PHP Deprecated : Methods with the same name as their class will not be constructors in a future version of PHP; Test has a deprecated constructor in ... Deprecated : Methods with the same name as their class will not be constructors in a future version of PHP; Test has a deprecated constructor in ... Test::Test ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:20:1","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"弃用了静态调用非静态方法 \u003c?php class Test { public function get() { print 'non-static call.'; } } Test::get(); // 结果 PHP Deprecated: Non-static method Test::get() should not be called statically in ... ... Deprecated: Non-static method Test::get() should not be called statically in ... ... non-static call. ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:20:2","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"password_hash() salt 选项被弃用 函数原 salt 不再需要由开发者提供了。函数内部默认带有 salt 能力，无需开发者提供 salt 值 ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:20:3","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"capture_session_meta SSL 上下文选项被弃用 该 capture_session_meta SSL 上下文选项已被弃用。现在，通过 stream_get_meta_data() 函数使用 SSL 元数据 ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:20:4","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"移除的扩展 ereg mssql mysql sybase_ct ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:20:5","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"移除的 SAPI PHP7+ 版本移除了以下 SAPI。 aolserver apache apache_hooks apache2filter caudium continuity isapi milter nsapi phttpd pi3web roxen thttpd tux webjames ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:20:6","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["PHP"],"content":"移除的函数列表 从 PHP-4.1.0 开始被废弃了 call_user_func() 和 call_user_func_array()； 已废弃的 mcrypt_generic_end() 函数已被移除，可以使用 mcrypt_generic_deinit() 代替； 已废弃的 mcrypt_ecb()、mcrypt_cbc()、 mcrypt_cfb() 和 mcrypt_ofb() 函数已被移除； set_magic_quotes_runtime() （别名：magic_quotes_runtime()）已被移除；它们在 PHP5.3.0 中已经被废弃，并且在 PHP5.4.0 也由于魔术引号的废弃而失去功能； 已废弃的 set_socket_blocking() 函数已被移除，您可以使用 stream_set_blocking() 代替； 在 PHP-FPM 不再使用 dl()，在 CLI 和 embed SAPIs 中仍可用； GD 库中下列函数被移除：imagepsbbox()、imagepsencodefont()、imagepsextendfont()、imagepsfreefont()、imagepsloadfont()、imagepsslantfont()、imagepstext()； 在配置文件 php.ini 中，always_populate_raw_post_data、asp_tags、xsl.security_prefs 被移除了； ","date":"2018-01-19","objectID":"/posts/php-php7-new-features/:20:7","tags":["PHP"],"title":"PHP7 新特性","uri":"/posts/php-php7-new-features/"},{"categories":["MySQL"],"content":"在实际的查询过程中会经常查询一些最值的情况，看着那些六亲不认的 SQL，我诚惶诚恐的先记录一下。 MySQL 数据类型 MySQL 用户管理 MySQL 关键字查询 MySQL 字符串函数 MySQL 字符串连接函数 MySQL 忘记 root 密码后重置 MySQL 最值查询 MySQL 日期时间函数 MySQL 联合查询 MySQL 查询当前年、季、月、周的第一天和最后一天 MySQL 支持 emoji 图标的设置 MySQL 存储引擎 MySQL 隔离级别及其脏读不可重复读幻读 ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:0:0","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"数据准备 查询前请先导入实例数据，此实例数据由 Navicat 客户端导出。 /* Navicat Premium Data Transfer Source Server : localhost Source Server Type : MySQL Source Server Version : 50714 Source Host : 127.0.0.1 Source Database : test Target Server Type : MySQL Target Server Version : 50714 File Encoding : utf-8 Date: 03/07/2017 21:29:35 PM */ SET NAMES utf8mb4; SET FOREIGN_KEY_CHECKS = 0; -- ---------------------------- -- Table structure for `test` -- ---------------------------- DROP TABLE IF EXISTS `test`; CREATE TABLE `test` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键 Id', `key` varchar(45) NOT NULL COMMENT '键名', `val` varchar(45) NOT NULL COMMENT '键值', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=33 DEFAULT CHARSET=utf8 COMMENT='测试表'; -- ---------------------------- -- Records of `test` -- ---------------------------- BEGIN; INSERT INTO `test` VALUES ('1', 'a', '10'), ('2', 'a', '11'), ('3', 'a', '12'), ('4', 'a', '13'), ('5', 'a', '14'), ('6', 'a', '15'), ('7', 'a', '16'), ('8', 'a', '17'), ('9', 'a', '18'), ('10', 'a', '19'), ('11', 'b', '20'), ('12', 'b', '21'), ('13', 'b', '22'), ('14', 'b', '23'), ('15', 'b', '24'), ('16', 'b', '25'), ('17', 'b', '26'), ('18', 'b', '27'), ('19', 'b', '28'), ('20', 'b', '29'), ('21', 'c', '30'), ('22', 'c', '31'), ('23', 'c', '32'), ('24', 'c', '33'), ('25', 'c', '34'), ('26', 'c', '35'), ('27', 'd', '40'), ('28', 'd', '41'), ('29', 'd', '42'), ('30', 'd', '43'), ('31', 'd', '44'), ('32', 'd', '45'); COMMIT; SET FOREIGN_KEY_CHECKS = 1; ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:1:0","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"按 key 分组取 val 最大的值所在行的记录 ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:2:0","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"方法一 SELECT a.`id`, a.`key`, MAX(a.`val`) AS val FROM test.test AS a GROUP BY a.`key`; ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:2:1","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"方法二 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE a.`val` = (SELECT MAX(b.`val`) FROM test.test AS b WHERE b.`key` = a.`key`) ORDER BY a.`key`; ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:2:2","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"方法三 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE NOT EXISTS(SELECT 1 FROM test.test AS b WHERE b.`key` = a.`key` AND b.`val` \u003e a.`val`); ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:2:3","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"方法四 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a, (SELECT `key`, MAX(`val`) AS val FROM test.test GROUP BY `key`) AS b WHERE a.`key` = b.`key` AND a.`val` = b.`val` ORDER BY a.`key`; ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:2:4","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"方法五 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a INNER JOIN (SELECT `key`, MAX(`val`) AS `val` FROM test.test GROUP BY `key`) AS b ON b.`key` = a.`key` AND b.`val` = a.`val` ORDER BY a.`key`; ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:2:5","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"方法六 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE 1 \u003e (SELECT COUNT(*) FROM test.test AS b WHERE b.`key` = a.`key` AND b.`val` \u003e a.`val`) ORDER BY a.`key`; ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:2:6","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"按 key 分组取 val 最小的值所在行的数据 ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:3:0","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"方法一 SELECT a.`id`, a.`key`, MIN(a.`val`) AS val FROM test.test AS a GROUP BY a.`key`; ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:3:1","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"方法二 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE a.`val` = (SELECT MIN(b.`val`) FROM test.test AS b WHERE b.`key` = a.`key`) ORDER BY a.`key`; ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:3:2","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"方法三 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE NOT EXISTS(SELECT 1 FROM test.test AS b WHERE b.`key` = a.`key` AND b.`val` \u003c a.`val`); ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:3:3","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"方法四 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a, (SELECT `key`, MIN(`val`) AS val FROM test.test GROUP BY `key`) AS b WHERE a.`key` = b.`key` AND a.`val` = b.`val` ORDER BY a.`key`; ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:3:4","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"方法五 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a INNER JOIN (SELECT `key`, MIN(`val`) AS val FROM test.test GROUP BY `key`) AS b ON b.`key` = a.`key` AND b.`val` = a.`val` ORDER BY a.`key`; ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:3:5","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"方法六 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE 1 \u003e (SELECT COUNT(*) FROM test.test AS b WHERE b.`key` = a.`key` AND b.`val` \u003c a.`val`) ORDER BY a.`key`; ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:3:6","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"按 key 分组取最大的两个 val 所在行的数据 ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:4:0","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"方法一 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE 2 \u003e (SELECT COUNT(*) FROM test.test AS b WHERE b.`key` = a.`key` AND b.`val` \u003e a.`val`) ORDER BY a.`key`; ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:4:1","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"方法二 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE EXISTS( SELECT COUNT(*) FROM test.test AS b WHERE b.`key` = a.`key` AND b.`val` \u003e a.`val` HAVING COUNT(*) \u003c 2 ) ORDER BY a.`key`; ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:4:2","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"按 key 分组取最小的两个 val 所在行的数据 ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:5:0","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"方法一 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE 2 \u003e ( SELECT COUNT(*) FROM test.test AS b WHERE b.`key` = a.`key` AND b.`val` \u003c a.`val` ) ORDER BY a.`key`; ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:5:1","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["MySQL"],"content":"方法二 SELECT a.`id`, a.`key`, a.`val` FROM test.test AS a WHERE EXISTS( SELECT COUNT(*) FROM test.test AS b WHERE b.`key` = a.`key` AND b.`val` \u003c a.`val` HAVING COUNT(*) \u003c 2 ) ORDER BY a.`key`; ","date":"2018-01-18","objectID":"/posts/mysql-max-min-query/:5:2","tags":["MySQL"],"title":"MySQL 最值查询","uri":"/posts/mysql-max-min-query/"},{"categories":["PHP"],"content":"Composer 是 PHP 的一个依赖管理工具。它允许你申明项目所依赖的代码库，它会在你的项目中为你安装他们。 Composer Homepage Composer GitHub Composer 英文文档 Composer 中文文档 Coomposer 中国全量镜像 ","date":"2018-01-18","objectID":"/posts/php-composer/:0:0","tags":["PHP"],"title":"PHP 依赖管理器","uri":"/posts/php-composer/"},{"categories":["PHP"],"content":"安装 ","date":"2018-01-18","objectID":"/posts/php-composer/:1:0","tags":["PHP"],"title":"PHP 依赖管理器","uri":"/posts/php-composer/"},{"categories":["PHP"],"content":"Linux 局部安装 局部安装一般指当前下载安装的目录。 // 命令安装 $ curl -sS https://getcomposer.org/installer | php // 获取更多的信息 $ curl -sS https://getcomposer.org/installer | php -- --help 如果上述方法安装失败，可使用 php 命令下载安装 $ php -r \"readfile('https://getcomposer.org/installer');\" | php 或者 $ php -r \"copy('https://getcomposer.org/installer', 'composer-setup.php');\" $ php -r \"if (hash_file('SHA384', 'composer-setup.php') === '544e09ee996cdf60ece3804abc52599c22b1f40f4323403c44d44fdfdd586475ca9813a858088ffbc1f233e9b180f061') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;\" $ php composer-setup.php $ php -r \"unlink('composer-setup.php');\" 全局安装 全局安装其实就是把 composer 命令放到环境系统变量识别的路径中。 $ sudo mv composer.phar /usr/local/bin/composer $ sudo chmod +x /usr/local/bin/composer 如果命令因为权限执行失败，请使用 sudo 再次尝试运行 mv 那行命令。 ","date":"2018-01-18","objectID":"/posts/php-composer/:1:1","tags":["PHP"],"title":"PHP 依赖管理器","uri":"/posts/php-composer/"},{"categories":["PHP"],"content":"Mac 默认情况下，通过 brew 安装的可执行命令在 /usr/local/bin 目录中做了软链。 $ brew search composer $ brew install composer $ composer -V ","date":"2018-01-18","objectID":"/posts/php-composer/:1:2","tags":["PHP"],"title":"PHP 依赖管理器","uri":"/posts/php-composer/"},{"categories":["PHP"],"content":"Windows 自动安装 下载 Composer-Setup.exe，双击直接安装即可 手动安装 如果收到 readfile 错误提示，使用 http 链接或者在 php.ini 中开启 php_openssl.dll C:\\Users\\username\u003ecd C:\\bin C:\\bin\u003ephp -r \"readfile('https://getcomposer.org/installer');\" | php 在 composer.phar 同级目录下新建文件 composer.bat C:\\bin\u003eecho @php \"%~dp0composer.phar\" %*\u003ecomposer.bat 关闭当前的命令行窗口，打开新的命令行窗口进行测试 C:\\Users\\username\u003ecomposer -V ","date":"2018-01-18","objectID":"/posts/php-composer/:1:3","tags":["PHP"],"title":"PHP 依赖管理器","uri":"/posts/php-composer/"},{"categories":["PHP"],"content":"使用 ","date":"2018-01-18","objectID":"/posts/php-composer/:2:0","tags":["PHP"],"title":"PHP 依赖管理器","uri":"/posts/php-composer/"},{"categories":["PHP"],"content":"创建项目依赖 // 创建 composer.json 文件 $ composer init ","date":"2018-01-18","objectID":"/posts/php-composer/:2:1","tags":["PHP"],"title":"PHP 依赖管理器","uri":"/posts/php-composer/"},{"categories":["PHP"],"content":"安装项目依赖 // 安装依赖 $ composer install ","date":"2018-01-18","objectID":"/posts/php-composer/:2:2","tags":["PHP"],"title":"PHP 依赖管理器","uri":"/posts/php-composer/"},{"categories":["PHP"],"content":"更新项目依赖 // 更新依赖 $ composer update ","date":"2018-01-18","objectID":"/posts/php-composer/:2:3","tags":["PHP"],"title":"PHP 依赖管理器","uri":"/posts/php-composer/"},{"categories":["PHP"],"content":"镜像 ","date":"2018-01-18","objectID":"/posts/php-composer/:3:0","tags":["PHP"],"title":"PHP 依赖管理器","uri":"/posts/php-composer/"},{"categories":["PHP"],"content":"系统全局配置 将配置信息添加到 Composer 的全局配置文件 config.json 中： $ composer config -g repo.packagist composer https://packagist.phpcomposer.com ","date":"2018-01-18","objectID":"/posts/php-composer/:3:1","tags":["PHP"],"title":"PHP 依赖管理器","uri":"/posts/php-composer/"},{"categories":["PHP"],"content":"单个项目配置 将配置信息添加到某个项目的 composer.json 文件中： $ composer config repo.packagist composer https://packagist.phpcomposer.com 上述命令将会在项目的 composer.json 文件的末尾自动添加镜像的配置信息： \"repositories\": { \"packagist\": { \"type\": \"composer\", \"url\": \"https://packagist.phpcomposer.com\" } } ","date":"2018-01-18","objectID":"/posts/php-composer/:3:2","tags":["PHP"],"title":"PHP 依赖管理器","uri":"/posts/php-composer/"},{"categories":["PHP"],"content":"魔术方法是一种特殊的方法，当对对象执行某些操作时会覆盖 PHP 的默认操作。 ","date":"2018-01-18","objectID":"/posts/php-magix-methods/:0:0","tags":["PHP"],"title":"PHP 魔术方法","uri":"/posts/php-magix-methods/"},{"categories":["PHP"],"content":"魔术方法 PHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了心下魔术方法，建议不要以 __ 为前缀。 名称 说明 备注 __construct() 类的构造函数 __destruct() 类的析构函数 __call() 在对象中调用一个不可访问方法时调用 __callStatic() 用静态方式中调用一个不可访问方法时调用 __get() 获得一个类的成员变量时调用 __set() 设置一个类的成员变量时调用 __isset() 当对不可访问属性调用 isset() 或 empty() 时调用 __unset() 当对不可访问属性调用 unset() 时被调用 __sleep() 执行 serialize() 时，先会调用这个函数 __wakeup() 执行 unserialize() 时，先会调用这个函数 __toString() 用于一个类被当成字符串时应怎样回应 __invoke() 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用 __set_state() 调用 var_export() 导出类时，此静态方法会被调用 __clone() 当复制完成时，如果定义了 __clone() 方法，则新创建的对象（复制生成的对象）中的 __clone() 方法会被调用，可用于修改属性的值（如果有必要的话） __debugInfo() 当打印一个对象以获取显示的属性时，此方法被 var_dump() 调用。如果此方法未在对象上定义，则将显示所有公开的，受保护的和私有的属性 ","date":"2018-01-18","objectID":"/posts/php-magix-methods/:1:0","tags":["PHP"],"title":"PHP 魔术方法","uri":"/posts/php-magix-methods/"},{"categories":["PHP"],"content":"方法实例 ","date":"2018-01-18","objectID":"/posts/php-magix-methods/:2:0","tags":["PHP"],"title":"PHP 魔术方法","uri":"/posts/php-magix-methods/"},{"categories":["PHP"],"content":"__construct() 和 __destruct() \u003c?php class Object { public function __construct() { echo __METHOD__ . PHP_EOL; } public function __destruct() { echo __METHOD__ . PHP_EOL; } } class Test extends Object { public function __construct() { echo __METHOD__ . PHP_EOL; parent::__construct(); } public function __destruct() { echo __METHOD__ . PHP_EOL; parent::__destruct(); } } new Test(); // 结果 Test::__construct Object::__construct Test::__destruct Object::__destruct ","date":"2018-01-18","objectID":"/posts/php-magix-methods/:2:1","tags":["PHP"],"title":"PHP 魔术方法","uri":"/posts/php-magix-methods/"},{"categories":["PHP"],"content":"__call() 和 __callStatic() \u003c?php class Object { public function __call($name, $arguments) { echo \"Calling object method '$name' \" . implode(', ', $arguments) . PHP_EOL; } public static function __callStatic($name, $arguments) { echo \"Calling static method '$name' \" . implode(', ', $arguments) . PHP_EOL; } } $object = new Object(); $object-\u003egetCall('in object context'); Object::getCallStatic('in static context'); // 结果 Calling object method 'getCall' in object context Calling static method 'getCallStatic' in static context ","date":"2018-01-18","objectID":"/posts/php-magix-methods/:2:2","tags":["PHP"],"title":"PHP 魔术方法","uri":"/posts/php-magix-methods/"},{"categories":["PHP"],"content":"__get(), __set(), __isset(), __unset() \u003c?php class Object { private $data = []; public function __set($key, $val) { echo __METHOD__ . PHP_EOL; $this-\u003edata[$key] = $val; } public function __get($key) { if (array_key_exists($key, $this-\u003edata)) { echo __METHOD__ . PHP_EOL; return $this-\u003edata[$key]; } return null; } public function __isset($key) { echo __METHOD__ . PHP_EOL; return isset($this-\u003edata[$key]); } public function __unset($key) { echo __METHOD__ . PHP_EOL; unset($this-\u003edata[$key]); } } $object = new Object(); $object-\u003eproperty = 'This is the property of the object.'; $object-\u003eproperty; isset($object-\u003eproperty); unset($object-\u003eproperty); // 结果 Object::__set Object::__get Object::__isset Object::__unset ","date":"2018-01-18","objectID":"/posts/php-magix-methods/:2:3","tags":["PHP"],"title":"PHP 魔术方法","uri":"/posts/php-magix-methods/"},{"categories":["PHP"],"content":"__sleep() 和 __wakeup \u003c?php class Object { protected $link; private $server, $username, $password, $database; public function __construct($server, $username, $password, $database) { echo __METHOD__ . PHP_EOL; $this-\u003eserver = $server; $this-\u003eusername = $username; $this-\u003epassword = $password; $this-\u003edatabase = $database; } public function __sleep() { echo __METHOD__ . PHP_EOL; return ['server', 'username', 'password', 'database']; } public function __wakeup() { echo __METHOD__ . PHP_EOL; $this-\u003econnect(); } private function connect() { echo __METHOD__ . PHP_EOL; $this-\u003elink = mysqli_connect( $this-\u003eserver, $this-\u003eusername, $this-\u003epassword ); } } $object = new Object('localhost', 'root', '', 'test'); $serialize = serialize($object); unserialize($serialize); // 结果 Object::__construct Object::__sleep Object::__wakeup Object::connect ","date":"2018-01-18","objectID":"/posts/php-magix-methods/:2:4","tags":["PHP"],"title":"PHP 魔术方法","uri":"/posts/php-magix-methods/"},{"categories":["PHP"],"content":"__toString() \u003c?php class Object { public function __toString() { return __METHOD__; } } $object = new Object(); echo $object; // 结果 Object::__toString ","date":"2018-01-18","objectID":"/posts/php-magix-methods/:2:5","tags":["PHP"],"title":"PHP 魔术方法","uri":"/posts/php-magix-methods/"},{"categories":["PHP"],"content":"__invoke() \u003c?php class Object { public function __invoke() { echo __METHOD__ . PHP_EOL; } } $object = new Object(); var_dump(is_callable($object())); // 结果 Object::__invoke bool(false) ","date":"2018-01-18","objectID":"/posts/php-magix-methods/:2:6","tags":["PHP"],"title":"PHP 魔术方法","uri":"/posts/php-magix-methods/"},{"categories":["PHP"],"content":"__set_state() \u003c?php class Object { public $a; public $b; public static function __set_state(array $array) { echo __METHOD__ . PHP_EOL; $object = new Object(); $object-\u003ea = $array['a']; $object-\u003eb = $array['b']; return $object; } } $object = new Object(); $object-\u003ea = 'this is a'; $object-\u003eb = 'this is b'; eval('$b = ' . var_export($object, true) . ';'); var_dump($b); // 结果 Object::__set_state object(Object)#2 (2) { [\"a\"]=\u003e string(9) \"this is a\" [\"b\"]=\u003e string(9) \"this is b\" } ","date":"2018-01-18","objectID":"/posts/php-magix-methods/:2:7","tags":["PHP"],"title":"PHP 魔术方法","uri":"/posts/php-magix-methods/"},{"categories":["PHP"],"content":"__clone() \u003c?php class Object { public static $count = 0; public $instance; public function __construct() { echo __METHOD__ . PHP_EOL; $this-\u003einstance = ++self::$count; } public function __clone() { echo __METHOD__ . PHP_EOL; $this-\u003einstance = ++self::$count; } } class Cloneable { public $object1; public $object2; public function __construct() { echo __METHOD__ . PHP_EOL; } public function __clone() { echo __METHOD__ . PHP_EOL; // 强制复制一份 this-\u003eobject，否则仍然指向同一个对象 $this-\u003eobject1 = clone $this-\u003eobject1; } } $cloneable = new Cloneable(); $cloneable-\u003eobject1 = new Object(); $cloneable-\u003eobject2 = new Object(); $clone = clone $cloneable; print \"Original Object:\\n\"; var_dump($cloneable); print \"Cloned Object:\\n\"; var_dump($clone); // 结果 Cloneable::__construct Object::__construct Object::__construct Cloneable::__clone Object::__clone Original Object: class Cloneable#1 (2) { public $object1 =\u003e class Object#2 (1) { public $instance =\u003e int(1) } public $object2 =\u003e class Object#3 (1) { public $instance =\u003e int(2) } } Cloned Object: class Cloneable#4 (2) { public $object1 =\u003e class Object#5 (1) { public $instance =\u003e int(3) } public $object2 =\u003e class Object#3 (1) { public $instance =\u003e int(2) } } ","date":"2018-01-18","objectID":"/posts/php-magix-methods/:2:8","tags":["PHP"],"title":"PHP 魔术方法","uri":"/posts/php-magix-methods/"},{"categories":["PHP"],"content":"__debugInfo() \u003c?php date_default_timezone_set('PRC'); class Object { public $year, $month, $day, $hour, $minute, $second; public function __debugInfo() { $date = $this-\u003eyear . '-' . $this-\u003emonth . '-' . $this-\u003eday; $time = $this-\u003ehour . ':' . $this-\u003eminute . ':' . $this-\u003esecond; $datetime = $date . ' ' . $time; return [ 'date' =\u003e $date, 'time' =\u003e $time, 'datetime' =\u003e $datetime, 'property' =\u003e call_user_func('get_object_vars', $this), ]; } } $object = new Object(); $object-\u003eyear = date('Y'); $object-\u003emonth = date('m'); $object-\u003eday = date('d'); $object-\u003ehour = date('H'); $object-\u003eminute = date('i'); $object-\u003esecond = date('s'); var_dump($object); // 结果 class Object#1 (4) { public $date =\u003e string(10) \"2018-01-18\" public $time =\u003e string(8) \"17:27:45\" public $datetime =\u003e string(19) \"2018-01-18 17:27:45\" public $property =\u003e array(6) { 'year' =\u003e string(4) \"2018\" 'month' =\u003e string(2) \"01\" 'day' =\u003e string(2) \"18\" 'hour' =\u003e string(2) \"17\" 'minute' =\u003e string(2) \"27\" 'second' =\u003e string(2) \"45\" } } ","date":"2018-01-18","objectID":"/posts/php-magix-methods/:2:9","tags":["PHP"],"title":"PHP 魔术方法","uri":"/posts/php-magix-methods/"},{"categories":["PHP"],"content":"魔术常量 名称 说明 备注 __LINE__ 文件中的当前行号 __FILE__ 文件的完整路径和文件名 __DIR__ 文件所在的目录 __FUNCTION__ 函数名称 __CLASS__ 类的名称 __TRAIT__ Trait 的名字 __METHOD__ 类的方法名 __NAMESPACE__ 当前命名空间的名称 \u003c?php namespace App; trait ObjectTrait { public function getTrait() { echo __TRAIT__ . PHP_EOL; } } class Object { use ObjectTrait; public function __construct() { echo __LINE__ . PHP_EOL; echo __FILE__ . PHP_EOL; echo __DIR__ . PHP_EOL; echo __FUNCTION__ . PHP_EOL; echo __CLASS__ . PHP_EOL; echo $this-\u003egetTrait(); echo __METHOD__ . PHP_EOL; } } $object = new Object(); // 结果 19 /Users/xxx/Downloads/test/vscode.php /Users/xxx/Downloads/test __construct App\\Object App\\ObjectTrait App\\Object::__construct ","date":"2018-01-18","objectID":"/posts/php-magix-methods/:3:0","tags":["PHP"],"title":"PHP 魔术方法","uri":"/posts/php-magix-methods/"},{"categories":["PHP"],"content":"概述 PHP 提供了一种 CLI SAPI - Server Application Programming Interface，服务端应用编程接口的支持，意为 CLI - Command Line Interface，即命令行接口。也是 Web 脚本语言 PHP 在系统命令行（Shell）下的另一种形式，用户可以在系统命令中使用 PHP 编写交互代码。 ","date":"2018-01-18","objectID":"/posts/php-command-line-interface/:1:0","tags":["PHP"],"title":"PHP Command Line Interface","uri":"/posts/php-command-line-interface/"},{"categories":["PHP"],"content":"作用 开发外壳应用。 ","date":"2018-01-18","objectID":"/posts/php-command-line-interface/:2:0","tags":["PHP"],"title":"PHP Command Line Interface","uri":"/posts/php-command-line-interface/"},{"categories":["PHP"],"content":"CLI SAPI 和其它 SAPI 模块的区别 与 CGI SAPI 不同，其输出没有任何头信息 CLI SAPI 强制覆盖了 php.ini 中的某些设置，因为这些设置在外壳环境下是没有意义 为了减轻外壳环境下的工作，定义了如下常量 名称 描述 备注 STDIN 一个已打开的指向 stdin 的流，调用方法：$stdin = fopen('php://stdin', 'r'); STDOUT 一个已打开的指向 stdout 的流，调用方法：$stdout = fopen(‘php://stdout’, ‘w’); STDERR 一个已打开的指向 stderr 的流， 调用方法：$stderr = fopen(‘php://stderr’, ‘w’); CLI SAPI 不会将当前目录改为已运行的脚本所在的目录 ","date":"2018-01-18","objectID":"/posts/php-command-line-interface/:3:0","tags":["PHP"],"title":"PHP Command Line Interface","uri":"/posts/php-command-line-interface/"},{"categories":["PHP"],"content":"CLI SAPI 模块的三种运行方式 ","date":"2018-01-18","objectID":"/posts/php-command-line-interface/:4:0","tags":["PHP"],"title":"PHP Command Line Interface","uri":"/posts/php-command-line-interface/"},{"categories":["PHP"],"content":"让 PHP 运行指定文件 $ php test.php 或者 $ php -f test.php ","date":"2018-01-18","objectID":"/posts/php-command-line-interface/:4:1","tags":["PHP"],"title":"PHP Command Line Interface","uri":"/posts/php-command-line-interface/"},{"categories":["PHP"],"content":"在命令行直接运行 PHP 代码 $ php -r 'print_r(get_defined_constants());' ","date":"2018-01-18","objectID":"/posts/php-command-line-interface/:4:2","tags":["PHP"],"title":"PHP Command Line Interface","uri":"/posts/php-command-line-interface/"},{"categories":["PHP"],"content":"通过标准输入 stdin 提供需要运行的 PHP 代码 PHP CLI 应用场景 ","date":"2018-01-18","objectID":"/posts/php-command-line-interface/:4:3","tags":["PHP"],"title":"PHP Command Line Interface","uri":"/posts/php-command-line-interface/"},{"categories":["PHP"],"content":"多线程应用 使用多进程，子进程结束以后，内核会负责回收资源 使用多进程，子进程异常退出不会导致整个进程 Thread 退出，父进程还有机会重建流程 一个常驻主进程，只负责任务分发，逻辑理清楚 ","date":"2018-01-18","objectID":"/posts/php-command-line-interface/:4:4","tags":["PHP"],"title":"PHP Command Line Interface","uri":"/posts/php-command-line-interface/"},{"categories":["PHP"],"content":"定时执行 PHP 程序 利用 Linux 的 crontab 命令，文件路径建议使用绝对路径。 \u003c?php // The task you plan to perform echo 'PHP is the best programming language.'; $ crontab -e // 每分钟执行一次脚本并且输出 * * * * * /usr/bin/php /usr/local/src/test.php // 每分钟执行一次脚本并且在后台运行 * * * * * /usr/bin/php /usr/local/src/test.php \u003e/dev/null 2\u003e\u00261 ","date":"2018-01-18","objectID":"/posts/php-command-line-interface/:4:5","tags":["PHP"],"title":"PHP Command Line Interface","uri":"/posts/php-command-line-interface/"},{"categories":["PHP"],"content":"开发桌面程序 使用 PHP CLI 和 GTK 包。 ","date":"2018-01-18","objectID":"/posts/php-command-line-interface/:4:6","tags":["PHP"],"title":"PHP Command Line Interface","uri":"/posts/php-command-line-interface/"},{"categories":["PHP"],"content":"Linux 下编写 PHP 的 Shell 脚本 ","date":"2018-01-18","objectID":"/posts/php-command-line-interface/:4:7","tags":["PHP"],"title":"PHP Command Line Interface","uri":"/posts/php-command-line-interface/"},{"categories":["PHP"],"content":"PHP CLI 实例 ","date":"2018-01-18","objectID":"/posts/php-command-line-interface/:5:0","tags":["PHP"],"title":"PHP Command Line Interface","uri":"/posts/php-command-line-interface/"},{"categories":["PHP"],"content":"PHP CLI 进阶 ","date":"2018-01-18","objectID":"/posts/php-command-line-interface/:6:0","tags":["PHP"],"title":"PHP Command Line Interface","uri":"/posts/php-command-line-interface/"},{"categories":["PHP"],"content":"PHP 实现两个日期之间相差的几年、几月、几日……，可以采用 PHP 内置的类 DateTime 和函数 strtotime() 实现，推荐使用内置类 DateTime 去实现，DateTime 把每个月天数的差异自动处理了，使用 strtotime() 函数需要自行处理。 ","date":"2018-01-15","objectID":"/posts/php-calculate-date/:0:0","tags":["PHP"],"title":"PHP - 计算出两个日期之间的差值","uri":"/posts/php-calculate-date/"},{"categories":["PHP"],"content":"计算出两个日期之间的差值 Representation of date and time \u003c?php function getDateDiff($date1, $date2) { $datetime1 = new \\DateTime($date1); $datetime2 = new \\DateTime($date2); $interval = $datetime1-\u003ediff($datetime2); $datetime = []; $items = [ 'year' =\u003e 'y', 'month' =\u003e 'm', 'day' =\u003e 'd', 'hour' =\u003e 'H', 'minute' =\u003e 'i', 'second' =\u003e 's', 'days' =\u003e 'a', ]; foreach ($items as $key =\u003e $format) { $datetime[$key] = $interval-\u003eformat(\"%{$format}\"); } return $datetime; } $date1 = '2016-12-12 09:45:45'; $date2 = '2018-01-15 10:55:55'; $array = getDateDiff($date1, $date2); print_r($array); // 结果 Array ( [year] =\u003e 1 [month] =\u003e 1 [day] =\u003e 3 [hour] =\u003e 01 [minute] =\u003e 10 [second] =\u003e 10 [days] =\u003e 399 ) 也就是说这两个日期之间的差值为：1 年 1 个月 3 天 1 小时 10 分钟 10 秒，总共 399 天 ","date":"2018-01-15","objectID":"/posts/php-calculate-date/:1:0","tags":["PHP"],"title":"PHP - 计算出两个日期之间的差值","uri":"/posts/php-calculate-date/"},{"categories":["PHP"],"content":"计算两个时期之间的月份数 \u003c?php $date1 = '2018-12-12 09:45:45'; $date2 = '2020-01-12 09:45:44'; $d1 = new \\DateTime($date1); $d2 = new \\DateTime($date2); echo $d1-\u003ediff($d2)-\u003em + ($d1-\u003ediff($d2)-\u003ey * 12); // 结果 12 从结果来看，不足一月会自动舍去 ","date":"2018-01-15","objectID":"/posts/php-calculate-date/:2:0","tags":["PHP"],"title":"PHP - 计算出两个日期之间的差值","uri":"/posts/php-calculate-date/"},{"categories":["PHP"],"content":"扩展的日期时间类 Carbon GitHub Carbon Website ","date":"2018-01-15","objectID":"/posts/php-calculate-date/:3:0","tags":["PHP"],"title":"PHP - 计算出两个日期之间的差值","uri":"/posts/php-calculate-date/"},{"categories":["PHP"],"content":"安装 // 使用 composer 安装 $ composer require nesbot/carbon ","date":"2018-01-15","objectID":"/posts/php-calculate-date/:3:1","tags":["PHP"],"title":"PHP - 计算出两个日期之间的差值","uri":"/posts/php-calculate-date/"},{"categories":["PHP"],"content":"实例 更多使用实例请参见官网 \u003c?php require 'vendor/autoload.php'; use Carbon\\Carbon; printf(\"Now: %s\", Carbon::now()); ","date":"2018-01-15","objectID":"/posts/php-calculate-date/:3:2","tags":["PHP"],"title":"PHP - 计算出两个日期之间的差值","uri":"/posts/php-calculate-date/"},{"categories":["Nginx"],"content":"KeepAlive 是长连接的意思。客户端发起 HTTP 请求前需要先与服务端建立 TCP 连接，每次TCP连接都需要三次握手来确定，三次交互不仅会增加消费时间，还会增加网络流量。HTTP 请求是请求应答式，如果能知道每个请求头与响应体的长度，就可以在一个连接上执行多个请求，这个就是所谓的长连接。 ","date":"2018-01-13","objectID":"/posts/nginx-keep-alive/:0:0","tags":["Nginx"],"title":"Nginx 支持 keep-alive 长连接","uri":"/posts/nginx-keep-alive/"},{"categories":["Nginx"],"content":"概念 Persistent HTTP connections have a number of advantages HTTP 协议采用请求-应答模式，当使用普通模式，即非 KeepAlive 模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP 协议为无连接的协议）；当使用 Keep-Alive 模式（又称持久连接/连接重用）时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。 ","date":"2018-01-13","objectID":"/posts/nginx-keep-alive/:1:0","tags":["Nginx"],"title":"Nginx 支持 keep-alive 长连接","uri":"/posts/nginx-keep-alive/"},{"categories":["Nginx"],"content":"支持 keep alive ","date":"2018-01-13","objectID":"/posts/nginx-keep-alive/:2:0","tags":["Nginx"],"title":"Nginx 支持 keep-alive 长连接","uri":"/posts/nginx-keep-alive/"},{"categories":["Nginx"],"content":"当使用 nginx 作为反向代理时，为了支持长连接，需要做到两点 从 client 到 nginx 的连接是长连接 从 nginx 到 server 的连接是长连接 ","date":"2018-01-13","objectID":"/posts/nginx-keep-alive/:2:1","tags":["Nginx"],"title":"Nginx 支持 keep-alive 长连接","uri":"/posts/nginx-keep-alive/"},{"categories":["Nginx"],"content":"保持和 client 的长连接 client 发送的 HTTP 请求要求 keep alive nginx 设置上支持 keep alive ","date":"2018-01-13","objectID":"/posts/nginx-keep-alive/:2:2","tags":["Nginx"],"title":"Nginx 支持 keep-alive 长连接","uri":"/posts/nginx-keep-alive/"},{"categories":["Nginx"],"content":"HTTP 配置 keepalive_timeout 默认 75s，一般情况下也够用，对于一些请求比较大的内部服务器通讯的场景，适当加大为 120s 或者 300s。第二个参数通常可以不用设置 第一个参数设置 keep-alive 客户端连接在服务器端保持开启的超时值。值为 0 会禁用 keep-alive 客户端连接。可选的第二个参数在响应的 header 域中设置一个值 Keep-Alive: timeout=time。这两个参数可以不一样 keepalive_requests 默认 100，对于 QPS 较高的场景，非常有必要加大这个参数，以避免出现大量连接被生成再抛弃的情况，减少 TIME_WAIT。这个参数的真实含义是指一个 keep alive 建立之后，nginx 就会为这个连接设置一个计数器，记录这个 keep alive 的长连接上已经接收并处理的客户端请求的数量。如果达到这个参数设置的最大值时，则 nginx 会强行关闭这个长连接，逼迫客户端不得不重新建立新的长连接 用于设置一个 keep-alive 连接上可以服务的请求的最大数量。当最大请求数量达到时，连接被关闭 ","date":"2018-01-13","objectID":"/posts/nginx-keep-alive/:2:3","tags":["Nginx"],"title":"Nginx 支持 keep-alive 长连接","uri":"/posts/nginx-keep-alive/"},{"categories":["Nginx"],"content":"保持和 server 的长连接 http { keepalive_timeout 100s; keepalive_requests 1000; upstream dev.proxy.com { server 192.168.10.11:8081 weight=1 max_fails=2 fail_timeout=30s; server 192.168.10.10:8081 weight=1 max_fails=2 fail_timeout=30s; keepalive 300; } server { listen 80 default_server; listen [::]:80 ipv6only=on; server_name dev.proxy.com; charset utf-8; location / { index index.php index.html index.htm; proxy_pass http://dev.proxy.com/; proxy_set_header Host $Host; proxy_set_header x-forwarded-for $remote_addr; proxy_set_header X-Real-IP $remote_addr; add_header Cache-Control no-store; add_header Pragma no-cache; proxy_http_version 1.1; proxy_set_header Connection \"\"; client_max_body_size 3072k; client_body_buffer_size 128k; } } } 合理的设置 keep-alive 值可以非常有效的缓冲请求和应答不均匀，缓解连接数量的反复震荡 连接数量震荡的两个表现 连接不够用，造成新建连接 连接空闲，造成关闭连接 统计在一台前端机上高峰时间 TCP 连接的情况 $ netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a,S[a]}' 导致 nginx 端出现大量 TIME_WAIT 的两种情况 keepalive_requests 设置比较小，高并发下超过此值后 nginx 会强制关闭和客户端保持的keepalive 长连接(主动关闭连接后导致 nginx 出现 TIME_WAIT) keepalive 设置的比较小(空闲数太小)，导致高并发下 nginx 会频繁出现连接数震荡(超过该值会关闭连接)，不停的关闭开启和后端 server 保持的 keep-alive 长连接 导致后端 server 端出现大量 TIME_WAIT 的情况 nginx 没有打开和后端的长连接，即：没有设置 proxy_http_version 1.1; 和proxy_set_header Connection \"\"; 从而导致后端 server 每次关闭连接，高并发下就会出现 server 端出现大量 TIME_WAIT ","date":"2018-01-13","objectID":"/posts/nginx-keep-alive/:2:4","tags":["Nginx"],"title":"Nginx 支持 keep-alive 长连接","uri":"/posts/nginx-keep-alive/"},{"categories":null,"content":" 🎆🌇🏙🌉🌆🌃🌌🌁 🌸 天行健，君子以自强不息；地势坤，君子以厚德载物。——《周易》 吴云洋 - 云风 思绪来得快去得也快，偶尔会在这里停留。 陈皓 - 左耳朵耗子 享受编程和技术所带来的快乐。 惠新宸 - 鸟哥 左手代码右手诗。 王垠 - 垠神 当然我在扯淡。 王渊命 - jolestar 技术上倾向于开源运动，政治上倾向于自由主义。 许式伟 连接数据，重塑价值。 Russ Cox What's grey? A melted penguin. 陶建辉 - Jeff Tao TDengine - 开源、高效的物联网大数据平台。 章亦春 - agentzh The Creator of OpenResty。 Lawrence Jones Working on building reliable infrastructure and tooling for GoCardless. Jake Wharton Stop stopping. Steve Francia Entrepreneurial, creative \u0026 empathetic leader with a healthy disregard for the impossible 鸟窝 大道至简 Simplicity is the ultimate form of sophistication 敖小剑 All in Dapr, all in Cloud Native! 🗾🎑🏞🌅🌄🌠🎇 🌺 不登高山，不知天之高也；不临深溪，不知地之厚也。——《荀子》 尤雨溪 一个前端，写了一个叫 Vue 的框架。 玉伯 因上努力，果上随缘。 张鑫旭 鑫空间，鑫生活。 大漠 CSS3、CSS 处理器和 Drupal 中国布道者。 司徒正美 - RubyLouvre 穿梭于二进制与二次元的 JS 魔术师。 朴灵 - JacksonTian Node.js \u0026 JavaScript 程劭非 - Winter 知乎吃枣药丸 吴亮 - 月影 十年踪迹 贺师俊 Web开发者 林建锋 - Sofish i create things 🚀🌸🌺🌼💐🌷🌹🌈 🌼 老当益壮，宁移白首之心？穷且益坚，不坠青云之志。——《滕王阁序》 KP - KeyPulse Yet Another 付费问答 宋力 - imind-lab 仁者见仁、智者见智。 刘三儿 天道酬勤，自强不息。 jinghongdaxiong 我想静静。 巨二大豆 没有太多的理由，只是在梦想的路上勇敢前行。 John Doe Good, better, best. Never let it rest. Rwkey 北漂码农 ","date":"2018-01-11","objectID":"/links/:0:0","tags":null,"title":"友链","uri":"/links/"},{"categories":null,"content":" 声明 🔥 本站所有文章均为本人学习实践后的加工整理，仅代表个人看法和观点，与其他任何人或组织无关！ ","date":"2018-01-11","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于 一个患有重度代码洁癖症的 PHP 开发者。 来自 甘肃，现居 北京。 KeyPulse: @imajinyun ","date":"2018-01-11","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"简介 { name: 'imajinyun', age: '🌈', gender: 'M', profession: 'Backend Developer', address: '🌏', education: '🙏', github: 'https://github.com/imajinyun', notes: 'https://imajinyun.xyz/', email: 'imajinyun@gmail.com', company: 'Working at Chope in China', description: '🚀🎉🧨', skills: { language: ['HTML+CSS+JS', 'Vue', 'PHP', 'Python', 'Go'], kitchain: { os: ['macOS', 'Linux -\u003e Ubuntu \u0026 CentOS', 'Windows'], vcs: ['GitLab', 'GitHub', 'Gitee', 'SVN'], store: ['MySQL', 'SQLite', 'Redis \u0026 Memcache', 'RabbitMQ \u0026 Kafka', 'MongoDB \u0026 DynamoDB'], server: ['Apache', 'Nginx'], platform: ['K8S', 'Docker', 'VirtualBox'], cloudservice: ['Aliyun', 'AWS', 'Qiniu'], cooperation: ['Jira', 'Confluence', 'Google Docs', 'Shimo'], communication: ['Slack', 'Discord', 'DingTalk'], }, devtools: ['Visual Studio Code', 'JetBrains Toolbox', 'NeoVim'], } } ","date":"2018-01-11","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"}]